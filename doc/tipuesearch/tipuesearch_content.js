var tipuesearch = {"pages":[{"text":"Fortran Program Post-analysis procedures for VPIC simulation. Install Depends on the compiler to use source module_gcc.sh or source module_intel.sh Run the following command to build the main program mkdir build cd build cmake .. make make install Get started The executables are all saved in this code's root directory.\nThe configuration files are in ./config_files . translate : processing the VPIC raw field data, which saved as an individual\nfile for each MPI process in PIC simulations. The processed data will be\nsaved in a single file or multiple files depending on the flags (see below).\nWhen doing translate , conf.dat and analysis_config.dat may need to be modified conf.dat httx, htty, httz: their produce should be the same as current total\nCPU numbers. Each of them should \\le the MPI topology of the PIC\nsimulation tindex_start: the default is 0, so the programe will translate the\nbeginning time frame. Change it when doing translate for a restart run,\nso you don't have to start from the beginning tindex_stop: set a large number, so the programe will translate all\nthe time frame. When testing the programe, set it small\noutput_format: when setting 1, each time frame saves one file.\nWhen setting 2, all time frames save in a single file. append_to_files: default is 1, so processed data will be appended to\nthe existing files analysis_config: is_rel should be 1 when all hydro data are dumped tp1, tp2: starting and ending time frame. They are output time frame,\nnot the actual time steps of the PIC simulations. inductive: using whole electric field when it is set 0; using motional\nelectric field -\\mathbf{v}\\times\\mathbf{B} when it is set 1. is_rel: whether relativistic fields are used eratio: the ratio of the energy interval to the initial thermal energy\nYou need to calculate this using emax and nex, defined in your\nconfiguration for this PIC simulation (**.cxx). parspec : get the particle energy spectrum in a box. The box can be the whole\nsimulation domain or a local small region. When doing parspec , spectrum_config.dat may need to be modified xc, yc, zc are the center of the box (in d_e). In the PIC simulations,\nx\\in[0, L_x], y\\in[-L_y/2, L_y/2], z\\in[-L_z/2, L_z/2] xsize, ysize and zsize: sizes of each dimension in cell numbers the rest is for velocity distribution. It can be ignored when\ndoing parspec dissipation : energy conversion analysis using \\mathbf{j}\\cdot\\mathbf{E}. analysis_config.dat (see above) and saving_flags.dat may be modified. saving_flags.dat When a flag is 1, the 2D/3D field data will be saved","tags":"","loc":"index.html","title":" Fortran Program "},{"text":"Module of the initial setup, including the energy bins, the maximum and\n minimum of the particle energy, the energy interval (both linear and\n logarithmic), the center of the box (de), the sizes of the box (cells). Source Code !******************************************************************************* ! Module of the initial setup, including the energy bins, the maximum and ! minimum of the particle energy, the energy interval (both linear and ! logarithmic), the center of the box (de), the sizes of the box (cells). !******************************************************************************* module spectrum_config use constants , only : fp , dp implicit none private public nbins , emax , emin , dve , dlogve , spatial_range , center , sizes , & tot_pic_mpi , pic_mpi_ranks , config_name public read_spectrum_config , set_spatial_range_de , calc_pic_mpi_ids , & calc_energy_interval , init_pic_mpi_ranks , free_pic_mpi_ranks , & calc_pic_mpi_ranks public corners_mpi , vmax , vmin , dv , nbins_vdist , tframe public calc_velocity_interval integer :: nbins real ( fp ) :: emax , emin , dve , dlogve real ( fp ) :: vmax , vmin , dv ! For velocity distribution. integer :: nbins_vdist integer :: tframe ! Time frame. real ( fp ), dimension ( 3 ) :: center ! In electron skin length (de). real ( fp ), dimension ( 3 ) :: sizes ! In number of cells. real ( fp ), dimension ( 2 , 3 ) :: spatial_range ! In electron skin length (de). integer , dimension ( 2 , 3 ) :: corners_mpi ! MPI IDs of the corners. integer :: tot_pic_mpi ! Total number of PIC MPI process. integer , allocatable , dimension (:) :: pic_mpi_ranks ! PIC MPI rank in 1D. character ( len = 64 ) :: config_name contains !--------------------------------------------------------------------------- ! Read the setup information from file. !--------------------------------------------------------------------------- subroutine read_spectrum_config use mpi_module use read_config , only : get_variable implicit none integer :: fh real ( fp ) :: temp fh = 10 open ( unit = fh , file = config_name , status = 'old' ) temp = get_variable ( fh , 'nbins' , '=' ) ! Number of energy bins nbins = int ( temp ) emax = get_variable ( fh , 'emax' , '=' ) ! Maximum energy emin = get_variable ( fh , 'emin' , '=' ) ! Minimum energy center ( 1 ) = get_variable ( fh , 'xc/de' , '=' ) ! x-coord of the box center center ( 2 ) = get_variable ( fh , 'yc/de' , '=' ) ! y-coord center ( 3 ) = get_variable ( fh , 'zc/de' , '=' ) ! z-coord sizes ( 1 ) = get_variable ( fh , 'xsize' , '=' ) ! Number of cells along x sizes ( 2 ) = get_variable ( fh , 'ysize' , '=' ) sizes ( 3 ) = get_variable ( fh , 'zsize' , '=' ) temp = get_variable ( fh , 'nbins_vdist' , '=' ) nbins_vdist = int ( temp ) vmax = get_variable ( fh , 'vmax' , '=' ) vmin = get_variable ( fh , 'vmin' , '=' ) temp = get_variable ( fh , 'tframe' , '=' ) tframe = int ( temp ) close ( fh ) call calc_energy_interval if ( myid == 0 ) then ! Echo this information print * , \"---------------------------------------------------\" write ( * , \"(A)\" ) \" Spectrum and velocity distribution information.\" write ( * , \"(A,I0)\" ) \" Number of energy bins = \" , nbins write ( * , \"(A,E14.6,E14.6)\" ) \" Minimum and maximum energy(gamma) = \" , & emin , emax write ( * , \"(A,3F6.2)\" ) \" Center of the box (de) = \" , center write ( * , \"(A,3F10.2)\" ) \" Sizes of the box (cells) = \" , sizes write ( * , \"(A,I0)\" ) \" Number of velocity bins = \" , nbins_vdist write ( * , \"(A,F6.2,F6.2)\" ) \" Minimum and maximum velocity(gamma) = \" , & vmin , vmax write ( * , \"(A,I0)\" ) \" Time frame of velocity distribution = \" , tframe print * , \"---------------------------------------------------\" endif end subroutine read_spectrum_config !--------------------------------------------------------------------------- ! Calculate the energy interval for each energy bin. !--------------------------------------------------------------------------- subroutine calc_energy_interval implicit none dve = emax / real ( nbins ) ! Linear-scale interval dlogve = ( log10 ( emax ) - log10 ( emin )) / real ( nbins ) ! Logarithmic-scale. end subroutine calc_energy_interval !--------------------------------------------------------------------------- ! Calculate velocity integral. !--------------------------------------------------------------------------- subroutine calc_velocity_interval implicit none dv = ( vmax - vmin ) / nbins_vdist end subroutine calc_velocity_interval !--------------------------------------------------------------------------- ! Initialize the pic_mpi_ranks 1D array. !--------------------------------------------------------------------------- subroutine init_pic_mpi_ranks implicit none allocate ( pic_mpi_ranks ( tot_pic_mpi )) pic_mpi_ranks = 0 end subroutine init_pic_mpi_ranks !--------------------------------------------------------------------------- ! Calculate the pic_mpi_ranks 1D array. !--------------------------------------------------------------------------- subroutine calc_pic_mpi_ranks use picinfo , only : domain implicit none integer :: i , j , k , tx , ty , tz , index1 tx = domain % pic_tx ty = domain % pic_ty tz = domain % pic_tz index1 = 0 do k = corners_mpi ( 1 , 3 ), corners_mpi ( 2 , 3 ) do j = corners_mpi ( 1 , 2 ), corners_mpi ( 2 , 2 ) do i = corners_mpi ( 1 , 1 ), corners_mpi ( 2 , 1 ) index1 = index1 + 1 pic_mpi_ranks ( index1 ) = i + j * tx + k * tx * ty enddo enddo enddo end subroutine calc_pic_mpi_ranks !--------------------------------------------------------------------------- ! Free the pic_mpi_ranks 1D array. !--------------------------------------------------------------------------- subroutine free_pic_mpi_ranks implicit none deallocate ( pic_mpi_ranks ) end subroutine free_pic_mpi_ranks !--------------------------------------------------------------------------- ! As the xsize, ysize, zsize are in number of cell, we shall set the spatial ! range in electron skin length (de). !--------------------------------------------------------------------------- subroutine set_spatial_range_de use picinfo , only : domain implicit none real ( fp ) :: dx , dy , dz , lx , ly , lz dx = domain % dx dy = domain % dy dz = domain % dz lx = domain % lx_de ly = domain % ly_de lz = domain % lz_de ! x spatial_range ( 1 , 1 ) = center ( 1 ) - 0.5 * sizes ( 1 ) * dx spatial_range ( 2 , 1 ) = center ( 1 ) + 0.5 * sizes ( 1 ) * dx if ( spatial_range ( 1 , 1 ) < 0.0 ) spatial_range ( 1 , 1 ) = 0.0 if ( spatial_range ( 2 , 1 ) > lx ) spatial_range ( 2 , 1 ) = lx ! y spatial_range ( 1 , 2 ) = center ( 2 ) - 0.5 * sizes ( 2 ) * dy spatial_range ( 2 , 2 ) = center ( 2 ) + 0.5 * sizes ( 2 ) * dy if ( spatial_range ( 1 , 2 ) < - ly / 2 ) spatial_range ( 1 , 2 ) = - ly / 2 if ( spatial_range ( 2 , 2 ) > ly / 2 ) spatial_range ( 2 , 2 ) = ly / 2 ! z spatial_range ( 1 , 3 ) = center ( 3 ) - 0.5 * sizes ( 3 ) * dz spatial_range ( 2 , 3 ) = center ( 3 ) + 0.5 * sizes ( 3 ) * dz if ( spatial_range ( 1 , 3 ) < - lz / 2 ) spatial_range ( 1 , 3 ) = - lz / 2 if ( spatial_range ( 2 , 3 ) > lz / 2 ) spatial_range ( 2 , 3 ) = lz / 2 end subroutine set_spatial_range_de !--------------------------------------------------------------------------- ! Calculate the IDs of the MPI processes which contains the bottom-left ! and top-right corners of the box. The MPI processes are in the MPI ! topology of the PIC simulation. !--------------------------------------------------------------------------- subroutine calc_pic_mpi_ids use picinfo , only : domain implicit none real ( dp ) :: cx , cy , cz cx = center ( 1 ) * domain % idx cy = ( center ( 2 ) + domain %","tags":"","loc":"sourcefile/spectrum_config.f90.html","title":"spectrum_config.f90 – Fortran Program"},{"text":"This model includes the methods to calculate j \\cdot E, where j is the current\n density, E is the electric field. Source Code !******************************************************************************* ! This model includes the methods to calculate j \\cdot E, where j is the current ! density, E is the electric field. !******************************************************************************* module jdote_module use constants , only : fp implicit none private public jdote , jdote_tot public init_jdote_total , free_jdote_total , save_jdote_total , & calc_jdote , init_jdote , free_jdote real ( fp ), allocatable , dimension (:, :, :) :: jdote real ( fp ), allocatable , dimension (:, :) :: jdote_tot integer , parameter :: njdote = 16 contains !--------------------------------------------------------------------------- ! Initialize the jdote data array. !--------------------------------------------------------------------------- subroutine init_jdote use mpi_topology , only : htg implicit none allocate ( jdote ( htg % nx , htg % ny , htg % nz )) jdote = 0.0 end subroutine init_jdote !--------------------------------------------------------------------------- ! Initialize the total of jdote. !--------------------------------------------------------------------------- subroutine init_jdote_total use parameters , only : tp1 , tp2 implicit none allocate ( jdote_tot ( njdote , tp2 - tp1 + 1 )) jdote_tot = 0.0 end subroutine init_jdote_total !--------------------------------------------------------------------------- ! Free jdote data array. !--------------------------------------------------------------------------- subroutine free_jdote implicit none deallocate ( jdote ) end subroutine free_jdote !--------------------------------------------------------------------------- ! Free jdote_tot !--------------------------------------------------------------------------- subroutine free_jdote_total implicit none deallocate ( jdote_tot ) end subroutine free_jdote_total !--------------------------------------------------------------------------- ! Save the total jdote summed in the whole simulation box. !--------------------------------------------------------------------------- subroutine save_jdote_total use constants , only : fp use parameters , only : tp1 , tp2 use parameters , only : inductive use particle_info , only : species , ibtag implicit none integer :: pos1 , output_record logical :: dir_e integer :: ct inquire ( file = './data/.' , exist = dir_e ) if ( .not. dir_e ) then call system ( 'mkdir ./data' ) endif print * , \"Saving j.E\" if ( inductive == 0 ) then open ( unit = 41 , & file = 'data/jdote' // ibtag // '_' // species // '.gda' , access = 'stream' ,& status = 'unknown' , form = 'unformatted' , action = 'write' ) else open ( unit = 41 , & file = 'data/jdote_in' // ibtag // '_' // species // '.gda' , access = 'stream' ,& status = 'unknown' , form = 'unformatted' , action = 'write' ) endif do ct = tp1 , tp2 output_record = ct - tp1 + 1 pos1 = ( output_record - 1 ) * sizeof ( fp ) * njdote + 1 write ( 41 , pos = pos1 ) jdote_tot ( 1 : 13 , output_record ), & jdote_tot ( 15 , output_record ), jdote_tot ( 14 , output_record ), & jdote_tot ( 16 , output_record ) enddo close ( 41 ) end subroutine save_jdote_total !--------------------------------------------------------------------------- ! Calculate J dot E from the fields. ! Input: !   jx, jy, jz: 3 components of the current density. ! Output: !   jdote_tot: the total jdote in the simulation box. !--------------------------------------------------------------------------- subroutine calc_jdote ( jx , jy , jz , jdote_tot ) use mpi_module use constants , only : fp use parameters , only : inductive use pic_fields , only : ex , ey , ez use inductive_electric_field , only : exin , eyin , ezin use statistics , only : get_average_and_total implicit none real ( fp ), intent ( out ) :: jdote_tot real ( fp ), dimension (:, :, :), intent ( in ) :: jx , jy , jz real ( fp ) :: avg if ( inductive == 0 ) then jdote = jx * ex + jy * ey + jz * ez else jdote = jx * exin + jy * eyin + jz * ezin endif jdote_tot = 0.0 call get_average_and_total ( jdote , avg , jdote_tot ) end subroutine calc_jdote end module jdote_module","tags":"","loc":"sourcefile/jdote_module.f90.html","title":"jdote_module.f90 – Fortran Program"},{"text":"User defined parameters for analysis. Source Code !******************************************************************************* ! User defined parameters for analysis. !******************************************************************************* module parameters implicit none private public tp1 , tp2 , inductive , is_rel public get_start_end_time_points , get_inductive_flag , get_relativistic_flag integer :: tp1 , tp2 ! Starting and ending time points for analysis. integer :: inductive , is_rel contains !--------------------------------------------------------------------------- ! Read starting and ending time points from the configuration file. !--------------------------------------------------------------------------- subroutine get_start_end_time_points use mpi_module use constants , only : fp use read_config , only : get_variable implicit none integer :: fh real ( fp ) :: temp fh = 10 ! Read the configuration file if ( myid == master ) then open ( unit = fh , file = 'config_files/analysis_config.dat' , & form = 'formatted' , status = 'old' ) temp = get_variable ( fh , 'tp1' , '=' ) tp1 = int ( temp ) temp = get_variable ( fh , 'tp2' , '=' ) tp2 = int ( temp ) close ( fh ) write ( * , \"(A,I0,A,I0)\" ) & \" Starting and ending time point for this analysis: \" , & tp1 , ', ' , tp2 endif call MPI_BCAST ( tp1 , 1 , MPI_INTEGER , master , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( tp2 , 1 , MPI_INTEGER , master , MPI_COMM_WORLD , ierr ) end subroutine get_start_end_time_points !--------------------------------------------------------------------------- ! Read the variable 'inductive' to decide whether inductive electric field ! is used. '1' for yes, '0' for no. !--------------------------------------------------------------------------- subroutine get_inductive_flag use mpi_module use constants , only : fp use read_config , only : get_variable implicit none integer :: fh real ( fp ) :: temp fh = 10 ! Read the configuration file if ( myid == master ) then open ( unit = fh , file = 'config_files/analysis_config.dat' , & form = 'formatted' , status = 'old' ) temp = get_variable ( fh , 'inductive' , '=' ) inductive = int ( temp ) if ( inductive == 1 ) then write ( * , \"(A)\" ) ' Using motional electric field.' else write ( * , \"(A)\" ) ' Using total electric field.' endif close ( fh ) endif call MPI_BCAST ( inductive , 1 , MPI_INTEGER , master , MPI_COMM_WORLD , ierr ) end subroutine get_inductive_flag !--------------------------------------------------------------------------- ! Read from the configuration file whether to use relativistic forms of ! calculation. !--------------------------------------------------------------------------- subroutine get_relativistic_flag use mpi_module use constants , only : fp use read_config , only : get_variable implicit none integer :: fh real ( fp ) :: temp fh = 10 ! Read the configuration file if ( myid == master ) then open ( unit = fh , file = 'config_files/analysis_config.dat' , & form = 'formatted' , status = 'old' ) temp = get_variable ( fh , 'is_rel' , '=' ) is_rel = int ( temp ) if ( is_rel == 1 ) then write ( * , \"(A)\" ) ' Using relativistic fields to do analysis.' else write ( * , \"(A)\" ) ' Using nonrelativistic fields to do analysis.' endif close ( fh ) endif call MPI_BCAST ( is_rel , 1 , MPI_INTEGER , master , MPI_COMM_WORLD , ierr ) end subroutine get_relativistic_flag end module parameters","tags":"","loc":"sourcefile/parameters.f90.html","title":"parameters.f90 – Fortran Program"},{"text":"Module of particle drift. This module will calculate particle curvature drift\n and gradient drift associated particle energy change. This module will also\n calculate the parallel acceleration. Note the particles are grouped into\n different energy band. Source Code !******************************************************************************* ! Module of particle drift. This module will calculate particle curvature drift ! and gradient drift associated particle energy change. This module will also ! calculate the parallel acceleration. Note the particles are grouped into ! different energy band. !******************************************************************************* module particle_drift use constants , only : fp , dp use picinfo , only : domain use path_info , only : rootpath use interpolation_emf , only : bx0 , by0 , bz0 , ex0 , ey0 , ez0 , bxn , byn , bzn use mpi_module implicit none private public init_drift_fields , init_para_perp_fields , init_jdote_sum , & set_drift_fields_zero , set_para_perp_fields_zero , & free_drift_fields , free_para_perp_fields , free_jdote_sum , & calc_particle_energy_change_rate , save_data_arrays , & sum_data_arrays , save_jdote_sum real ( fp ), allocatable , dimension (:, :, :, :) :: jcpara_dote , jgrad_dote real ( fp ), allocatable , dimension (:, :, :, :) :: jpara_dote , jperp_dote real ( fp ), allocatable , dimension (:, :, :) :: jdote_sum_local , jdote_sum_global integer , parameter :: nvar = 4 ! kinds of fieldsk real ( fp ) :: gyrof ! Gyro frequency integer :: nx , ny , nz , nband integer :: ntp ! Number of particle output frames. contains !--------------------------------------------------------------------------- ! Initialize the fields due to particle drift motions !--------------------------------------------------------------------------- subroutine init_drift_fields use topology_translate , only : ht use picinfo , only : nbands implicit none nx = ht % nx ny = ht % ny nz = ht % nz nband = nbands allocate ( jcpara_dote ( nx , ny , nz , nband )) allocate ( jgrad_dote ( nx , ny , nz , nband )) call set_drift_fields_zero end subroutine init_drift_fields !--------------------------------------------------------------------------- ! Set drift fields to be zero !--------------------------------------------------------------------------- subroutine set_drift_fields_zero implicit none jcpara_dote = 0.0 jgrad_dote = 0.0 end subroutine set_drift_fields_zero !--------------------------------------------------------------------------- ! Initialize the fields due to particle parallel and perpendicular motions ! with respect to the local magnetic field. !--------------------------------------------------------------------------- subroutine init_para_perp_fields use topology_translate , only : ht use picinfo , only : nbands implicit none nx = ht % nx ny = ht % ny nz = ht % nz nband = nbands allocate ( jpara_dote ( nx , ny , nz , nband )) allocate ( jperp_dote ( nx , ny , nz , nband )) call set_para_perp_fields_zero end subroutine init_para_perp_fields !--------------------------------------------------------------------------- ! Set parallel and perpendicular fields to be zero !--------------------------------------------------------------------------- subroutine set_para_perp_fields_zero implicit none jpara_dote = 0.0 jperp_dote = 0.0 end subroutine set_para_perp_fields_zero !--------------------------------------------------------------------------- ! Initialize the summation of the calculated jdote over the whole box. !--------------------------------------------------------------------------- subroutine init_jdote_sum use picinfo , only : nbands , nt , domain implicit none ntp = ( nt * domain % fields_interval ) / domain % particle_interval + 1 allocate ( jdote_sum_local ( ntp , nbands , nvar )) if ( myid == master ) then allocate ( jdote_sum_global ( ntp , nbands , nvar )) jdote_sum_global = 0.0 endif jdote_sum_local = 0.0 end subroutine init_jdote_sum !--------------------------------------------------------------------------- ! Free the fields due to particle drift motions !--------------------------------------------------------------------------- subroutine free_drift_fields implicit none deallocate ( jcpara_dote , jgrad_dote ) end subroutine free_drift_fields !--------------------------------------------------------------------------- ! Free the fields due to particle drift motions !--------------------------------------------------------------------------- subroutine free_para_perp_fields implicit none deallocate ( jpara_dote , jperp_dote ) end subroutine free_para_perp_fields !--------------------------------------------------------------------------- ! Free the summation of the calculated jdote over the whole box. !--------------------------------------------------------------------------- subroutine free_jdote_sum implicit none deallocate ( jdote_sum_local ) if ( myid == master ) then deallocate ( jdote_sum_global ) endif end subroutine free_jdote_sum !--------------------------------------------------------------------------- ! Calculate the particle energy change rate of all the particles in one ! VPIC simulation MPI process. ! Input: !   tindex: the time index, indicating the time step numbers in PIC simulation. !   species: 'e' for electron. 'h' for others. !   np: the VPIC simulation MPI process. !   sx, sy, sz: the offset from the starting cell of current MPI process. !--------------------------------------------------------------------------- subroutine calc_particle_energy_change_rate ( tindex , species , np , sx , sy , sz ) use particle_file , only : open_particle_file , close_particle_file , fh use particle_module , only : ptl , calc_particle_energy , calc_interp_param , & calc_para_perp_velocity_3d , calc_gyrofrequency , & calc_gradient_drift_velocity , calc_curvature_drift_velocity , & iex , jex , kex , iey , jey , key , iez , jez , kez , ibx , jbx , kbx , & iby , jby , kby , ibz , jbz , kbz , dx_ex , dy_ex , dz_ex , & dx_ey , dy_ey , dz_ey , dx_ez , dy_ez , dz_ez , dx_bx , dx_by , dx_bz , & dy_bx , dy_by , dy_bz , dz_bx , dz_by , dz_bz use interpolation_emf , only : trilinear_interp_bx , trilinear_interp_by , & trilinear_interp_bz , trilinear_interp_ex , trilinear_interp_ey , & trilinear_interp_ez , calc_b_norm , calc_gradient_B , & calc_curvature use file_header , only : pheader implicit none character ( len = 1 ), intent ( in ) :: species integer , intent ( in ) :: tindex , np , sx , sy , sz character ( len = 8 ) :: cid integer :: iptl write ( cid , \"(I0)\" ) np call open_particle_file ( tindex , species , cid ) ! Loop over particles do iptl = 1 , pheader % dim , 1 read ( fh ) ptl call calc_particle_energy call calc_interp_param call trilinear_interp_bx ( ibx , jbx , kbx , dx_bx , dy_bx , dz_bx ) call trilinear_interp_by ( iby , jby , kby , dx_by , dy_by , dz_by ) call trilinear_interp_bz ( ibz , jbz , kbz , dx_bz , dy_bz , dz_bz ) call trilinear_interp_ex ( iex , jex , kex , dx_ex , dy_ex , dz_ex ) call trilinear_interp_ey ( iey , jey , key , dx_ey , dy_ey , dz_ey ) call trilinear_interp_ez ( iez , jez , kez , dx_ez , dy_ez , dz_ez ) call calc_b_norm call calc_gradient_B call calc_curvature call calc_para_perp_velocity_3d call calc_gyrofrequency call calc_gradient_drift_velocity call calc_curvature_drift_velocity call update_data_arrays ( sx , sy , sz ) enddo call close_particle_file end subroutine calc_particle_energy_change_rate !--------------------------------------------------------------------------- ! Update the particle energy change rate arrays. jcpara_dote, jgrad_dote, ! jpara_dote, jperp_dote. ! Input: !   sx, sy, sz: the offset from the starting cell of current MPI process. !--------------------------------------------------------------------------- subroutine update_data_arrays ( sx , sy , sz ) use particle_module , only : gama , igama , vparax , vparay , vparaz , & vperpx , vperpy , vperpz , gyrof , vgx , vgy , vgz , vcx , vcy , vcz use interpolation_emf , only : ex0 , ey0 , ez0 use particle_info , only : ptl_charge , species use picinfo , only : einterval_e , einterval_i , nbands use particle_module , only : ci , cj , ck implicit none integer , intent ( in ) :: sx , sy , sz real ( fp ) :: einterval integer :: ibin , ix , iy , iz if ( species == 'e' ) then einterval = einterval_e else einterval = einterval_i endif ibin = ( gama - 1 ) / einterval + 1 if ( ibin > nbands ) ibin = nbands ix = ci + sx iy = cj + sy iz = ck + sz jcpara_dote ( ix , iy , iz , ibin ) = jcpara_dote ( ix , iy , iz , ibin ) + & ptl_charge","tags":"","loc":"sourcefile/particle_drift.f90.html","title":"particle_drift.f90 – Fortran Program"},{"text":"Module for reading configuration file. The configuration file looks like\n A = value or A: value. So this module defines a subroutine to read the value\n with different delimiter. Source Code !******************************************************************************* ! Module for reading configuration file. The configuration file looks like ! A = value or A: value. So this module defines a subroutine to read the value ! with different delimiter. !******************************************************************************* module read_config implicit none private public get_variable , get_variable_int contains !--------------------------------------------------------------------------- ! Function to the value of one variable with name var_name. ! Inputs: !   fh: file handler. !   var_name: the variable name. !   delimiter: the delimiter. The value of the variable is after the delimiter. ! Returns: !   var_value: the variable value. !--------------------------------------------------------------------------- function get_variable ( fh , var_name , delimiter ) result ( var_value ) use constants , only : fp implicit none integer , intent ( in ) :: fh character ( * ), intent ( in ) :: var_name , delimiter real ( fp ) :: var_value character ( len = 150 ) :: single_line integer :: len1 , IOstatus do while ( index ( single_line , var_name ) == 0 ) read ( fh , '(A)' , IOSTAT = IOstatus ) single_line if ( IOStatus < 0 ) then exit endif enddo var_value = - 1.0 if ( IOStatus == 0 ) then len1 = len ( trim ( single_line )) + 1 ! For C or C++ code if ( index ( single_line , \";\" ) /= 0 ) then len1 = index ( single_line , \";\" ) endif read ( single_line ( index ( single_line , delimiter ) + 1 : len1 - 1 ), * ) var_value endif end function !--------------------------------------------------------------------------- ! Get the variable as an integer. !--------------------------------------------------------------------------- function get_variable_int ( fh , var_name , delimiter ) result ( var_value_int ) use constants , only : fp implicit none integer , intent ( in ) :: fh character ( * ), intent ( in ) :: var_name , delimiter real ( fp ) :: var_value integer :: var_value_int var_value = get_variable ( fh , var_name , delimiter ) var_value_int = int ( var_value ) end function get_variable_int end module read_config","tags":"","loc":"sourcefile/read_config.f90.html","title":"read_config.f90 – Fortran Program"},{"text":"Module of the parameters related to PIC simulations. Source Code !******************************************************************************* ! Module of the parameters related to PIC simulations. !******************************************************************************* module picinfo use constants , only : dp , fp use path_info , only : rootpath use read_config , only : get_variable implicit none save private public picdomain , broadcast_pic_info , get_total_time_frames , & write_pic_info , get_energy_band_number , read_thermal_params , & calc_energy_interval public nbands , mime , domain , nt , read_domain , emax , einterval_e , & einterval_i ! Information of simulation domain. All values are in simulation units. ! Length is in de. Time is in 1/wpe unless clarified. type picdomain real ( dp ) :: dx , dy , dz ! Grid sizes real ( dp ) :: idx , idy , idz ! Inverse of dx, dy, dz real ( dp ) :: idxh , idyh , idzh ! Half of idx, idy, idz real ( fp ) :: lx_de , ly_de , lz_de ! Simulation box sizes real ( fp ) :: dtwpe , dtwce ! Time step in PIC simulation real ( fp ) :: dtwpi , dtwci ! Time step in PIC simulation real ( fp ) :: dt , idt ! Fields output interval and its inverse integer :: energies_interval ! Energy output time interval integer :: fields_interval ! Fields output time interval integer :: hydro_interval ! hydro output time interval integer :: particle_interval ! Particles output time interval integer :: nx , ny , nz ! Grid numbers integer :: pic_tx , pic_ty , pic_tz ! MPI topology integer :: pic_nx , pic_ny , pic_nz ! The domain sizes for each process integer :: nppc ! Number of particles/cell/species integer :: nproc ! Number of CPU cores used. end type picdomain type ( picdomain ) :: domain real ( fp ) :: mime ! Mass ratio integer :: nt ! Total number of time frames for field output. integer :: nbands ! Total number of energy bands. real ( fp ) :: emax ! Maximum energy for energy bands. real ( fp ) :: Ti_Te ! Temperature ratio of ions and electrons real ( fp ) :: vthe , vthi ! Thermal speed real ( fp ) :: einterval_e , einterval_i ! Energy interval for different band contains !--------------------------------------------------------------------------- ! Private function to get the main configuration file name for current PIC ! simulation from the Makefile of VPIC code. !--------------------------------------------------------------------------- function get_main_fname () result ( fname ) implicit none character ( len = 20 ) :: fname character ( len = 256 ) :: buff integer :: fh , index1 fh = 40 ! Get the main configuration file for current PIC simulation. open ( unit = fh , file = trim ( adjustl ( rootpath )) // 'Makefile' , status = 'old' ) read ( fh , '(A)' ) buff do while ( index ( buff , 'vpic' ) == 0 ) read ( fh , '(A)' ) buff enddo index1 = index ( buff , 'op' ) fname = trim ( buff ( index1 + 3 :)) close ( fh ) end function get_main_fname !--------------------------------------------------------------------------- ! Get the fields output time interval from the initialization file. ! The interval is defined as \"int interval = ...\", for example, ! int interval = int(2.5/(wci*dt)). This routine assumes the intervals ! are the same for all particle species. ! ! Input: !   dtwpe, dtwce, dtwpi, dtwci: time step in different units. ! Output: !   fields_interval: the fields output interval !   hydro_interval: the hydro fields output interval !   particles_interval: the particle output interval !--------------------------------------------------------------------------- subroutine get_fields_interval ( dtwpe , dtwce , dtwpi , dtwci , fields_interval , & hydro_interval , particle_interval ) use constants , only : fp implicit none real ( fp ), intent ( in ) :: dtwpe , dtwce , dtwpi , dtwci integer , intent ( out ) :: fields_interval , hydro_interval , particle_interval integer :: fh , index1 , index2 , index3 character ( len = 256 ) :: buff , code character ( len = 20 ) :: fname , another_interval logical :: cond1 , cond2 integer :: interval , ratio , interval_base fh = 40 fname = get_main_fname () open ( unit = fh , file = trim ( adjustl ( rootpath )) // trim ( adjustl ( fname )), status = 'old' ) read ( fh , '(A)' ) buff ! Make sure the line is not commented out cond1 = index ( buff , 'int interval = ' ) == 0 cond2 = index ( buff , '//' ) /= 0 do while ( cond1 .or. cond2 ) read ( fh , '(A)' ) buff cond1 = index ( buff , 'int interval = ' ) == 0 cond2 = index ( buff , '//' ) /= 0 enddo if ( index ( buff , '(' ) == 0 ) then ! This interval is based on another interval index1 = index ( buff , '=' ) index2 = index ( buff , ';' ) if ( index ( buff , '*' ) == 0 ) then another_interval = trim ( adjustl ( buff ( index1 + 1 : index2 - 1 ))) ratio = 1 else index3 = index ( buff , '*' ) another_interval = trim ( adjustl ( buff ( index3 + 1 : index2 - 1 ))) read ( buff ( index1 + 1 : index3 - 1 ), * ) ratio endif code = 'int ' // trim ( adjustl ( another_interval )) // ' = ' ! Find another_interval rewind ( fh ) cond1 = index ( buff , trim ( adjustl ( code ))) == 0 cond2 = index ( buff , '//' ) /= 0 do while ( cond1 .or. cond2 ) read ( fh , '(A)' ) buff cond1 = index ( buff , trim ( adjustl ( code ))) == 0 cond2 = index ( buff , '//' ) /= 0 enddo interval_base = get_time_interval ( buff , dtwpe , dtwce , dtwpi , dtwci ) interval = interval_base * ratio else interval = get_time_interval ( buff , dtwpe , dtwce , dtwpi , dtwci ) endif ! Read fields_interval cond1 = index ( buff , 'int fields_interval = ' ) == 0 cond2 = index ( buff , '//' ) /= 0 do while ( cond1 .or. cond2 ) read ( fh , '(A)' ) buff cond1 = index ( buff , 'int fields_interval = ' ) == 0 cond2 = index ( buff , '//' ) /= 0 enddo if ( index ( buff , '*' ) /= 0 ) then index1 = index ( buff , '=' ) index2 = index ( buff , '*' ) read ( buff ( index1 + 1 : index2 - 1 ), * ) ratio else ratio = 1 endif fields_interval = interval * ratio ! Read hydro_interval, assuming ehydro_interval == Hhydro_interval cond1 = index ( buff , 'int ehydro_interval = ' ) == 0 cond2 = index ( buff , '//' ) /= 0 do while ( cond1 .or. cond2 ) read ( fh , '(A)' ) buff cond1 = index ( buff , 'int ehydro_interval = ' ) == 0 cond2 = index ( buff , '//' ) /= 0 enddo if ( index ( buff , '*' ) /= 0 ) then index1 = index ( buff , '=' ) index2 = index ( buff , '*' ) read ( buff ( index1 + 1 : index2 - 1 ), * ) ratio else ratio = 1 endif hydro_interval = interval * ratio ! Read particle_interval, assuming eparticle_interval == Hparticle_interval cond1 = index ( buff , 'int eparticle_interval = ' ) == 0 cond2 = index ( buff , '//' ) /= 0 do while ( cond1 .or. cond2 ) read ( fh , '(A)' ) buff cond1 = index ( buff , 'int eparticle_interval = ' ) == 0 cond2 = index ( buff , '//' ) /= 0 enddo if ( index ( buff , '*' ) /= 0 ) then index1 = index ( buff , '=' ) index2","tags":"","loc":"sourcefile/get_info.f90.html","title":"get_info.f90 – Fortran Program"},{"text":"MPI data type for parallel I/O. This contains one subroutine to open field data file using MPI I/O, one\n subroutine to read data using MPI I/O. Source Code !******************************************************************************* ! MPI data type for parallel I/O. !******************************************************************************* module mpi_datatype_fields use mpi_module use picinfo , only : domain use mpi_topology , only : ht , htg implicit none private public sizes_ghost , subsizes_ghost , starts_ghost , & sizes_nghost , subsizes_nghost , starts_nghost , & filetype_ghost , filetype_nghost , set_mpi_datatype_fields ! Two kinds: one with ghost cells, the other without. integer :: sizes_ghost ( 3 ), subsizes_ghost ( 3 ), starts_ghost ( 3 ) integer :: sizes_nghost ( 3 ), subsizes_nghost ( 3 ), starts_nghost ( 3 ) integer :: filetype_ghost , filetype_nghost contains !--------------------------------------------------------------------------- ! Create a MPI data type and commit it. The data type will be different for ! data input and data output since they have arrays with different sizes. ! Updates: !   sizes_ghost, subsizes_ghost, starts_ghost: the sizes for !       MPI_TYPE_CREATE_SUBARRAY with ghost cells. !   sizes_nghost, subsizes_nghost, starts_nghost: the sizes for !       MPI_TYPE_CREATE_SUBARRAY without ghost cells. !   filetype_ghost, filetype_nghost: the file types of the created array. !--------------------------------------------------------------------------- subroutine set_mpi_datatype_fields use mpi_datatype_module , only : set_mpi_datatype implicit none sizes_ghost ( 1 ) = domain % nx sizes_ghost ( 2 ) = domain % ny sizes_ghost ( 3 ) = domain % nz subsizes_ghost ( 1 ) = htg % nx subsizes_ghost ( 2 ) = htg % ny subsizes_ghost ( 3 ) = htg % nz starts_ghost ( 1 ) = htg % start_x starts_ghost ( 2 ) = htg % start_y starts_ghost ( 3 ) = htg % start_z filetype_ghost = set_mpi_datatype ( sizes_ghost , & subsizes_ghost , starts_ghost ) sizes_nghost = sizes_ghost subsizes_nghost ( 1 ) = ht % nx subsizes_nghost ( 2 ) = ht % ny subsizes_nghost ( 3 ) = ht % nz starts_nghost ( 1 ) = ht % start_x starts_nghost ( 2 ) = ht % start_y starts_nghost ( 3 ) = ht % start_z filetype_nghost = set_mpi_datatype ( sizes_nghost , & subsizes_nghost , starts_nghost ) end subroutine set_mpi_datatype_fields end module mpi_datatype_fields !******************************************************************************* ! This contains one subroutine to open field data file using MPI I/O, one ! subroutine to read data using MPI I/O. !******************************************************************************* module mpi_io_fields use mpi_module implicit none private public save_field contains !--------------------------------------------------------------------------- ! Save the fields data to a file use MPI/IO. ! Input: !   fdata: the field data to save to disk. !   varname: the field variable name. !   ct: current time frame. !--------------------------------------------------------------------------- subroutine save_field ( fdata , varname , ct ) use constants , only : fp use picinfo , only : domain use parameters , only : tp1 use path_info , only : outputpath use particle_info , only : species , ibtag use mpi_datatype_fields , only : filetype_nghost , subsizes_nghost use mpi_info_module , only : fileinfo use mpi_topology , only : range_out use mpi_io_module , only : open_data_mpi_io , write_data_mpi_io implicit none real ( fp ), dimension (:, :, :), intent ( in ) :: fdata character ( * ), intent ( in ) :: varname integer , intent ( in ) :: ct character ( len = 150 ) :: fname integer :: fh ! File handler integer :: ixl , iyl , izl , ixh , iyh , izh real ( fp ), allocatable , dimension (:,:,:) :: data_nghost integer ( kind = MPI_OFFSET_KIND ) :: disp , offset allocate ( data_nghost ( subsizes_nghost ( 1 ), subsizes_nghost ( 2 ), & subsizes_nghost ( 3 ))) ixl = range_out % ixl ixh = range_out % ixh iyl = range_out % iyl iyh = range_out % iyh izl = range_out % izl izh = range_out % izh ! print*, (ixh-ixl+1) /= subsizes_nghost(1), & !         (iyh-iyl+1) /= subsizes_nghost(2), & !         (izh-izl+1) /= subsizes_nghost(3) ! print*, ixh > subsizes_ghost(1), iyh > subsizes_ghost(2), & !         izh > subsizes_ghost(3) data_nghost = fdata ( ixl : ixh , iyl : iyh , izl : izh ) disp = domain % nx * domain % ny * domain % nz * sizeof ( MPI_REAL ) * ( ct - tp1 ) offset = 0 fname = trim ( adjustl ( outputpath )) // varname // ibtag // '_' // species // '.gda' call open_data_mpi_io ( fname , MPI_MODE_RDWR + MPI_MODE_CREATE , fileinfo , fh ) call write_data_mpi_io ( fh , filetype_nghost , subsizes_nghost , & disp , offset , data_nghost ) call MPI_FILE_CLOSE ( fh , ierror ) deallocate ( data_nghost ) end subroutine save_field end module mpi_io_fields","tags":"","loc":"sourcefile/mpi_io_fields.f90.html","title":"mpi_io_fields.f90 – Fortran Program"},{"text":"Module for data analysis setup, including the initialization of MPI processes,\n reading PIC simulation domain, setting MPI topology, setting MPI datatype,\n setting MPI_INFO for I/O, opening and closing PIC field fields,\n initialization and free of the PIC fields, freeing the MPI datatype, MPI_INFO,\n and finalizing the MPI process. Source Code !******************************************************************************* ! Module for data analysis setup, including the initialization of MPI processes, ! reading PIC simulation domain, setting MPI topology, setting MPI datatype, ! setting MPI_INFO for I/O, opening and closing PIC field fields, ! initialization and free of the PIC fields, freeing the MPI datatype, MPI_INFO, ! and finalizing the MPI process. !******************************************************************************* module analysis_management implicit none private public init_analysis , end_analysis contains !--------------------------------------------------------------------------- ! Initialize the analysis by reading the PIC simulation domain information, ! get file paths for the field data and the outputs. !--------------------------------------------------------------------------- subroutine init_analysis use mpi_module use path_info , only : get_file_paths use mpi_topology , only : set_mpi_topology use mpi_datatype_fields , only : set_mpi_datatype_fields use mpi_info_module , only : fileinfo , set_mpi_info use picinfo , only : read_domain , broadcast_pic_info , & get_total_time_frames , get_energy_band_number , & read_thermal_params , calc_energy_interval , nbands use parameters , only : get_start_end_time_points , get_inductive_flag , & tp2 , get_relativistic_flag use configuration_translate , only : read_configuration use time_info , only : get_nout use commandline_arguments , only : get_cmdline_arguments implicit none call MPI_INIT ( ierr ) call MPI_COMM_RANK ( MPI_COMM_WORLD , myid , ierr ) call MPI_COMM_SIZE ( MPI_COMM_WORLD , numprocs , ierr ) call get_cmdline_arguments call get_file_paths if ( myid == master ) then call read_domain endif call broadcast_pic_info call get_start_end_time_points call get_inductive_flag call get_relativistic_flag call read_configuration call get_total_time_frames ( tp2 ) call get_energy_band_number call read_thermal_params if ( nbands > 0 ) then call calc_energy_interval endif call set_mpi_topology ! MPI topology call set_mpi_datatype_fields call set_mpi_info end subroutine init_analysis !--------------------------------------------------------------------------- ! Finalizing the analysis by release the memory, MPI data types, MPI info. !--------------------------------------------------------------------------- subroutine end_analysis use mpi_module use mpi_datatype_fields , only : filetype_ghost , filetype_nghost use mpi_info_module , only : fileinfo implicit none call MPI_TYPE_FREE ( filetype_ghost , ierror ) call MPI_TYPE_FREE ( filetype_nghost , ierror ) call MPI_INFO_FREE ( fileinfo , ierror ) call MPI_FINALIZE ( ierr ) end subroutine end_analysis end module analysis_management","tags":"","loc":"sourcefile/analysis_config.f90.html","title":"analysis_config.f90 – Fortran Program"},{"text":"Module for reading and writing HDF5 file in parallel Source Code !******************************************************************************* ! Module for reading and writing HDF5 file in parallel !******************************************************************************* module parallel_hdf5 use constants , only : fp , dp use mpi_module use hdf5 implicit none private integer ( hid_t ) :: file_id integer ( hid_t ), allocatable , dimension (:) :: group_id , dset_id integer ( hid_t ) :: filespace , memspace , plist_id integer ( hsize_t ), allocatable , dimension (:) :: dset_dims , dcount , offset integer :: rank contains !--------------------------------------------------------------------------- ! Open hdf5 file in parallel !--------------------------------------------------------------------------- subroutine open_hdf5_parallel ( filename , groupname ) use mpi_info_module , only : fileinfo implicit none character ( * ), intent ( in ) :: filename , groupname integer :: error h5open_f ( error ) call h5pcreate_f ( H5P_FILE_ACCESS_F , plist_id , error ) call h5pset_fapl_mpio_f ( plist_id , MPI_COMM_WORLD , info , error ) call h5fopen_f ( filename , H5F_ACC_RDWR_F , file_id , error , & access_prp = plist_id ) call h5pclose_f ( plist_id , error ) call h5fclose_f ( file_id , error ) end subroutine open_hdf5_parallel !--------------------------------------------------------------------------- ! Read hdf5 file in parallel !--------------------------------------------------------------------------- subroutine read_hdf5_parallel implicit none end subroutine read_hdf5_parallel end module parallel_hdf5","tags":"","loc":"sourcefile/parallel_hdf5.f90.html","title":"parallel_hdf5.f90 – Fortran Program"},{"text":"Module of file path information, including the root path of current PIC run,\n the filepath of the data files (bx, by, bz ...) and the outputpath of current\n analysis. Source Code !******************************************************************************* ! Module of file path information, including the root path of current PIC run, ! the filepath of the data files (bx, by, bz ...) and the outputpath of current ! analysis. !******************************************************************************* module path_info implicit none save private public rootpath , filepath , outputpath , get_file_paths character ( len = 150 ) :: rootpath , filepath , outputpath contains subroutine get_file_paths use mpi_module implicit none integer :: status1 , getcwd , index1 status1 = getcwd ( rootpath ) index1 = index ( rootpath , '/' , back = .true. ) rootpath = rootpath ( 1 : index1 ) filepath = trim ( rootpath ) // 'data/' outputpath = trim ( rootpath ) // 'data1/' if ( myid == master ) then call create_directories endif end subroutine get_file_paths subroutine create_directories implicit none logical :: dir_e character ( len = 256 ) :: fname dir_e = .false. inquire ( file = filepath , exist = dir_e ) if ( .not. dir_e ) then fname = 'mkdir ' // filepath call system ( fname ) endif inquire ( file = outputpath , exist = dir_e ) if ( .not. dir_e ) then fname = 'mkdir ' // outputpath call system ( fname ) endif end subroutine create_directories end module path_info","tags":"","loc":"sourcefile/path_info.f90.html","title":"path_info.f90 – Fortran Program"},{"text":"Module for parallel and perpendicular pressure. It includes the data and\n the methods to calculate the pressures. Source Code !******************************************************************************* ! Module for parallel and perpendicular pressure. It includes the data and ! the methods to calculate the pressures. !******************************************************************************* module para_perp_pressure use constants , only : fp use parameters , only : is_rel implicit none private public ppara , pperp , init_para_perp_pressure , free_para_perp_pressure public calc_para_perp_pressure , calc_real_para_perp_pressure public save_para_perp_pressure , save_averaged_para_perp_pressure public init_avg_para_perp_pressure , free_avg_para_perp_pressure real ( fp ), allocatable , dimension (:,:,:) :: pperp , ppara real ( fp ), allocatable , dimension (:) :: pperp_avg , ppara_avg logical :: is_subtract_bulkflow contains !--------------------------------------------------------------------------- ! Initialize the averaged parallel and perpendicular pressure. !--------------------------------------------------------------------------- subroutine init_avg_para_perp_pressure use parameters , only : tp1 , tp2 implicit none allocate ( ppara_avg ( tp2 - tp1 + 1 )) allocate ( pperp_avg ( tp2 - tp1 + 1 )) ppara_avg = 0.0 pperp_avg = 0.0 end subroutine init_avg_para_perp_pressure !--------------------------------------------------------------------------- ! Initialization of the parallel and perpendicular pressure. !--------------------------------------------------------------------------- subroutine init_para_perp_pressure use mpi_topology , only : htg implicit none integer :: nx , ny , nz nx = htg % nx ny = htg % ny nz = htg % nz ! Allocate storage space for fields and moments allocate ( ppara ( nx , ny , nz )) allocate ( pperp ( nx , ny , nz )) ppara = 0.0 pperp = 0.0 call init_avg_para_perp_pressure end subroutine init_para_perp_pressure !--------------------------------------------------------------------------- ! Free the averaged parallel and perpendicular pressure. !--------------------------------------------------------------------------- subroutine free_avg_para_perp_pressure implicit none deallocate ( ppara_avg , pperp_avg ) end subroutine free_avg_para_perp_pressure !--------------------------------------------------------------------------- ! Free the memory used by parallel and perpendicular pressure. !--------------------------------------------------------------------------- subroutine free_para_perp_pressure implicit none deallocate ( ppara , pperp ) call free_avg_para_perp_pressure end subroutine free_para_perp_pressure !--------------------------------------------------------------------------- ! Calculate parallel and perpendicular pressure from the pressure tensor ! and magnetic field. P is the pressure tensor below. !       P_\\parallel = \\hat{b}\\cdot P \\cdot\\hat{b} !       P_\\perp = (tr(P)-P_\\parallel)*0.5 ! The bulk flow is NOT subtracted from the pressure. ! Inputs: !   ct: current time frame. !--------------------------------------------------------------------------- subroutine calc_para_perp_pressure ( ct ) use constants , only : fp use parameters , only : tp1 use pic_fields , only : bx , by , bz , absB , vx , vy , vz , ux , uy , uz , & num_rho , pxx , pxy , pxz , pyy , pyz , pzz , pyx , pzx , pzy use statistics , only : get_average_and_total use particle_info , only : ptl_mass use mpi_topology , only : htg use saving_flags , only : save_pre implicit none integer , intent ( in ) :: ct real ( fp ), allocatable , dimension (:,:,:) :: bsquare , prexx , preyy , prezz real ( fp ) :: tot integer :: nx , ny , nz nx = htg % nx ny = htg % ny nz = htg % nz allocate ( bsquare ( nx , ny , nz )) allocate ( prexx ( nx , ny , nz )) allocate ( preyy ( nx , ny , nz )) allocate ( prezz ( nx , ny , nz )) bsquare = bx * bx + by * by + bz * bz if ( is_rel == 1 ) then prexx = pxx + vx * ux * num_rho * ptl_mass preyy = pyy + vy * uy * num_rho * ptl_mass prezz = pzz + vz * uz * num_rho * ptl_mass ppara = prexx * bx * bx + & preyy * by * by + & prezz * bz * bz + & ( pxy + vx * uy * num_rho * ptl_mass ) * bx * by + & ( pyx + vy * ux * num_rho * ptl_mass ) * bx * by + & ( pxz + vx * uz * num_rho * ptl_mass ) * bx * bz + & ( pzx + vz * ux * num_rho * ptl_mass ) * bx * bz + & ( pyz + vy * uz * num_rho * ptl_mass ) * by * bz + & ( pzy + vz * uy * num_rho * ptl_mass ) * by * bz else prexx = pxx + vx * vx * num_rho * ptl_mass preyy = pyy + vy * vy * num_rho * ptl_mass prezz = pzz + vz * vz * num_rho * ptl_mass ppara = prexx * bx * bx + & preyy * by * by + & prezz * bz * bz + & ( pxy + vx * vy * num_rho * ptl_mass ) * bx * by * 2.0 + & ( pxz + vx * vz * num_rho * ptl_mass ) * bx * bz * 2.0 + & ( pyz + vy * vz * num_rho * ptl_mass ) * by * bz * 2.0 endif ppara = ppara / bsquare pperp = 0.5 * ( prexx + preyy + prezz - ppara ) is_subtract_bulkflow = .false. if ( save_pre == 1 ) then call save_para_perp_pressure ( ct ) endif deallocate ( bsquare , prexx , preyy , prezz ) call get_average_and_total ( ppara , ppara_avg ( ct - tp1 + 1 ), tot ) call get_average_and_total ( pperp , pperp_avg ( ct - tp1 + 1 ), tot ) end subroutine calc_para_perp_pressure !--------------------------------------------------------------------------- ! Calculate parallel and perpendicular pressure from the pressure tensor ! and magnetic field. The bulk flow is subtracted from the pressure. ! Inputs: !   ct: current time frame. !--------------------------------------------------------------------------- subroutine calc_real_para_perp_pressure ( ct ) use constants , only : fp use parameters , only : tp1 use pic_fields , only : bx , by , bz , absB , num_rho , & pxx , pxy , pxz , pyy , pyz , pzz , pyx , pzx , pzy use statistics , only : get_average_and_total use mpi_topology , only : htg use saving_flags , only : save_pre implicit none integer , intent ( in ) :: ct real ( fp ), allocatable , dimension (:,:,:) :: bsquare real ( fp ) :: tot integer :: nx , ny , nz nx = htg % nx ny = htg % ny nz = htg % nz allocate ( bsquare ( nx , ny , nz )) bsquare = bx * bx + by * by + bz * bz if ( is_rel == 1 ) then ppara = pxx * bx * bx + pyy * by * by + pzz * bz * bz + & ( pxy + pyx ) * bx * by + ( pxz + pzx ) * bx * bz + & ( pyz + pzy ) * by * bz else ppara = pxx * bx * bx + pyy * by * by + pzz * bz * bz + & ( pxy * bx * by * 2.0 ) + ( pxz * bx * bz * 2.0 ) + & ( pyz * by * bz * 2.0 ) endif ppara = ppara / bsquare pperp = 0.5 * ( pxx + pyy + pzz - ppara ) is_subtract_bulkflow = .true. if ( save_pre == 1 ) then call save_para_perp_pressure ( ct ) endif deallocate ( bsquare ) call get_average_and_total ( ppara , ppara_avg ( ct - tp1 + 1 ), tot ) call get_average_and_total ( pperp , pperp_avg ( ct","tags":"","loc":"sourcefile/para_perp_pressure.f90.html","title":"para_perp_pressure.f90 – Fortran Program"},{"text":"Module for mpi_io. It includes the routine to set the MPI datatype and\n MPI_INFO. Source Code !******************************************************************************* ! Module for mpi_io. It includes the routine to set the MPI datatype and ! MPI_INFO. !******************************************************************************* module mpi_io_translate implicit none private public datatype , set_mpi_io , write_data integer :: datatype contains !--------------------------------------------------------------------------- ! Set MPI datatype and MPI_INFO. !--------------------------------------------------------------------------- subroutine set_mpi_io use mpi_module use topology_translate , only : ht use picinfo , only : domain use mpi_datatype_module , only : set_mpi_datatype use mpi_info_module , only : set_mpi_info implicit none integer :: sizes ( 3 ), subsizes ( 3 ), starts ( 3 ) ! size of the global matrix sizes ( 1 ) = domain % nx sizes ( 2 ) = domain % ny sizes ( 3 ) = domain % nz ! size of the chunck seen by each process subsizes ( 1 ) = ht % nx subsizes ( 2 ) = ht % ny subsizes ( 3 ) = ht % nz ! where each chunck starts starts ( 1 ) = ht % ix * ht % nx starts ( 2 ) = ht % iy * ht % ny starts ( 3 ) = ht % iz * ht % nz datatype = set_mpi_datatype ( sizes , subsizes , starts ) call set_mpi_info end subroutine set_mpi_io !--------------------------------------------------------------------------- ! Write data to file using MPI I/O. !--------------------------------------------------------------------------- subroutine write_data ( fname , fdata , tindex , output_record ) use mpi_module use constants , only : fp , dp use topology_translate , only : ht use mpi_info_module , only : fileinfo use configuration_translate , only : output_format implicit none integer , intent ( in ) :: tindex , output_record real ( fp ), intent ( in ), dimension (:,:,:) :: fdata character ( * ), intent ( in ) :: fname integer ( kind = MPI_OFFSET_KIND ) :: disp , offset character ( len = 150 ) :: cfname real ( dp ) :: mp_elapsed integer :: fh mp_elapsed = MPI_WTIME () disp = 0 if ( output_format == 1 ) then offset = ( output_record - 1 ) * ht % nx * ht % ny * ht % nz cfname = trim ( fname ) // '.gda' else offset = 0 write ( cfname , \"(I0)\" ) tindex cfname = trim ( fname ) // '_' // trim ( cfname ) // '.gda' endif call MPI_FILE_OPEN ( MPI_COMM_WORLD , cfname , & MPI_MODE_RDWR + MPI_MODE_CREATE , fileinfo , fh , ierror ) if ( ierror /= 0 ) then call MPI_Error_string ( ierror , err_msg , err_length , ierror2 ) print * , \"Error in MPI_FILE_OPEN:\" , trim ( err_msg ) endif call MPI_FILE_SET_VIEW ( fh , disp , MPI_REAL4 , datatype , & 'native' , MPI_INFO_NULL , ierror ) if ( ierror /= 0 ) then call MPI_Error_string ( ierror , err_msg , err_length , ierror2 ) print * , \"Error in MPI_FILE_SET_VIEW:\" , trim ( err_msg ) endif if ( myid == master ) print * , \"writing data to file \" , trim ( cfname ) call MPI_FILE_WRITE_AT_ALL ( fh , offset , fdata , ht % nx * ht % ny * ht % nz , & MPI_REAL4 , status , ierror ) if ( ierror /= 0 ) then call MPI_Error_string ( ierror , err_msg , err_length , ierror2 ) print * , \"Error in MPI_FILE_WRITE:\" , trim ( err_msg ) endif call MPI_FILE_CLOSE ( fh , ierror ) mp_elapsed = MPI_WTIME () - mp_elapsed if ( myid == master ) write ( * , '(A, F5.1)' ) \" => time(s):\" , mp_elapsed end subroutine write_data end module mpi_io_translate","tags":"","loc":"sourcefile/mpi_io_translate.f90.html","title":"mpi_io_translate.f90 – Fortran Program"},{"text":"Module of particle maximum energy in each cell. Source Code !******************************************************************************* ! Module of particle maximum energy in each cell. !******************************************************************************* module particle_maximum_energy use constants , only : fp , dp use picinfo , only : domain use path_info , only : rootpath implicit none private public distribute_pic_mpi , init_emax_array , free_emax_array , & update_emax_array , write_emax , set_emax_datatype , & free_emax_datatype public txs , tys , tzs , txe , tye , tze integer :: txp , typ , tzp , txs , tys , tzs , txe , tye , tze integer :: nx_tot , ny_tot , nz_tot , nxp , nyp , nzp , nxs , nys , nzs integer :: offset_nx , offset_ny , offset_nz integer , dimension ( 3 ) :: sizes , subsizes , starts real ( fp ), allocatable , dimension (:,:,:) :: emax integer :: datatype contains !--------------------------------------------------------------------------- ! Distribute tasks based on the corners of the MPI processes of the PIC ! simulation for the spectrum calculation. !--------------------------------------------------------------------------- subroutine distribute_pic_mpi use mpi_module use spectrum_config , only : corners_mpi use mpi_topology , only : distribute_tasks implicit none integer :: tx , ty , tz , txc , tyc , tzc , ix , iy , iz integer :: pic_nx , pic_ny , pic_nz tx = corners_mpi ( 2 , 1 ) - corners_mpi ( 1 , 1 ) + 1 ty = corners_mpi ( 2 , 2 ) - corners_mpi ( 1 , 2 ) + 1 tz = corners_mpi ( 2 , 3 ) - corners_mpi ( 1 , 3 ) + 1 pic_nx = domain % pic_nx pic_ny = domain % pic_ny pic_nz = domain % pic_nz nx_tot = tx * pic_nx ny_tot = ty * pic_ny nz_tot = tz * pic_nz offset_nx = corners_mpi ( 1 , 1 ) * pic_nx offset_ny = corners_mpi ( 1 , 2 ) * pic_ny offset_nz = corners_mpi ( 1 , 3 ) * pic_nz ! Defaults topology for current analysis txc = numprocs tyc = 1 tzc = 1 call set_ana_topology ( tx , ty , tz , txc , tyc , tzc ) iz = myid / ( txc * tyc ) iy = mod ( myid , txc * tyc ) / txc ix = myid - iz * txc * tyc - iy * txc call distribute_tasks ( tx , txc , ix , txp , txs , txe ) call distribute_tasks ( ty , tyc , iy , typ , tys , tye ) call distribute_tasks ( tz , tzc , iz , tzp , tzs , tze ) ! Shift to the right position txs = txs + corners_mpi ( 1 , 1 ) txe = txe + corners_mpi ( 1 , 1 ) tys = tys + corners_mpi ( 1 , 2 ) tye = tye + corners_mpi ( 1 , 2 ) tzs = tzs + corners_mpi ( 1 , 3 ) tze = tze + corners_mpi ( 1 , 3 ) nxs = txs * pic_nx nys = tys * pic_ny nzs = tzs * pic_nz nxp = txp * pic_nx nyp = typ * pic_ny nzp = tzp * pic_nz end subroutine distribute_pic_mpi !--------------------------------------------------------------------------- ! Initialize emax array !--------------------------------------------------------------------------- subroutine init_emax_array implicit none allocate ( emax ( nxp , nyp , nzp )) emax = 0.0 end subroutine init_emax_array !--------------------------------------------------------------------------- ! Free emax array !--------------------------------------------------------------------------- subroutine free_emax_array implicit none deallocate ( emax ) end subroutine free_emax_array !--------------------------------------------------------------------------- ! Update emax data array ! Input: !   emax_pic_mpi: maximum kinetic energy in each cell for one PIC MPI !   otx, oty, otz: the offsets in PIC MPI process !--------------------------------------------------------------------------- subroutine update_emax_array ( emax_pic_mpi , otx , oty , otz ) use picinfo , only : domain implicit none real ( fp ), dimension (:, :, :), intent ( in ) :: emax_pic_mpi integer , intent ( in ) :: otx , oty , otz integer :: ixl , ixh , iyl , iyh , izl , izh ixl = otx * domain % pic_nx + 1 iyl = oty * domain % pic_ny + 1 izl = otz * domain % pic_nz + 1 ixh = ixl + domain % pic_nx - 1 iyh = iyl + domain % pic_ny - 1 izh = izl + domain % pic_nz - 1 emax ( ixl : ixh , iyl : iyh , izl : izh ) = emax_pic_mpi end subroutine update_emax_array !--------------------------------------------------------------------------- ! Write emax array to file !--------------------------------------------------------------------------- subroutine write_emax ( ct , species ) use mpi_module use path_info , only : outputpath use mpi_io_module , only : open_data_mpi_io , write_data_mpi_io use mpi_info_module , only : fileinfo implicit none integer , intent ( in ) :: ct character ( len = 1 ), intent ( in ) :: species integer ( kind = MPI_OFFSET_KIND ) :: disp , offset character ( len = 150 ) :: fname integer :: fh disp = domain % nx * domain % ny * domain % nz * sizeof ( MPI_REAL ) * ( ct - 1 ) offset = 0 fname = trim ( adjustl ( outputpath )) // 'emax_' // species // '.gda' call open_data_mpi_io ( fname , MPI_MODE_RDWR + MPI_MODE_CREATE , fileinfo , fh ) call write_data_mpi_io ( fh , datatype , subsizes , disp , offset , emax ) call MPI_FILE_CLOSE ( fh , ierror ) end subroutine write_emax !--------------------------------------------------------------------------- ! Set emax datatype for MPI IO !--------------------------------------------------------------------------- subroutine set_emax_datatype use mpi_datatype_module , only : set_mpi_datatype implicit none sizes = [ nx_tot , ny_tot , nz_tot ] subsizes = [ nxp , nyp , nzp ] starts = [ nxs , nys , nzs ] datatype = set_mpi_datatype ( sizes , subsizes , starts ) end subroutine set_emax_datatype !--------------------------------------------------------------------------- ! Free emax datatype for MPI IO !--------------------------------------------------------------------------- subroutine free_emax_datatype use mpi_module implicit none call MPI_TYPE_FREE ( datatype , ierror ) end subroutine free_emax_datatype !--------------------------------------------------------------------------- ! Set topology for current analysis ! Input: !   tx, ty, tz: the box sizes in PIC MPI topology !--------------------------------------------------------------------------- subroutine set_ana_topology ( tx , ty , tz , txc , tyc , tzc ) use mpi_module implicit none integer , intent ( in ) :: tx , ty , tz integer , intent ( out ) :: txc , tyc , tzc integer :: tot_mpi tot_mpi = tx * ty * tz if ( myid > ( tot_mpi - 1 )) then ! To many processes to use txc = 0 tyc = 0 tzc = 0 else if ( numprocs <= tx ) then ! Most cases txc = numprocs else ! Possible for 3D txc = gcd ( tx , numprocs ) if ( numprocs / txc <= ty ) then tyc = numprocs / txc else tyc = gcd ( ty , numprocs / txc ) tzc = numprocs / txc / tyc if ( tzc > tz ) then call MPI_FINALIZE ( ierr ) print * , \"Impossible to balance the topology.\" stop endif endif endif endif end subroutine set_ana_topology !--------------------------------------------------------------------------- ! Get the greatest common divisor of two numbers !--------------------------------------------------------------------------- function gcd ( a0 , b0 ) result ( a ) implicit none integer , intent ( in ) :: a0 , b0 integer :: a","tags":"","loc":"sourcefile/maximum_energy.f90.html","title":"maximum_energy.f90 – Fortran Program"},{"text":"MPI topology for current analysis. The PIC simulation has one MPI topology.\n When doing post-analysis, we use less CPU cores. So we must make sure the\n tasks are equally divided among all the MPI processes of current analysis. Source Code !******************************************************************************* ! MPI topology for current analysis. The PIC simulation has one MPI topology. ! When doing post-analysis, we use less CPU cores. So we must make sure the ! tasks are equally divided among all the MPI processes of current analysis. !******************************************************************************* module topology_translate use mpi_module use constants , only : fp , dp use rank_index_mapping , only : rank_to_index implicit none private public idxstart , idxstop , ht , set_topology , set_start_stop_cells , & free_start_stop_cells ! Starting and stopping cells for current MPI process. integer , allocatable , dimension (:,:) :: idxstart , idxstop ! MPI 3D topology for current analysis. The MPI topology of the PIC ! simulation is also 3D, but with larger sizes. The start_x and stop_x ! indices are based one the MPI topology of the PIC simulation. type ht_type integer :: tx , ty , tz ! Number of processes in x and y integer :: ix , iy , iz ! MPI process ID in each dimension. integer :: nx , ny , nz ! Number of cells in each direction integer :: start_x , stop_x ! Where to start/stop in x integer :: start_z , stop_z , start_y , stop_y end type ht_type type ( ht_type ) :: ht contains !--------------------------------------------------------------------------- ! Set topology for current analysis. !--------------------------------------------------------------------------- subroutine set_topology use configuration_translate , only : httx , htty , httz use picinfo , only : domain implicit none ht % tx = httx ht % ty = htty ht % tz = httz ! Map myid to a 3D topology. call rank_to_index ( myid , ht % tx , ht % ty , ht % tz , ht % ix , ht % iy , ht % iz ) ! Domain start/stop for this process ht % start_x = ( domain % pic_tx / ht % tx ) * ht % ix ht % stop_x = ( domain % pic_tx / ht % tx ) * ( ht % ix + 1 ) - 1 ht % start_y = ( domain % pic_ty / ht % ty ) * ht % iy ht % stop_y = ( domain % pic_ty / ht % ty ) * ( ht % iy + 1 ) - 1 ht % start_z = ( domain % pic_tz / ht % tz ) * ht % iz ht % stop_z = ( domain % pic_tz / ht % tz ) * ( ht % iz + 1 ) - 1 ! Number of cells for each process ht % nx = domain % nx / ht % tx ht % ny = domain % ny / ht % ty ht % nz = domain % nz / ht % tz if ( myid == master ) then ! echo this information print * , \"---------------------------------------------------\" print * , \"The topology information for current analysis\" write ( * , \"(A,I0,A,I0,A,I0)\" ) \" Topology: tx, ty, tz = \" , & ht % tx , ', ' , ht % ty , ', ' , ht % tz write ( * , \"(A,I0,A,I0,A,I0)\" ) \" Cells: nx, ny, nz = \" , & ht % nx , ', ' , ht % ny , ', ' , ht % nz print * , \"---------------------------------------------------\" endif end subroutine set_topology !--------------------------------------------------------------------------- ! Set the starting and stopping cell indices for current MPI process. !--------------------------------------------------------------------------- subroutine set_start_stop_cells use picinfo , only : domain implicit none integer :: ndomains , ix , iy , iz , n ndomains = domain % pic_tx * domain % pic_ty * domain % pic_tz allocate ( idxstart ( ndomains , 3 )) allocate ( idxstop ( ndomains , 3 )) ! Determine total size of global problem do n = 1 , ndomains call rank_to_index ( n - 1 , domain % pic_tx , domain % pic_ty , & domain % pic_tz , ix , iy , iz ) idxstart ( n , 1 ) = (( domain % nx / domain % pic_tx )) * ix + 1 - ht % nx * ht % ix idxstart ( n , 2 ) = (( domain % ny / domain % pic_ty )) * iy + 1 - ht % ny * ht % iy idxstart ( n , 3 ) = (( domain % nz / domain % pic_tz )) * iz + 1 - ht % nz * ht % iz idxstop ( n , 1 ) = idxstart ( n , 1 ) + ( domain % nx / domain % pic_tx ) - 1 idxstop ( n , 2 ) = idxstart ( n , 2 ) + ( domain % ny / domain % pic_ty ) - 1 idxstop ( n , 3 ) = idxstart ( n , 3 ) + ( domain % nz / domain % pic_tz ) - 1 enddo ! Check the topology for consistency if (( ht % tx * ht % ty * ht % tz /= numprocs ) .or. & (( domain % pic_tx / ht % tx ) * ht % tx /= domain % pic_tx ) .or. & (( domain % pic_tz / ht % tz ) * ht % tz /= domain % pic_tz ) .or. & (( domain % pic_ty / ht % ty ) * ht % ty /= domain % pic_ty )) then if ( myid == master ) print * , \"invalid converter topology\" call MPI_FINALIZE ( ierr ) stop endif end subroutine set_start_stop_cells !--------------------------------------------------------------------------- ! Free starting and stopping cell indices. !--------------------------------------------------------------------------- subroutine free_start_stop_cells implicit none deallocate ( idxstart , idxstop ) end subroutine free_start_stop_cells end module topology_translate","tags":"","loc":"sourcefile/topology_translate.f90.html","title":"topology_translate.f90 – Fortran Program"},{"text":"Module of electromagnetic fields. Source Code !******************************************************************************* ! Module of electromagnetic fields. !******************************************************************************* module emfields use constants , only : fp implicit none private public init_emfields , free_emfields , read_emfields , write_emfields real ( fp ), allocatable , dimension (:,:,:) :: ex , ey , ez , bx , by , bz , absB contains !--------------------------------------------------------------------------- ! Initialize the fields !--------------------------------------------------------------------------- subroutine init_emfields use topology_translate , only : ht implicit none allocate ( ex ( ht % nx , ht % ny , ht % nz )) allocate ( ey ( ht % nx , ht % ny , ht % nz )) allocate ( ez ( ht % nx , ht % ny , ht % nz )) allocate ( bx ( ht % nx , ht % ny , ht % nz )) allocate ( by ( ht % nx , ht % ny , ht % nz )) allocate ( bz ( ht % nx , ht % ny , ht % nz )) allocate ( absB ( ht % nx , ht % ny , ht % nz )) ex = 0.0 ; ey = 0.0 ; ez = 0.0 bx = 0.0 ; by = 0.0 ; bz = 0.0 absB = 0.0 end subroutine init_emfields !--------------------------------------------------------------------------- ! Free the fields !--------------------------------------------------------------------------- subroutine free_emfields implicit none deallocate ( ex , ey , ez ) deallocate ( bx , by , bz , absB ) end subroutine free_emfields !--------------------------------------------------------------------------- ! Read electromagnetic fields from file. ! Inputs: !   tindex0: the time step index. !--------------------------------------------------------------------------- subroutine read_emfields ( tindex0 ) use rank_index_mapping , only : index_to_rank use picinfo , only : domain use topology_translate , only : ht implicit none integer , intent ( in ) :: tindex0 integer :: dom_x , dom_y , dom_z , n do dom_x = ht % start_x , ht % stop_x do dom_y = ht % start_y , ht % stop_y do dom_z = ht % start_z , ht % stop_z call index_to_rank ( dom_x , dom_y , dom_z , domain % pic_tx , & domain % pic_ty , domain % pic_tz , n ) call read_emfields_single ( tindex0 , n - 1 ) enddo ! x enddo ! y enddo ! z absB = sqrt ( bx ** 2 + by ** 2 + bz ** 2 ) end subroutine read_emfields !--------------------------------------------------------------------------- ! Read the fields for a single MPI process of PIC simulation. ! Inputs: !   tindex0: the time step index. !   pic_mpi_id: MPI id for the PIC simulation to identify the file. !--------------------------------------------------------------------------- subroutine read_emfields_single ( tindex0 , pic_mpi_id ) use path_info , only : rootpath use constants , only : fp use file_header , only : read_boilerplate , read_fields_header , fheader use topology_translate , only : idxstart , idxstop implicit none integer , intent ( in ) :: tindex0 , pic_mpi_id real ( fp ), allocatable , dimension (:,:,:) :: buffer character ( len = 150 ) :: fname logical :: is_exist integer :: fh ! File handler integer :: n , ixl , iyl , izl , ixh , iyh , izh integer :: nc1 , nc2 , nc3 integer :: tindex fh = 10 tindex = tindex0 ! Index 0 does not have proper current, so use index 1 if it exists if ( tindex == 0 ) then write ( fname , \"(A,I0,A8,I0,A1,I0)\" ) trim ( adjustl ( rootpath )) // \"fields/T.\" , & 1 , \"/fields.\" , 1 , \".\" , pic_mpi_id is_exist = .false. inquire ( file = trim ( fname ), exist = is_exist ) if ( is_exist ) tindex = 1 endif write ( fname , \"(A,I0,A8,I0,A1,I0)\" ) trim ( adjustl ( rootpath )) // \"fields/T.\" , & tindex , \"/fields.\" , tindex , \".\" , pic_mpi_id is_exist = .false. inquire ( file = trim ( fname ), exist = is_exist ) if ( is_exist ) then open ( unit = 10 , file = trim ( fname ), access = 'stream' , status = 'unknown' , & form = 'unformatted' , action = 'read' ) else print * , \"Can't find file:\" , fname print * print * , \" ***  Terminating ***\" stop endif call read_boilerplate ( fh ) call read_fields_header ( fh ) allocate ( buffer ( fheader % nc ( 1 ), fheader % nc ( 2 ), fheader % nc ( 3 ))) n = pic_mpi_id + 1 ! MPI ID starts at 0. The 1D rank starts at 1. ixl = idxstart ( n , 1 ) iyl = idxstart ( n , 2 ) izl = idxstart ( n , 3 ) ixh = idxstop ( n , 1 ) iyh = idxstop ( n , 2 ) izh = idxstop ( n , 3 ) nc1 = fheader % nc ( 1 ) - 1 nc2 = fheader % nc ( 2 ) - 1 nc3 = fheader % nc ( 3 ) - 1 read ( fh ) buffer ex ( ixl : ixh , iyl : iyh , izl : izh ) = buffer ( 2 : nc1 , 2 : nc2 , 2 : nc3 ) read ( fh ) buffer ey ( ixl : ixh , iyl : iyh , izl : izh ) = buffer ( 2 : nc1 , 2 : nc2 , 2 : nc3 ) read ( fh ) buffer ez ( ixl : ixh , iyl : iyh , izl : izh ) = buffer ( 2 : nc1 , 2 : nc2 , 2 : nc3 ) read ( fh ) buffer bx ( ixl : ixh , iyl : iyh , izl : izh ) = buffer ( 2 : nc1 , 2 : nc2 , 2 : nc3 ) read ( fh ) buffer by ( ixl : ixh , iyl : iyh , izl : izh ) = buffer ( 2 : nc1 , 2 : nc2 , 2 : nc3 ) read ( fh ) buffer bz ( ixl : ixh , iyl : iyh , izl : izh ) = buffer ( 2 : nc1 , 2 : nc2 , 2 : nc3 ) deallocate ( buffer ) close ( fh ) end subroutine read_emfields_single !--------------------------------------------------------------------------- ! Save electromagnetic fields. !   tindex: the time step index. !   output_record: it decides the offset from the file head. !--------------------------------------------------------------------------- subroutine write_emfields ( tindex , output_record ) use path_info , only : rootpath use mpi_io_translate , only : write_data implicit none integer , intent ( in ) :: tindex , output_record call write_data ( trim ( adjustl ( rootpath )) // 'data/ex' , & ex , tindex , output_record ) call write_data ( trim ( adjustl ( rootpath )) // 'data/ey' , & ey , tindex , output_record ) call write_data ( trim ( adjustl ( rootpath )) // 'data/ez' , & ez , tindex , output_record ) call write_data ( trim ( adjustl ( rootpath )) // 'data/bx' , & bx , tindex , output_record ) call write_data ( trim ( adjustl ( rootpath )) // 'data/by' , & by , tindex , output_record ) call write_data ( trim ( adjustl ( rootpath )) // 'data/bz' , & bz , tindex , output_record ) call write_data ( trim ( adjustl ( rootpath )) // 'data/absB' , & absB , tindex , output_record ) end subroutine write_emfields end module emfields","tags":"","loc":"sourcefile/emfields.f90.html","title":"emfields.f90 – Fortran Program"},{"text":"This module includes procedures to trace magnetic field lines.\n We only consider 2D domain in x-z plane here. Source Code !******************************************************************************* ! This module includes procedures to trace magnetic field lines. ! We only consider 2D domain in x-z plane here. !******************************************************************************* module fieldline_tracing use constants , only : fp implicit none private public nx , nz , gdx , gdz , lx , lz , a , b , c , dc , xarr , zarr , npoints , hmax public init_fieldline_tracing , end_fieldline_tracing , tracing , & get_crossing_point , controller , push , derivs , & Cash_Karp_parameters , Dormand_Prince_parameters , & init_fieldline_points , free_fieldline_points , trace_field_line integer :: nx , nz real ( fp ) :: gdx , gdz , lx , lz ! Grid sizes and lengths in di. real ( fp ) :: hmax ! Maximum step allowed real ( fp ), allocatable , dimension (:) :: xarr , zarr ! Maximum number of points along one field line. integer , parameter :: np_max = 1 E3 real ( fp ), parameter :: hmax_gdx = 1 0.0 ! Maximum step in gdx integer :: npoints ! The actual number of points along one filed line. ! Adaptive Runge-Kutta parameters. real ( fp ), dimension ( 0 : 6 ) :: a , c , dc real ( fp ), dimension ( 0 : 5 , 0 : 6 ) :: b contains !--------------------------------------------------------------------------- ! Set the grid information, including the grid sizes and grid lengths. !--------------------------------------------------------------------------- subroutine set_grid_info use constants , only : fp use picinfo , only : domain , mime implicit none nx = domain % nx nz = domain % nz gdx = domain % dx / sqrt ( mime ) gdz = domain % dz / sqrt ( mime ) lx = domain % lx_de / sqrt ( mime ) lz = domain % lz_de / sqrt ( mime ) hmax = hmax_gdx * gdx ! Maximum step allowed end subroutine set_grid_info !--------------------------------------------------------------------------- ! Initialize field line tracing, including setting the grid information, ! initializing magnetic field and read magnetic field. !--------------------------------------------------------------------------- subroutine init_fieldline_tracing use magnetic_field , only : init_magnetic_fields implicit none call set_grid_info call init_magnetic_fields end subroutine init_fieldline_tracing !--------------------------------------------------------------------------- ! Initialize the array of the points along a filed line. !--------------------------------------------------------------------------- subroutine init_fieldline_points implicit none allocate ( xarr ( np_max )) allocate ( zarr ( np_max )) xarr = 0.0 zarr = 0.0 end subroutine init_fieldline_points !--------------------------------------------------------------------------- ! Free the array of the points along a field line. !--------------------------------------------------------------------------- subroutine free_fieldline_points implicit none deallocate ( xarr , zarr ) end subroutine free_fieldline_points !--------------------------------------------------------------------------- ! Finish field line tracing by freeing the magnetic field. !--------------------------------------------------------------------------- subroutine end_fieldline_tracing use magnetic_field , only : free_magnetic_fields implicit none call free_magnetic_fields end subroutine end_fieldline_tracing !--------------------------------------------------------------------------- ! Trace magnetic field line starting at one point. The length of the field ! line is used as the variable, so Bx/dx = By/dy = Bz/dz = B/ds. ! Inputs: !   htry: the first-try step size. !   x0, z0: the coordinates of current point. !   direction_flag: 1 for forward, -1 for backward. ! References: !   Press, William H. Numerical recipes 3rd edition: The art of scientific !   computing. Cambridge university press, 2007. Chapter 17.2. !--------------------------------------------------------------------------- subroutine tracing ( x0 , z0 , htry , direction_flag ) use constants , only : fp implicit none real ( fp ), intent ( in ) :: x0 , z0 , htry integer , intent ( in ) :: direction_flag real ( fp ), dimension ( 0 : 6 ) :: kx , ky , kz real ( fp ) :: arc_length , xout , zout , xold , zold real ( fp ) :: x , z , xcross , zcross real ( fp ) :: dxds , dyds , dzds , dxdsnew , dydsnew , dzdsnew real ( fp ) :: h , hnext , errold logical :: is_accept arc_length = 0.0 h = htry errold = 1.0e-4 is_accept = .false. npoints = 1 x = x0 z = z0 xarr ( npoints ) = x zarr ( npoints ) = z call derivs ( x , z , direction_flag , dxds , dyds , dzds ) do while ( x > 0 .and. x < lx .and. z > 0 .and. z < lz .and. & arc_length < 2 * lx ) call push ( dxds , dyds , dzds , direction_flag , x , z , h , kx , ky , kz , & xout , zout , dxdsnew , dydsnew , dzdsnew ) call controller ( h , hmax , hnext , x , z , xout , zout , & kx , kz , is_accept , errold ) if ( is_accept ) then arc_length = arc_length + h xold = x zold = z x = xout z = zout dxds = dxdsnew dyds = dydsnew dzds = dzdsnew h = hnext npoints = npoints + 1 xarr ( npoints ) = x zarr ( npoints ) = z endif enddo ! while loop ! Make sure it integrates to the boundary. if ( x < 0 .or. x > lx .or. z < 0 .or. z > lz ) then ! This excludes the closed field inside the domain. xcross = 0.0 zcross = 0.0 call get_crossing_point ( x , z , xold , zold , lx , lz , xcross , zcross ) h = sqrt (( xcross - xold ) ** 2 + ( zcross - zold ) ** 2 ) arc_length = arc_length + h call push ( dxds , dyds , dzds , direction_flag , x , z , h , kx , ky , kz , & xout , zout , dxdsnew , dydsnew , dzdsnew ) npoints = npoints + 1 xarr ( npoints ) = x zarr ( npoints ) = z endif end subroutine tracing !--------------------------------------------------------------------------- ! Trace magnetic field line starting at one point. Record the total number ! of points along the field line. ! Inputs: !   x0, z0: the coordinates of the starting point. !--------------------------------------------------------------------------- subroutine trace_field_line ( x0 , z0 ) use constants , only : fp use picinfo , only : domain , mime implicit none real ( fp ), intent ( in ) :: x0 , z0 real ( fp ) :: htry integer :: direction_flag htry = gdx direction_flag = 1 ! Forward along the magnetic field call tracing ( x0 , z0 , htry , direction_flag ) xarr = xarr * sqrt ( mime ) ! di -> de zarr = zarr * sqrt ( mime ) end subroutine trace_field_line !--------------------------------------------------------------------------- ! Save the coordinates of the points along a filed line. !--------------------------------------------------------------------------- subroutine save_fieldline_points implicit none integer :: i open ( unit = 20 , file = 'xz_field.dat' , status = 'unknown' ) do i = 1 , npoints write ( 20 , '(2e12.4)' ) xarr ( i ), zarr ( i ) enddo close ( 20 ) end subroutine save_fieldline_points !--------------------------------------------------------------------------- ! Get the boundary crossing point. ! Inputs: !   x, z: the position of the point outside the box. !   xold, zold: the position of the point inside the box. !   lx, lz: the sizes of the box. ! Outputs: !   xcross, zcross: the crossing point. !--------------------------------------------------------------------------- subroutine get_crossing_point ( x , z , xold , zold , lx , lz , xcross , zcross ) use constants , only : fp implicit none real ( fp ), intent ( in ) :: x , z , xold , zold , lx , lz real ( fp ), intent ( out ) :: xcross , zcross real ( fp ) :: k , xb , xt , zr , zl if (( x - xold ) /= 0.0 ) then k = ( z - zold ) / ( x - xold ) xb = xold - zold / k ! Bottom if ( xb >= 0 .and. xb","tags":"","loc":"sourcefile/fieldline_tracing.f90.html","title":"fieldline_tracing.f90 – Fortran Program"},{"text":"Module of particle related fields, including bulk flow velocity, particle\n number density, particle fraction in each energy band (eb), particle stress\n tensor and current density. Source Code !******************************************************************************* ! Module of particle related fields, including bulk flow velocity, particle ! number density, particle fraction in each energy band (eb), particle stress ! tensor and current density. !******************************************************************************* module particle_fields use constants , only : fp use path_info , only : rootpath use picinfo , only : nbands use parameters , only : is_rel ! Whether they are relativistic fields. implicit none private public init_particle_fields , init_density_fields , init_velocity_fields , & init_current_densities , init_pressure_tensor , read_particle_fields , & read_density_fields_single , read_velocity_fields_single , & read_pressure_tensor_single , free_particle_fields , & free_velocity_fields , free_density_fields , free_current_densities , & free_pressure_tensor , set_current_density_zero , adjust_particle_fields , & write_particle_fields , calc_current_density , calc_absJ , & write_current_densities public nrho , eb real ( fp ), allocatable , dimension (:,:,:) :: vx , vy , vz , nrho real ( fp ), allocatable , dimension (:,:,:) :: pxx , pxy , pxz , pyy , pyz , pzz real ( fp ), allocatable , dimension (:,:,:) :: jx , jy , jz , absJ real ( fp ), allocatable , dimension (:,:,:) :: pyx , pzx , pzy , ux , uy , uz real ( fp ), allocatable , dimension (:,:,:,:) :: eb contains !--------------------------------------------------------------------------- ! Initialize particle related fields. !--------------------------------------------------------------------------- subroutine init_particle_fields call init_density_fields call init_velocity_fields call init_pressure_tensor call init_current_densities end subroutine init_particle_fields !--------------------------------------------------------------------------- ! Initialize density and particle fraction for different energy band. !--------------------------------------------------------------------------- subroutine init_density_fields use topology_translate , only : ht implicit none allocate ( nrho ( ht % nx , ht % ny , ht % nz )) if ( nbands > 0 ) then allocate ( eb ( ht % nx , ht % ny , ht % nz , nbands )) eb = 0.0 endif nrho = 0.0 end subroutine init_density_fields !--------------------------------------------------------------------------- ! Initialize velocity fields. !--------------------------------------------------------------------------- subroutine init_velocity_fields use topology_translate , only : ht implicit none allocate ( vx ( ht % nx , ht % ny , ht % nz )) allocate ( vy ( ht % nx , ht % ny , ht % nz )) allocate ( vz ( ht % nx , ht % ny , ht % nz )) vx = 0.0 ; vy = 0.0 ; vz = 0.0 if ( is_rel == 1 ) then ! Relativistic fields allocate ( ux ( ht % nx , ht % ny , ht % nz )) allocate ( uy ( ht % nx , ht % ny , ht % nz )) allocate ( uz ( ht % nx , ht % ny , ht % nz )) ux = 0.0 ; uy = 0.0 ; uz = 0.0 endif end subroutine init_velocity_fields !--------------------------------------------------------------------------- ! Initialize pressure tensor fields. !--------------------------------------------------------------------------- subroutine init_pressure_tensor use topology_translate , only : ht implicit none allocate ( pxx ( ht % nx , ht % ny , ht % nz )) allocate ( pxy ( ht % nx , ht % ny , ht % nz )) allocate ( pxz ( ht % nx , ht % ny , ht % nz )) allocate ( pyy ( ht % nx , ht % ny , ht % nz )) allocate ( pyz ( ht % nx , ht % ny , ht % nz )) allocate ( pzz ( ht % nx , ht % ny , ht % nz )) pxx = 0.0 ; pxy = 0.0 ; pxz = 0.0 pyy = 0.0 ; pyz = 0.0 ; pzz = 0.0 if ( is_rel == 1 ) then ! Relativistic fields allocate ( pyx ( ht % nx , ht % ny , ht % nz )) allocate ( pzx ( ht % nx , ht % ny , ht % nz )) allocate ( pzy ( ht % nx , ht % ny , ht % nz )) pyx = 0.0 ; pzx = 0.0 ; pzy = 0.0 endif end subroutine init_pressure_tensor !--------------------------------------------------------------------------- ! Initialize current densities. !--------------------------------------------------------------------------- subroutine init_current_densities use topology_translate , only : ht implicit none allocate ( jx ( ht % nx , ht % ny , ht % nz )) allocate ( jy ( ht % nx , ht % ny , ht % nz )) allocate ( jz ( ht % nx , ht % ny , ht % nz )) allocate ( absJ ( ht % nx , ht % ny , ht % nz )) call set_current_density_zero end subroutine init_current_densities !--------------------------------------------------------------------------- ! Set current densities to zero to avoid accumulation. !--------------------------------------------------------------------------- subroutine set_current_density_zero implicit none jx = 0.0 ; jy = 0.0 ; jz = 0.0 absJ = 0.0 end subroutine set_current_density_zero !--------------------------------------------------------------------------- ! Free particle related fields. !--------------------------------------------------------------------------- subroutine free_particle_fields implicit none call free_density_fields call free_velocity_fields call free_pressure_tensor call free_current_densities end subroutine free_particle_fields !--------------------------------------------------------------------------- ! Free density and particle fraction for different energy band. !--------------------------------------------------------------------------- subroutine free_density_fields implicit none deallocate ( nrho ) if ( nbands > 0 ) then deallocate ( eb ) endif end subroutine free_density_fields !--------------------------------------------------------------------------- ! Free velocity fields. !--------------------------------------------------------------------------- subroutine free_velocity_fields implicit none deallocate ( vx , vy , vz ) if ( is_rel == 1 ) then deallocate ( ux , uy , uz ) endif end subroutine free_velocity_fields !--------------------------------------------------------------------------- ! Free pressure tensor fields. !--------------------------------------------------------------------------- subroutine free_pressure_tensor implicit none deallocate ( pxx , pxy , pxz , pyy , pyz , pzz ) if ( is_rel == 1 ) then deallocate ( pyx , pzx , pzy ) endif end subroutine free_pressure_tensor !--------------------------------------------------------------------------- ! Free current densities. !--------------------------------------------------------------------------- subroutine free_current_densities implicit none deallocate ( jx , jy , jz , absJ ) end subroutine free_current_densities !--------------------------------------------------------------------------- ! Read electromagnetic fields from file. ! Inputs: !   tindex0: the time step index. !   species: 'e' for electron, 'H' for ion. !--------------------------------------------------------------------------- subroutine read_particle_fields ( tindex0 , species ) use rank_index_mapping , only : index_to_rank use picinfo , only : domain use topology_translate , only : ht implicit none integer , intent ( in ) :: tindex0 character ( len = 1 ), intent ( in ) :: species integer :: dom_x , dom_y , dom_z , n do dom_x = ht % start_x , ht % stop_x do dom_y = ht % start_y , ht % stop_y do dom_z = ht % start_z , ht % stop_z call index_to_rank ( dom_x , dom_y , dom_z , domain % pic_tx , & domain % pic_ty , domain % pic_tz , n ) call read_particle_fields_single ( tindex0 , n - 1 , species ) enddo ! x enddo ! y enddo ! z end subroutine read_particle_fields !--------------------------------------------------------------------------- ! Open one particle fields file. ! Input: !   fh: file handler !   tindex0: the time step index. !   pic_mpi_id: MPI id for the PIC simulation to identify the file. !   species: 'e' for electron, 'H' for ion. !--------------------------------------------------------------------------- subroutine open_particle_file ( fh , tindex0 , pic_mpi_id , species ) use file_header , only : read_boilerplate , read_fields_header implicit none integer , intent ( in ) :: fh ! File handler integer , intent ( in ) :: tindex0 , pic_mpi_id character ( len = 1 ), intent","tags":"","loc":"sourcefile/particle_fields.f90.html","title":"particle_fields.f90 – Fortran Program"},{"text":"Main program to calculate particle spectrum and velocity distributions in a\n user defined box. Source Code !******************************************************************************* ! Main program to calculate particle spectrum and velocity distributions in a ! user defined box. !******************************************************************************* subroutine particle_spectrum_vdist_box use particle_spectrum_vdist_module , only : particle_spectrum_vdist_main implicit none call particle_spectrum_vdist_main end subroutine particle_spectrum_vdist_box","tags":"","loc":"sourcefile/particle_spectrum_vdist_python.f90.html","title":"particle_spectrum_vdist_python.f90 – Fortran Program"},{"text":"Module of particle information. Source Code !******************************************************************************* ! Module of particle information. !******************************************************************************* module particle_module use constants , only : fp implicit none private public ptl , ke , px , py , pz , vpara , vperp , gama , igama , vparax , vparay , & vparaz , vperpx , vperpy , vperpz , gyrof , vgx , vgy , vgz , vcx , vcy , & vcz , ci , cj , ck , iex , jex , kex , iey , jey , key , iez , jez , kez , & ibx , jbx , kbx , iby , jby , kby , ibz , jbz , kbz , dx_ex , dy_ex , dz_ex , & dx_ey , dy_ey , dz_ey , dx_ez , dy_ez , dz_ez , dx_bx , dx_by , dx_bz , & dy_bx , dy_by , dy_bz , dz_bx , dz_by , dz_bz public calc_particle_energy , calc_ptl_coord , calc_para_perp_velocity , & calc_para_perp_velocity_3d , calc_gyrofrequency , & calc_gradient_drift_velocity , calc_curvature_drift_velocity , & calc_interp_param type particle real ( fp ) :: dx , dy , dz ! Particle relative position in a cell [-1,1] integer :: icell ! Index of cell containing the particle real ( fp ) :: vx , vy , vz ! Particle normalized momentum real ( fp ) :: q end type particle type ( particle ) :: ptl real ( fp ) :: ke ! Kinetic energy real ( fp ) :: gama , igama ! Lorentz factor and its inverse real ( fp ) :: px , py , pz ! Particle position real ( fp ) :: vpara , vperp ! Parallel and perpendicular momentum real ( fp ) :: vparax , vparay , vparaz ! Parallel velocity real ( fp ) :: vperpx , vperpy , vperpz ! Perpendicular velocity real ( fp ) :: gyrof ! Gyrofrequency real ( fp ) :: vgx , vgy , vgz ! Gradient drift velocity real ( fp ) :: vcx , vcy , vcz ! Curvature drift velocity integer :: ci , cj , ck ! Cell indices where the particle is in integer :: iex , jex , kex ! The indices of the corner for Ex interpolation integer :: iey , jey , key , iez , jez , kez integer :: ibx , iby , ibz , jbx , jby , jbz , kbx , kby , kbz real ( fp ) :: dx_ex , dy_ex , dz_ex ! The offsets for Ex interpolation real ( fp ) :: dx_ey , dy_ey , dz_ey , dx_ez , dy_ez , dz_ez real ( fp ) :: dx_bx , dx_by , dx_bz , dy_bx , dy_by , dy_bz real ( fp ) :: dz_bx , dz_by , dz_bz contains !--------------------------------------------------------------------------- ! Read one single particle information, calculate its energy and put it into ! the right place of the flux arrays. ! Input: !   fh: file handler. !--------------------------------------------------------------------------- subroutine calc_particle_energy implicit none gama = sqrt ( 1.0 + ptl % vx ** 2 + ptl % vy ** 2 + ptl % vz ** 2 ) igama = 1.0 / gama ke = gama - 1.0 end subroutine calc_particle_energy !--------------------------------------------------------------------------- ! Calculate the particle's coordinates. [0 - lx, -ly/2 - ly/2, -lz/2 - lz/2] ! They are in electron skin length (de). !--------------------------------------------------------------------------- subroutine calc_ptl_coord use file_header , only : v0 implicit none integer :: nx , ny , nz integer :: icell ! Including ghost cells nx = v0 % nx + 2 ny = v0 % ny + 2 nz = v0 % nz + 2 icell = ptl % icell ck = icell / ( nx * ny ) ! [1,nz-2] cj = ( icell - ck * nx * ny ) / nx ! [1,ny-2] ci = icell - ck * nx * ny - cj * nx ! [1,nx-2] ! nx, ny, nz include ghost cells. The actual cells start at 1. pz = v0 % z0 + (( ck - 1 ) + ( ptl % dz + 1 ) * 0.5 ) * v0 % dz py = v0 % y0 + (( cj - 1 ) + ( ptl % dy + 1 ) * 0.5 ) * v0 % dy px = v0 % x0 + (( ci - 1 ) + ( ptl % dx + 1 ) * 0.5 ) * v0 % dx end subroutine calc_ptl_coord !--------------------------------------------------------------------------- ! Get the parameters for fields interpolation. See the notes for details. !--------------------------------------------------------------------------- subroutine calc_interp_param use file_header , only : v0 implicit none integer :: nx , ny , nz , icell real ( fp ) :: dx , dy , dz ! Including ghost cells nx = v0 % nx + 2 ny = v0 % ny + 2 nz = v0 % nz + 2 icell = ptl % icell ck = icell / ( nx * ny ) ! [1,nz-2] cj = ( icell - ck * nx * ny ) / nx ! [1,ny-2] ci = icell - ck * nx * ny - cj * nx ! [1,nx-2] ! Particle offset from the center of a cell. [-1, 1] dx = ptl % dx dy = ptl % dy dz = ptl % dz ! Ex jex = cj kex = ck dy_ex = 0.5 * ( 1 + dy ) dz_ex = 0.5 * ( 1 + dz ) ! Ey iey = ci key = ck dx_ey = 0.5 * ( 1 + dx ) dz_ey = 0.5 * ( 1 + dz ) ! Ez iez = ci jez = cj dx_ez = 0.5 * ( 1 + dx ) dy_ez = 0.5 * ( 1 + dy ) ! Bx ibx = ci dx_bx = 0.5 * ( 1 + dx ) ! By jby = cj dy_by = 0.5 * ( 1 + dy ) ! Bz kbz = ck dz_bz = 0.5 * ( 1 + dz ) if ( dx < 0 ) then iex = ci - 1 dx_ex = 0.5 * dx + 1 iby = ci - 1 dx_by = 0.5 * dx + 1 ibz = ci - 1 dx_bz = 0.5 * dx + 1 else iex = ci dx_ex = 0.5 * dx iby = ci dx_by = 0.5 * dx ibz = ci dx_bz = 0.5 * dx endif if ( dy < 0 ) then jey = cj - 1 dy_ey = 0.5 * dy + 1 jbx = cj - 1 dy_bx = 0.5 * dy + 1 jbz = cj - 1 dy_bz = 0.5 * dy + 1 else jey = cj dy_ey = 0.5 * dy jbx = cj dy_bx = 0.5 * dy jbz = cj dy_bz = 0.5 * dy endif if ( dz < 0 ) then kez = ck - 1 dz_ez = 0.5 * dz + 1 kbx = ck - 1 dz_bx = 0.5 * dz + 1 kby = ck - 1 dz_by = 0.5 * dz + 1 else kez = ck dz_ez = 0.5 * dz kbx = ck dz_bx = 0.5 * dz kby = ck dz_by = 0.5 * dz endif end subroutine calc_interp_param !--------------------------------------------------------------------------- ! Calculate the particle's parallel and perpendicular momentum to the local ! magnetic field. !--------------------------------------------------------------------------- subroutine calc_para_perp_velocity use picinfo , only : domain use magnetic_field , only : bx0 , by0 , bz0 , get_magnetic_field_at_point implicit none real ( fp ) :: absB real ( fp ) :: dx , dz dx = real ( domain % dx , kind = 4 ) dz = real ( domain % dz ,","tags":"","loc":"sourcefile/particle_module.f90.html","title":"particle_module.f90 – Fortran Program"},{"text":"Module of particle file. It includes the routines to check the existence of\n a particle file, to open a particle file and read its headers, to check if the\n particles are in the required spatial range. Source Code !******************************************************************************* ! Module of particle file. It includes the routines to check the existence of ! a particle file, to open a particle file and read its headers, to check if the ! particles are in the required spatial range. !******************************************************************************* module particle_file use path_info , only : rootpath implicit none private public check_existence , open_particle_file , close_particle_file public check_particle_in_range , fh , ratio_interval , get_ratio_interval , & check_both_particle_fields_exist ! The ratio of the particle and field output intervals integer :: ratio_interval integer :: fh contains !--------------------------------------------------------------------------- ! Check the existence of the dataset. This is for the case that there is ! time gaps in the output files. ! Inputs: !   tindex: the time index, indicating the time step numbers in PIC simulation. !   species: 'e' for electron. 'h' for others. !--------------------------------------------------------------------------- subroutine check_existence ( tindex , species , existFlag ) implicit none character ( len = 1 ), intent ( in ) :: species integer , intent ( in ) :: tindex logical , intent ( out ) :: existFlag character ( len = 20 ) :: ctindex character ( len = 150 ) :: dataset , fname write ( ctindex , \"(I0)\" ) tindex dataset = trim ( adjustl ( rootpath )) // \"particle/T.\" // trim ( ctindex ) dataset = trim ( adjustl ( dataset )) // \"/\" // species // \"particle.\" fname = trim ( dataset ) // trim ( ctindex ) // \".0\" inquire ( file = fname , exist = existFlag ) if ( .not. existFlag ) then print * , fname , \" doesn't exist.\" print * , \"There is probably a gap in the output.\" endif end subroutine check_existence !--------------------------------------------------------------------------- ! Open a particle file and read its headers. ! Input: !   tindex: the time index, indicating the time step numbers in PIC simulation. !   species: 'e' for electron. 'h' for others. !   cid: the MPI ID for the PIC simulation. !--------------------------------------------------------------------------- subroutine open_particle_file ( tindex , species , cid ) use file_header , only : read_boilerplate , read_particle_header implicit none character ( len = 1 ), intent ( in ) :: species integer , intent ( in ) :: tindex character ( * ), intent ( in ) :: cid character ( len = 50 ) :: ctindex character ( len = 150 ) :: dataset , fname fh = 10 write ( ctindex , \"(I0)\" ) tindex dataset = trim ( adjustl ( rootpath )) // \"particle/T.\" // trim ( ctindex ) dataset = trim ( adjustl ( dataset )) // \"/\" // species // \"particle.\" fname = trim ( dataset ) // trim ( ctindex ) // \".\" // trim ( cid ) open ( unit = fh , file = trim ( fname ), status = 'unknown' , & form = 'unformatted' , access = 'stream' , action = 'read' ) write ( * , '(A,A)' ) \"Reading --> \" , trim ( fname ) call read_boilerplate ( fh ) call read_particle_header ( fh ) end subroutine open_particle_file !--------------------------------------------------------------------------- ! Check if the particles in this particle file are in the required spatial ! range. The method is to check the bottom-left and top-right corners. !--------------------------------------------------------------------------- function check_particle_in_range ( spatial_range ) result ( isrange ) use constants , only : fp , dp use picinfo , only : domain use file_header , only : v0 implicit none real ( fp ), dimension ( 2 , 3 ), intent ( in ) :: spatial_range real ( fp ) :: x0 , y0 , z0 , x1 , y1 , z1 real ( fp ) :: dx , dy , dz logical :: isrange , isrange1 , isrange2 ! Corners of this MPI process's domain x0 = v0 % x0 y0 = v0 % y0 z0 = v0 % z0 x1 = v0 % x0 + domain % pic_nx * domain % dx y1 = v0 % y0 + domain % pic_ny * domain % dy z1 = v0 % z0 + domain % pic_nz * domain % dz ! The grid sizes of each MPI process dx = domain % dx * domain % pic_nx dy = domain % dy * domain % pic_ny dz = domain % dz * domain % pic_nz ! Only if the corners are within the box. ! Shift one MPI grid to cover boundary. isrange1 = x1 >= ( spatial_range ( 1 , 1 ) - dx ) & .and. x1 <= ( spatial_range ( 2 , 1 ) + dx ) & .and. y1 >= ( spatial_range ( 1 , 2 ) - dy ) & .and. y1 <= ( spatial_range ( 2 , 2 ) + dy ) & .and. z1 >= ( spatial_range ( 1 , 3 ) - dz ) & .and. z1 <= ( spatial_range ( 2 , 3 ) + dz ) isrange2 = x0 >= ( spatial_range ( 1 , 1 ) - dx ) & .and. x0 <= ( spatial_range ( 2 , 1 ) + dx ) & .and. y0 >= ( spatial_range ( 1 , 2 ) - dy ) & .and. y0 <= ( spatial_range ( 2 , 2 ) + dy ) & .and. z0 >= ( spatial_range ( 1 , 3 ) - dz ) & .and. z0 <= ( spatial_range ( 2 , 3 ) + dz ) isrange = isrange1 .or. isrange2 end function check_particle_in_range !--------------------------------------------------------------------------- ! Close the particle file. !--------------------------------------------------------------------------- subroutine close_particle_file implicit none close ( fh ) end subroutine close_particle_file !--------------------------------------------------------------------------- ! To get the ratio of particle output interval and the fields_interval. ! These two are different for these two. And the ratio is given in sigma.cxx !--------------------------------------------------------------------------- subroutine get_ratio_interval implicit none character ( len = 150 ) :: buff character ( len = 50 ) :: buff1 , format1 integer :: len1 , len2 , len3 ratio_interval = 0 open ( unit = 40 , file = trim ( adjustl ( rootpath )) // 'sigma.cxx' , status = 'old' ) read ( 40 , '(A)' ) buff do while ( index ( buff , 'int Hhydro_interval = ' ) == 0 ) read ( 40 , '(A)' ) buff enddo read ( 40 , '(A)' ) buff len1 = len ( trim ( buff )) ! \"int eparticle_interval = \" has 25 characters len2 = index ( buff , 'int' ) + 24 ! The last 10 characters are \"*interval;\" len3 = len1 - len2 - 10 write ( format1 , \"(A,I2.2,A,I1.1,A,I1.1,A)\" ) & \"(A\" , len2 , \",I\" , len3 , \".\" , len3 , \")'\" read ( buff , trim ( adjustl ( format1 ))) buff1 , ratio_interval close ( 40 ) print * , \"The ratio of particle and field output intervals: \" , & ratio_interval end subroutine get_ratio_interval !--------------------------------------------------------------------------- ! Check if the time frame has both particle and fields data. ! Input: !   ct: current time frame for the fields output. !--------------------------------------------------------------------------- function check_both_particle_fields_exist ( ct ) result ( is_time_valid ) implicit none integer , intent ( in ) :: ct logical :: is_time_valid is_time_valid = .true. if ( mod ( ct , ratio_interval ) /= 0 ) then is_time_valid = .false. endif end function check_both_particle_fields_exist end module particle_file","tags":"","loc":"sourcefile/particle_file.f90.html","title":"particle_file.f90 – Fortran Program"},{"text":"Module of the topology of the MPI processes. Source Code !******************************************************************************* ! Module of the topology of the MPI processes. !******************************************************************************* module mpi_topology implicit none private public ht_type , ht , htg , set_mpi_topology , range_out , distribute_tasks type ht_type integer :: tx , ty , tz ! number of processes in each dimension. integer :: nx , ny , nz ! number of cells in each dimension. integer :: start_x , start_y , start_z ! where to start in x/y/z. integer :: stop_x , stop_y , stop_z ! where to stop in x/y/z. integer :: ix , iy , iz ! IDs of current MPI process. end type ht_type type ( ht_type ) :: ht ! The real topology for the MPI processes. type ( ht_type ) :: htg ! The topology including the ghost cells. ! Data range for saving. The ghost cells are not needed when saving data. ! The MPI process including the boundary has different ghost cells. ! That's why we need some calculation of the staring and ending indices ! for data saving. (l and h indicating lower and higher bound). type data_range integer :: ixl , ixh integer :: iyl , iyh integer :: izl , izh end type data_range type ( data_range ) :: range_out contains !--------------------------------------------------------------------------- ! Set the topology of the MPI processes with ghost cells. !--------------------------------------------------------------------------- subroutine set_topology_with_ghost implicit none htg = ht call adjust_topology ( htg % ix , htg % tx , htg % nx , htg % start_x , htg % stop_x ) call adjust_topology ( htg % iy , htg % ty , htg % ny , htg % start_y , htg % stop_y ) call adjust_topology ( htg % iz , htg % tz , htg % nz , htg % start_z , htg % stop_z ) end subroutine set_topology_with_ghost !--------------------------------------------------------------------------- ! Adjust the topology according to whether the current MPI process is ! dealing with cells at the center or at the boundary of the domain. ! Input: !   mpiId: MPI ID in current dimension. !   nptot: total number of MPI processes in current dimension. ! Input & output: !   nc: number of cells in current dimension for current MPI process.. !   startc: ID for the starting cells in current dimension. !   stopc: ID for the stopping cels in current dimension. !--------------------------------------------------------------------------- subroutine adjust_topology ( mpiId , nptot , nc , startc , stopc ) implicit none integer , intent ( in ) :: mpiId , nptot integer , intent ( inout ) :: nc , startc , stopc if (( mpiId > 0 ) .and. ( mpiId < ( nptot - 1 ))) then ! Center nc = nc + 2 startc = startc - 1 stopc = stopc + 1 else if (( mpiId == 0 ) .and. ( mpiId < ( nptot - 1 ))) then ! Left/bottom boundary. nc = nc + 1 stopc = stopc + 1 else if (( mpiId == ( nptot - 1 )) .and. ( mpiId > 0 )) then ! Right/top boundary. nc = nc + 1 startc = startc - 1 endif end subroutine adjust_topology !--------------------------------------------------------------------------- ! Get the middle two divisors of an integer. e.g. 24=4*6 !--------------------------------------------------------------------------- subroutine get_middle_divisors ( num , d1 , d2 ) implicit none integer , intent ( in ) :: num integer , intent ( out ) :: d1 , d2 integer :: nsq , i nsq = int ( sqrt ( num + 0.0 )) do i = nsq , 1 , - 1 if ( mod ( num , i ) == 0 ) then d1 = i exit endif enddo d2 = num / d1 return end subroutine get_middle_divisors !--------------------------------------------------------------------------- ! Get the number of cells, the starting and stopping cells IDs in one ! dimension for current MPI process. ! Inputs: !   ntasks: total number of tasks for all. !   nworkers: number of the worker we have. !   worker_id: the ID of current worker. [0, nworkers-1] ! Outputs: !   ntasks_current: number of the tasks for current worker. !   task_start, task_end: starting and ending task ID for current worker. !--------------------------------------------------------------------------- subroutine distribute_tasks ( ntasks , nworkers , worker_id , ntask_current , & task_start , task_end ) implicit none integer , intent ( in ) :: ntasks , nworkers , worker_id integer , intent ( out ) :: ntask_current , task_start , task_end integer :: mod_tasks ! The tasks that cannot be averagely distributed. ntask_current = ntasks / nworkers task_start = worker_id * ntask_current mod_tasks = mod ( ntasks , nworkers ) if ( worker_id < mod_tasks ) then ntask_current = ntask_current + 1 task_start = task_start + worker_id else task_start = task_start + mod_tasks endif task_end = task_start + ntask_current - 1 end subroutine distribute_tasks !--------------------------------------------------------------------------- ! Distribute tasks and set the topology of the MPI processes for this analysis. ! Updates: !   ht: the MPI topology without ghost cells. !   htg: the MPI topology with ghost cells. !   range_out the range for data output. !--------------------------------------------------------------------------- subroutine set_mpi_topology use mpi_module use picinfo , only : domain implicit none integer :: d1 , d2 call get_middle_divisors ( numprocs , d1 , d2 ) if ( domain % ny == 1 ) then ! 2D case ht % tx = d1 ht % ty = 1 ht % tz = d2 ht % iz = myid / ht % tx ht % ix = mod ( myid , ht % tx ) ht % iy = 0 else ! 3D case ht % tx = 1 ht % ty = d1 ht % tz = d2 ht % iz = myid / ht % ty ht % iy = mod ( myid , ht % ty ) ht % ix = 0 endif call distribute_tasks ( domain % nx , ht % tx , ht % ix , ht % nx , & ht % start_x , ht % stop_x ) call distribute_tasks ( domain % ny , ht % ty , ht % iy , ht % ny , & ht % start_y , ht % stop_y ) call distribute_tasks ( domain % nz , ht % tz , ht % iz , ht % nz , & ht % start_z , ht % stop_z ) !print*, myid, ht%start_x, ht%start_y, ht%start_z !print*, myid, ht%stop_x, ht%stop_y, ht%stop_z !print*, myid, ht%nx, ht%ny, ht%nz call set_topology_with_ghost ! Set data range for saving. range_out % ixl = ht % start_x - htg % start_x + 1 range_out % iyl = ht % start_y - htg % start_y + 1 range_out % izl = ht % start_z - htg % start_z + 1 range_out % ixh = range_out % ixl + ht % nx - 1 range_out % iyh = range_out % iyl + ht % ny - 1 range_out % izh = range_out % izl + ht % nz - 1 end subroutine set_mpi_topology end module mpi_topology","tags":"","loc":"sourcefile/mpi_setup.f90.html","title":"mpi_setup.f90 – Fortran Program"},{"text":"Module dealing with compressional heating. Source Code !******************************************************************************* ! Module dealing with compressional heating. !******************************************************************************* module compression_shear use constants , only : fp use mpi_topology , only : htg implicit none private public pdiv_v , pshear , vdot_div_ptensor , div_v , bbsigma public init_compression_shear , free_compression_shear , & calc_compression_shear , save_compression_shear , & save_tot_compression_shear , init_div_vdot_ptensor , & free_div_vdot_ptensor , calc_div_vdot_ptensor , & save_div_vdot_ptensor , save_tot_div_vdot_ptensor , & init_div_v , free_div_v , calc_div_v real ( fp ), allocatable , dimension (:, :, :) :: pdiv_v , pshear real ( fp ), allocatable , dimension (:, :, :) :: vdot_div_ptensor real ( fp ), allocatable , dimension (:, :, :) :: div_v , bbsigma real ( fp ), allocatable , dimension (:, :, :) :: vdot_ptensor_x , & vdot_ptensor_y , vdot_ptensor_z , div_vdot_ptensor contains !--------------------------------------------------------------------------- ! Initialize the data arrays. !--------------------------------------------------------------------------- subroutine init_compression_shear implicit none call init_compression call init_shear call init_vdot_div_ptensor call init_div_vdot_ptensor end subroutine init_compression_shear !--------------------------------------------------------------------------- ! Initialize div_v. !--------------------------------------------------------------------------- subroutine init_div_v implicit none allocate ( div_v ( htg % nx , htg % ny , htg % nz )) div_v = 0.0 end subroutine init_div_v !--------------------------------------------------------------------------- ! Initialize div_v, pdiv_v. !--------------------------------------------------------------------------- subroutine init_compression implicit none allocate ( div_v ( htg % nx , htg % ny , htg % nz )) allocate ( pdiv_v ( htg % nx , htg % ny , htg % nz )) div_v = 0.0 pdiv_v = 0.0 end subroutine init_compression !--------------------------------------------------------------------------- ! Initialize pshear, bbsigma. !--------------------------------------------------------------------------- subroutine init_shear implicit none allocate ( pshear ( htg % nx , htg % ny , htg % nz )) allocate ( bbsigma ( htg % nx , htg % ny , htg % nz )) pshear = 0.0 bbsigma = 0.0 end subroutine init_shear !--------------------------------------------------------------------------- ! Initialize vdot_div_ptensor !--------------------------------------------------------------------------- subroutine init_vdot_div_ptensor implicit none allocate ( vdot_div_ptensor ( htg % nx , htg % ny , htg % nz )) vdot_div_ptensor = 0.0 end subroutine init_vdot_div_ptensor !--------------------------------------------------------------------------- ! Initialize div_vdot_ptensor and the 3 components of vdot_ptensor. !--------------------------------------------------------------------------- subroutine init_div_vdot_ptensor implicit none allocate ( div_vdot_ptensor ( htg % nx , htg % ny , htg % nz )) allocate ( vdot_ptensor_x ( htg % nx , htg % ny , htg % nz )) allocate ( vdot_ptensor_y ( htg % nx , htg % ny , htg % nz )) allocate ( vdot_ptensor_z ( htg % nx , htg % ny , htg % nz )) div_vdot_ptensor = 0.0 vdot_ptensor_x = 0.0 vdot_ptensor_y = 0.0 vdot_ptensor_z = 0.0 end subroutine init_div_vdot_ptensor !--------------------------------------------------------------------------- ! Free the data arrays. !--------------------------------------------------------------------------- subroutine free_compression_shear implicit none call free_compression call free_shear call free_vdot_div_ptensor call free_div_vdot_ptensor end subroutine free_compression_shear !--------------------------------------------------------------------------- ! Free div_v. !--------------------------------------------------------------------------- subroutine free_div_v implicit none deallocate ( div_v ) end subroutine free_div_v !--------------------------------------------------------------------------- ! Free div_v, pdiv_v. !--------------------------------------------------------------------------- subroutine free_compression implicit none deallocate ( div_v , pdiv_v ) end subroutine free_compression !--------------------------------------------------------------------------- ! Free pshear, bbsigma. !--------------------------------------------------------------------------- subroutine free_shear implicit none deallocate ( pshear , bbsigma ) end subroutine free_shear !--------------------------------------------------------------------------- ! Free vdot_div_ptensor. !--------------------------------------------------------------------------- subroutine free_vdot_div_ptensor implicit none deallocate ( vdot_div_ptensor ) end subroutine free_vdot_div_ptensor !--------------------------------------------------------------------------- ! Free div_vdot_ptensor and the 3 components of vdot_ptensor. !--------------------------------------------------------------------------- subroutine free_div_vdot_ptensor implicit none deallocate ( div_vdot_ptensor ) deallocate ( vdot_ptensor_x , vdot_ptensor_y , vdot_ptensor_z ) end subroutine free_div_vdot_ptensor !--------------------------------------------------------------------------- ! Calculate the divergence of v. !--------------------------------------------------------------------------- subroutine calc_div_v use pic_fields , only : vx , vy , vz use neighbors_module , only : ixl , iyl , izl , ixh , iyh , izh , idx , idy , idz implicit none integer :: nx , ny , nz , ix , iy , iz nx = htg % nx ny = htg % ny nz = htg % nz do ix = 1 , nx div_v ( ix , :, :) = ( vx ( ixh ( ix ), :, :) - vx ( ixl ( ix ), :, :)) * idx ( ix ) enddo do iy = 1 , ny div_v (:, iy , :) = div_v (:, iy , :) + & ( vy (:, iyh ( iy ), :) - vy (:, iyl ( iy ), :)) * idy ( iy ) enddo do iz = 1 , nz div_v (:, :, iz ) = div_v (:, :, iz ) + & ( vz (:, :, izh ( iz )) - vz (:, :, izl ( iz ))) * idz ( iz ) enddo end subroutine calc_div_v !--------------------------------------------------------------------------- ! Calculate p\\nabla\\cdot\\vec{v}. Here, p is the scalar pressure. !--------------------------------------------------------------------------- subroutine calc_pdiv_v use pressure_tensor , only : pscalar implicit none pdiv_v = - pscalar * div_v end subroutine calc_pdiv_v !--------------------------------------------------------------------------- ! Calculate the compression related variables. !--------------------------------------------------------------------------- subroutine calc_compression implicit none call calc_div_v call calc_pdiv_v end subroutine calc_compression !--------------------------------------------------------------------------- ! Calculate bbsigma = b_ib_j\\sigma_{ij}. !--------------------------------------------------------------------------- subroutine calc_bbsigma use pic_fields , only : bx , by , bz , vx , vy , vz , absB use neighbors_module , only : ixl , iyl , izl , ixh , iyh , izh , idx , idy , idz implicit none real ( fp ) :: sigma_xx , sigma_xy , sigma_xz , sigma_yy , sigma_yz , sigma_zz real ( fp ) :: bxc , byc , bzc integer :: nx , ny , nz , ix , iy , iz nx = htg % nx ny = htg % ny nz = htg % nz do iz = 1 , nz do iy = 1 , ny do ix = 1 , nx sigma_xx = ( vx ( ixh ( ix ), iy , iz ) - vx ( ixl ( ix ), iy , iz )) * & idx ( ix ) - div_v ( ix , iy , iz ) / 3.0 sigma_yy = ( vy ( ix , iyh ( iy ), iz ) - vy ( ix , iyl ( iy ), iz )) * & idy ( iy ) - div_v ( ix , iy , iz ) / 3.0 sigma_zz = ( vz ( ix , iy , izh ( iz )) - vz ( ix , iy , izl ( iz ))) * & idz ( iz ) - div_v ( ix , iy , iz ) / 3.0 sigma_xy = 0.5 * ( vx ( ix , iyh ( iy ), iz ) - & vx ( ix , iyl ( iy ), iz )) * idy ( iy ) + & 0.5 * ( vy ( ixh ( ix ), iy , iz ) - & vy ( ixl ( ix ), iy , iz )) * idx ( ix ) sigma_xz = 0.5 * ( vx ( ix , iy , izh ( iz )) - & vx ( ix","tags":"","loc":"sourcefile/compression_shear.f90.html","title":"compression_shear.f90 – Fortran Program"},{"text":"Module of particle energy spectrum. Source Code !******************************************************************************* ! Module of particle energy spectrum. !******************************************************************************* module particle_energy_spectrum use constants , only : fp , dp use picinfo , only : domain use path_info , only : rootpath implicit none private public f , fsum , flog , flogsum , ebins_lin , ebins_log public init_energy_spectra , free_energy_spectra , calc_energy_spectra , & set_energy_spectra_zero , set_energy_spectra_zero_single , & calc_energy_bins , init_energy_spectra_single , & free_energy_spectra_single , calc_energy_spectrum_single , & sum_spectra_over_mpi , save_particle_spectra , update_energy_spectrum , & init_maximum_energy , set_maximum_energy_zero , update_maximum_energy , & get_maximum_energy_global , save_maximum_energy , free_maximum_energy , & init_emax_pic_mpi , free_emax_pic_mpi , set_emax_pic_mpi_zero real ( dp ), allocatable , dimension (:) :: f , fsum , flog , flogsum real ( dp ), allocatable , dimension (:) :: ebins_lin , ebins_log real ( fp ), allocatable , dimension (:) :: emax_local , emax_global real ( fp ), allocatable , dimension (:, :, :) :: emax_pic_mpi real ( fp ) :: emax_tmp contains !--------------------------------------------------------------------------- ! Initialize particle energy spectrum. !--------------------------------------------------------------------------- subroutine init_energy_spectra use mpi_module use spectrum_config , only : nbins implicit none call init_energy_spectra_single if ( myid == master ) then allocate ( fsum ( nbins )) allocate ( flogsum ( nbins )) endif call set_energy_spectra_zero end subroutine init_energy_spectra !--------------------------------------------------------------------------- ! Initialize particle energy spectrum for current process. ! This can be used for both parallel routines and series routines. !--------------------------------------------------------------------------- subroutine init_energy_spectra_single use spectrum_config , only : nbins implicit none allocate ( f ( nbins )) allocate ( flog ( nbins )) allocate ( ebins_lin ( nbins )) allocate ( ebins_log ( nbins )) ebins_lin = 0.0 ebins_log = 0.0 call set_energy_spectra_zero_single end subroutine init_energy_spectra_single !--------------------------------------------------------------------------- ! Set the flux to zeros at the beginning of each time frame. !--------------------------------------------------------------------------- subroutine set_energy_spectra_zero use mpi_module implicit none call set_energy_spectra_zero_single if ( myid == master ) then fsum = 0.0 flogsum = 0.0 endif end subroutine set_energy_spectra_zero !--------------------------------------------------------------------------- ! Set the flux to zeros at the beginning of each time frame. ! This can be used for both parallel routines and series routines. !--------------------------------------------------------------------------- subroutine set_energy_spectra_zero_single implicit none f = 0.0 flog = 0.0 end subroutine set_energy_spectra_zero_single !--------------------------------------------------------------------------- ! Initialize array of maximum energy. !--------------------------------------------------------------------------- subroutine init_maximum_energy ( nt ) use mpi_module implicit none integer , intent ( in ) :: nt allocate ( emax_local ( nt )) if ( myid == master ) then allocate ( emax_global ( nt )) endif call set_maximum_energy_zero end subroutine init_maximum_energy !--------------------------------------------------------------------------- ! Set the maximum energy to zeros. !--------------------------------------------------------------------------- subroutine set_maximum_energy_zero use mpi_module implicit none emax_local = 0.0 if ( myid == master ) then emax_global = 0.0 endif end subroutine set_maximum_energy_zero !--------------------------------------------------------------------------- ! Free the array of the maximum energy. !--------------------------------------------------------------------------- subroutine free_maximum_energy use mpi_module implicit none deallocate ( emax_local ) if ( myid == master ) then deallocate ( emax_global ) endif end subroutine free_maximum_energy !--------------------------------------------------------------------------- ! Free the memory used by the particle energy flux. !--------------------------------------------------------------------------- subroutine free_energy_spectra use mpi_module implicit none call free_energy_spectra_single if ( myid == master ) then deallocate ( fsum , flogsum ) endif end subroutine free_energy_spectra !--------------------------------------------------------------------------- ! Free the memory used by the particle energy flux. ! This can be used for both parallel routines and series routines. !--------------------------------------------------------------------------- subroutine free_energy_spectra_single implicit none deallocate ( f , flog ) deallocate ( ebins_lin , ebins_log ) end subroutine free_energy_spectra_single !--------------------------------------------------------------------------- ! Initialize the maximum energy array for one PIC MPI process !--------------------------------------------------------------------------- subroutine init_emax_pic_mpi use picinfo , only : domain implicit none allocate ( emax_pic_mpi ( domain % pic_nx , domain % pic_ny , domain % pic_nz )) call set_emax_pic_mpi_zero end subroutine init_emax_pic_mpi !--------------------------------------------------------------------------- ! Set the maximum energy array to zeros !--------------------------------------------------------------------------- subroutine set_emax_pic_mpi_zero implicit none emax_pic_mpi = 0.0 end subroutine set_emax_pic_mpi_zero !--------------------------------------------------------------------------- ! Free the maximum energy array for one PIC MPI process !--------------------------------------------------------------------------- subroutine free_emax_pic_mpi use picinfo , only : domain implicit none deallocate ( emax_pic_mpi ) end subroutine free_emax_pic_mpi !--------------------------------------------------------------------------- ! Calculate the energy bins for linear and logarithmic cases. !--------------------------------------------------------------------------- subroutine calc_energy_bins use spectrum_config , only : nbins , dve , dlogve , emin implicit none integer :: i do i = 1 , nbins ebins_lin ( i ) = dve * i ebins_log ( i ) = emin * 10 ** ( dlogve * i ) enddo end subroutine calc_energy_bins !--------------------------------------------------------------------------- ! Get particle energy spectrum from individual particle information. ! Input: !   ct: current time frame. !   species: 'e' for electron. 'h' for others. !--------------------------------------------------------------------------- subroutine calc_energy_spectra ( ct , species ) use mpi_module use constants , only : fp use particle_frames , only : tinterval use particle_file , only : check_existence use commandline_arguments , only : is_emax_cell use particle_maximum_energy , only : write_emax implicit none integer , intent ( in ) :: ct character ( len = 1 ), intent ( in ) :: species integer :: tindex logical :: is_exist call calc_energy_bins tindex = ct * tinterval call set_energy_spectra_zero call check_existence ( tindex , species , is_exist ) emax_tmp = emax_local ( ct ) if ( is_exist ) then if ( is_emax_cell ) then call calc_energy_spectrum_mpi_con ( tindex , species ) call write_emax ( ct , species ) else call calc_energy_spectrum_mpi ( tindex , species ) endif emax_local ( ct ) = emax_tmp ! emax_tmp has been updated call sum_spectra_over_mpi if ( myid == master ) then call save_particle_spectra ( ct , species ) endif endif end subroutine calc_energy_spectra !--------------------------------------------------------------------------- ! Sum particle energy spectrum over all MPI process. !--------------------------------------------------------------------------- subroutine sum_spectra_over_mpi use mpi_module use spectrum_config , only : nbins implicit none ! Sum over all nodes to get the total energy spectrum call MPI_REDUCE ( f , fsum , nbins , MPI_DOUBLE_PRECISION , & MPI_SUM , 0 , MPI_COMM_WORLD , ierr ) call MPI_REDUCE ( flog , flogsum , nbins , MPI_DOUBLE_PRECISION , & MPI_SUM , 0 , MPI_COMM_WORLD , ierr ) end subroutine sum_spectra_over_mpi !--------------------------------------------------------------------------- ! Update the global array of maximum energy. !--------------------------------------------------------------------------- subroutine get_maximum_energy_global ( nt ) use mpi_module implicit none integer , intent ( in ) :: nt call MPI_REDUCE ( emax_local , emax_global , nt , MPI_FLOAT , MPI_MAX , & master , MPI_COMM_WORLD , ierr ) end subroutine get_maximum_energy_global !--------------------------------------------------------------------------- ! Save particle energy spectrum to file. !--------------------------------------------------------------------------- subroutine save_particle_spectra ( ct , species ) use spectrum_config , only : nbins implicit none integer , intent ( in ) :: ct character ( len = 1 ), intent ( in ) :: species logical :: dir_e character ( len = 100 ) :: fname integer :: i inquire ( file = './spectrum/.' , exist = dir_e ) if ( .not. dir_e ) then call system ( 'mkdir spectrum' ) endif ! print *,\" *** Finished Creating Spectrum ***\" write ( fname , \"(A,A1,A1,I0)\" ) \"spectrum/spectrum-\" , &","tags":"","loc":"sourcefile/particle_spectrum.f90.html","title":"particle_spectrum.f90 – Fortran Program"},{"text":"Statistics for the field data. It includes subroutines to calculate the mean,\n the total, the distribution with logarithmic bins. Source Code !******************************************************************************* ! Statistics for the field data. It includes subroutines to calculate the mean, ! the total, the distribution with logarithmic bins. !******************************************************************************* module statistics implicit none private public get_average_and_total , get_log_distribution contains !--------------------------------------------------------------------------- ! Get the average and total of a field data set across MPI process ! Input: !   fdata: the data array. !   ntot: total number of data points. ! Output: !   avg, tot: the average and total of the field data. !--------------------------------------------------------------------------- subroutine get_average_and_total ( fdata , avg , tot ) use mpi_module use constants , only : fp use picinfo , only : domain use mpi_topology , only : range_out implicit none real ( fp ), dimension (:, :, :), intent ( in ) :: fdata real ( fp ), intent ( out ) :: avg , tot real ( fp ), allocatable , dimension (:) :: tot_array real ( fp ) :: tot_local integer :: ixl , ixh , iyl , iyh , izl , izh ixl = range_out % ixl iyl = range_out % iyl izl = range_out % izl ixh = range_out % ixh iyh = range_out % iyh izh = range_out % izh if ( myid == master ) then allocate ( tot_array ( numprocs )) tot_array = 0.0 endif tot_local = sum ( fdata ( ixl : ixh , iyl : iyh , izl : izh )) call MPI_BARRIER ( MPI_COMM_WORLD , ierror ) call MPI_GATHER ( tot_local , 1 , MPI_REAL , tot_array , 1 , MPI_REAL , & master , MPI_COMM_WORLD , ierror ) if ( myid == master ) then tot = sum ( tot_array ) * domain % dx * domain % dy * domain % dz avg = tot / ( domain % nx * domain % ny * domain % nz ) deallocate ( tot_array ) else avg = 0.1 ; tot = 1.0 ! Some random number except rank master. endif end subroutine get_average_and_total !--------------------------------------------------------------------------- ! Get the distribution of a data set using a logarithm scale bins. ! Input: !   dataSet: the data set. !   minValue: the minimum value in the energy bins. !   maxValue: the maximum value in the energy bins. !   nbins: number of energy bins. ! Return: !   distData: the distribution of the data set. !--------------------------------------------------------------------------- subroutine get_log_distribution ( dataSet , minValue , maxValue , nbins , distData ) use constants , only : fp use mpi_topology , only : ht , htg implicit none real ( fp ), intent ( in ) :: minValue , maxValue integer , intent ( in ) :: nbins real ( fp ), dimension (:, :, :), intent ( in ) :: dataSet real ( fp ), intent ( out ), dimension ( nbins + 2 ) :: distData integer :: ix , iy , iz , ibin integer :: ix_start , iy_start , iz_start , ix_stop , iy_stop , iz_stop real ( fp ) :: deltaLog , minLog , maxLog minLog = log10 ( minValue ) maxLog = log10 ( maxValue ) deltaLog = ( maxLog - minLog ) / nbins distData = 0.0 ix_start = ht % start_x - htg % start_x + 1 iy_start = ht % start_y - htg % start_y + 1 iz_start = ht % start_z - htg % start_z + 1 ix_stop = ix_start + ht % nx - 1 iy_stop = iy_start + ht % ny - 1 iz_stop = iz_start + ht % nz - 1 do iz = iz_start , iz_stop do iy = iy_start , iy_stop do ix = ix_start , ix_stop ibin = ( log10 ( dataSet ( ix , iy , iz )) - minLog ) / deltaLog + 1 if ( ibin < 1 ) ibin = 1 if ( ibin > nbins + 1 ) ibin = nbins + 2 distData ( ibin ) = distData ( ibin ) + 1 enddo enddo enddo end subroutine get_log_distribution end module statistics","tags":"","loc":"sourcefile/statistics.f90.html","title":"statistics.f90 – Fortran Program"},{"text":"Module of jdote for different energy band. Source Code !******************************************************************************* ! Module of jdote for different energy band. !******************************************************************************* module jdote_energy_band use constants , only : dp , fp implicit none private public read_config_jdote_eband integer :: nbands real ( fp ) :: emin , emax , dloge , emin_log , emax_log real ( fp ), allocatable , dimension (:, :, :, :) :: jdote_eband_para real ( fp ), allocatable , dimension (:, :, :, :) :: jdote_eband_perp integer , dimension ( 2 , 3 ) :: mpi_ranges contains !--------------------------------------------------------------------------- ! Read the configuration file for jdote for different energy band. ! And calculate the logarithmic energy interval. !--------------------------------------------------------------------------- subroutine read_config_jdote_eband use read_config , only : get_variable implicit none integer :: fh real ( fp ) :: temp character ( len = 100 ) :: fname fname = 'config_files/jdote_eband_config.dat' fh = 10 open ( unit = fh , file = fname , status = 'old' ) temp = get_variable ( fh , 'nbands' , '=' ) ! Number of energy bands nbands = int ( temp ) emax = get_variable ( fh , 'emax' , '=' ) ! Maximum energy emin = get_variable ( fh , 'emin' , '=' ) ! Minimum energy close ( fh ) ! Calculate the logarithmic energy interval emin_log = log10 ( emin ) emax_log = log10 ( emax ) dloge = ( emax_log - emin_log ) / nbands end subroutine read_config_jdote_eband !--------------------------------------------------------------------------- ! Initialize the jdote_ebands_para and  jdote_ebands_perp !--------------------------------------------------------------------------- subroutine init_jdote_ebands use mpi_topology , only : htg implicit none integer :: nx , ny , nz nx = htg % nx ny = htg % ny nz = htg % nz allocate ( jdote_eband_para ( nx , ny , nz , nbands )) allocate ( jdote_eband_perp ( nx , ny , nz , nbands )) jdote_eband_para = 0.0 jdote_eband_perp = 0.0 end subroutine init_jdote_ebands !--------------------------------------------------------------------------- ! Free the jdote_ebands_para and  jdote_ebands_perp !--------------------------------------------------------------------------- subroutine free_jdote_ebands implicit none deallocate ( jdote_eband_para ) deallocate ( jdote_eband_perp ) end subroutine free_jdote_ebands !--------------------------------------------------------------------------- ! Calculate the range of VPIC MPI processes for current MPI process. !--------------------------------------------------------------------------- subroutine calc_mpi_ranges use picinfo , only : domain use mpi_topology , only : ht implicit none integer :: mx , my , mz mpi_ranges = 0 mx = domain % pic_tx / ht % tx my = domain % pic_ty / ht % ty mz = domain % pic_tz / ht % tz mpi_ranges ( 1 , 1 ) = mx * ht % ix mpi_ranges ( 2 , 1 ) = mx * ( ht % ix + 1 ) - 1 mpi_ranges ( 1 , 2 ) = my * ht % iy mpi_ranges ( 2 , 2 ) = my * ( ht % iy + 1 ) - 1 mpi_ranges ( 1 , 3 ) = mz * ht % iz mpi_ranges ( 2 , 3 ) = mz * ( ht % iz + 1 ) - 1 end subroutine calc_mpi_ranges !--------------------------------------------------------------------------- ! Read particle files and calculate jdote for different energy band. !--------------------------------------------------------------------------- subroutine calc_jdote_eband use picinfo , only : domain implicit none integer :: i , j , k , tx , ty , tz , cid tx = domain % pic_tx ty = domain % pic_ty tz = domain % pic_tz do k = mpi_ranges ( 1 , 3 ), mpi_ranges ( 2 , 3 ) do j = mpi_ranges ( 1 , 2 ), mpi_ranges ( 2 , 2 ) do i = mpi_ranges ( 1 , 1 ), mpi_ranges ( 2 , 1 ) enddo enddo enddo end subroutine calc_jdote_eband end module jdote_energy_band","tags":"","loc":"sourcefile/jdote_energy_band.f90.html","title":"jdote_energy_band.f90 – Fortran Program"},{"text":"Module of the configuration setup for this analysis.\n httx: number of domains in x (converter)\n htty: the same in y\n httz: the same in z\n tindex_start: time slice to start at\n tindex_stop: time slice to stop at. Set to a large number to process all.\n output_format: output format. 2=file per slice, 1=all slices in one file\n append_to_files: set to 1 to append to existing files, anything else to\n                  start at the beginning. Module includes routines to do mapping between 1D index and 3D indices on\n a 3D grid. Source Code !******************************************************************************* !******************************************************************************* ! Module of the configuration setup for this analysis. ! httx: number of domains in x (converter) ! htty: the same in y ! httz: the same in z ! tindex_start: time slice to start at ! tindex_stop: time slice to stop at. Set to a large number to process all. ! output_format: output format. 2=file per slice, 1=all slices in one file ! append_to_files: set to 1 to append to existing files, anything else to !                  start at the beginning. !******************************************************************************* module configuration_translate implicit none private public httx , htty , httz , tindex_start , tindex_stop , output_format , & append_to_files , read_configuration integer :: httx , htty , httz , tindex_start , tindex_stop integer :: output_format , append_to_files contains !--------------------------------------------------------------------------- ! Read the configuration from file and broadcast to all MPI processes. !--------------------------------------------------------------------------- subroutine read_configuration use mpi_module implicit none namelist / datum / httx , htty , httz , tindex_start , tindex_stop , & output_format , append_to_files ! Read the configuration file if ( myid == master ) then open ( unit = 10 , file = 'config_files/conf.dat' , & form = 'formatted' , status = 'old' ) read ( 10 , datum ) close ( 10 ) endif ! Broadcast to all MPI processes. call MPI_BCAST ( httx , 1 , MPI_INTEGER , master , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( htty , 1 , MPI_INTEGER , master , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( httz , 1 , MPI_INTEGER , master , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( tindex_start , 1 , MPI_INTEGER , master , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( tindex_stop , 1 , MPI_INTEGER , master , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( output_format , 1 , MPI_INTEGER , master , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( append_to_files , 1 , MPI_INTEGER , master , MPI_COMM_WORLD , ierr ) if ( myid == master ) then ! Echo this information print * , \"---------------------------------------------------\" print * , \"Configuration to translate data\" write ( * , \"(A,I0,A,I0,A,I0)\" ) \" Topology tx, ty, tz = \" , & httx , ', ' , htty , ', ' , httz write ( * , \"(A,I0,A,I0)\" ) \" tindex_start, tindex_stop = \" , & tindex_start , ', ' , tindex_stop write ( * , \"(A,I0)\" ) \" output_format: \" , output_format write ( * , \"(A,I0)\" ) \" append_to_files: \" , append_to_files print * , \"---------------------------------------------------\" endif end subroutine read_configuration end module configuration_translate !******************************************************************************* ! Module includes routines to do mapping between 1D index and 3D indices on ! a 3D grid. !******************************************************************************* module rank_index_mapping implicit none private public rank_to_index , index_to_rank contains !--------------------------------------------------------------------------- ! Map a 1D index to a 3D grid. ! Inputs: !   rank: the 1D index. !   nx, ny, nz: the sizes of the 3D grid. ! Outputs: !   ix, iy, iz: the 3D indices. !--------------------------------------------------------------------------- subroutine rank_to_index ( rank , nx , ny , nz , ix , iy , iz ) implicit none integer , intent ( in ) :: rank , nx , ny , nz integer , intent ( out ) :: ix , iy , iz iz = rank / ( nx * ny ) iy = ( rank - iz * nx * ny ) / nx ix = rank - iz * nx * ny - iy * nx end subroutine rank_to_index !--------------------------------------------------------------------------- ! Map 3D indices one a 3D grid to a 1D index. !--------------------------------------------------------------------------- subroutine index_to_rank ( ix , iy , iz , nx , ny , nz , rank ) implicit none integer , intent ( in ) :: ix , iy , iz , nx , ny , nz integer , intent ( out ) :: rank integer :: iix , iiy , iiz iix = mod ( ix , nx ) iiy = mod ( iy , ny ) iiz = mod ( iz , nz ) rank = iix + nx * ( iiy + ny * iiz ) + 1 end subroutine index_to_rank end module rank_index_mapping","tags":"","loc":"sourcefile/translate_config.f90.html","title":"translate_config.f90 – Fortran Program"},{"text":"Module for velocity distribution. The velocity here is actually 4-velocity\n multiplied by the sqrt(mass of particle). So that it can be used for both\n electrons and ions without changing vmin, vmax. Source Code !******************************************************************************* ! Module for velocity distribution. The velocity here is actually 4-velocity ! multiplied by the sqrt(mass of particle). So that it can be used for both ! electrons and ions without changing vmin, vmax. !******************************************************************************* module velocity_distribution use constants , only : fp , dp use path_info , only : rootpath implicit none private public fvel_2d , fvel_xy , fvel_xz , fvel_yz , fvel_para , fvel_perp , & fvel_2d_sum , fvel_xy_sum , fvel_xz_sum , fvel_yz_sum , & fvel_para_sum , fvel_perp_sum , vbins_short , vbins_long public init_velocity_bins , free_velocity_bins , init_vdist_2d , & set_vdist_2d_zero , free_vdist_2d , init_vdist_2d_single , & set_vdist_2d_zero_single , free_vdist_2d_single , init_vdist_1d , & set_vdist_1d_zero , free_vdist_1d , init_vdist_1d_single , & set_vdist_1d_zero_single , free_vdist_1d_single , & calc_vdist_2d , calc_vdist_1d , calc_vdist_2d_single , & calc_vdist_1d_single , sum_vdist_1d_over_mpi , & sum_vdist_2d_over_mpi , save_vdist_1d , save_vdist_2d , & update_vdist_1d , update_vdist_2d real ( dp ), allocatable , dimension (:, :) :: fvel_2d , fvel_xy , fvel_xz , fvel_yz real ( dp ), allocatable , dimension (:) :: fvel_para , fvel_perp real ( dp ), allocatable , dimension (:, :) :: fvel_2d_sum , fvel_xy_sum real ( dp ), allocatable , dimension (:, :) :: fvel_xz_sum , fvel_yz_sum real ( dp ), allocatable , dimension (:) :: fvel_para_sum , fvel_perp_sum real ( dp ), allocatable , dimension (:) :: vbins_short , vbins_long ! The index of the left corner of the bin that contains the particle. integer :: ibin_para , ibin_perp , ibinx , ibiny , ibinz ! The offset from the left corner. [0, 1) real ( fp ) :: offset_para , offset_perp , offsetx , offsety , offsetz contains !--------------------------------------------------------------------------- ! Initialize short (nbins_vdist) and long (2*nbins_vdist) velocity bins. !--------------------------------------------------------------------------- subroutine init_velocity_bins use spectrum_config , only : nbins_vdist , vmax , dv implicit none integer :: i allocate ( vbins_short ( nbins_vdist )) allocate ( vbins_long ( nbins_vdist * 2 )) do i = 1 , nbins_vdist vbins_short ( i ) = ( i - 0.5 ) * dv enddo do i = 1 , nbins_vdist * 2 vbins_long ( i ) = ( i - 0.5 ) * dv - vmax enddo end subroutine init_velocity_bins !--------------------------------------------------------------------------- ! Free velocity bins. !--------------------------------------------------------------------------- subroutine free_velocity_bins implicit none deallocate ( vbins_short , vbins_long ) end subroutine free_velocity_bins !--------------------------------------------------------------------------- ! Initialize 2D velocity distribution for a parallel analysis using MPI. !--------------------------------------------------------------------------- subroutine init_vdist_2d use mpi_module use spectrum_config , only : nbins_vdist implicit none call init_vdist_2d_single if ( myid == master ) then allocate ( fvel_2d_sum ( nbins_vdist * 2 , nbins_vdist )) allocate ( fvel_xy_sum ( nbins_vdist * 2 , nbins_vdist * 2 )) allocate ( fvel_xz_sum ( nbins_vdist * 2 , nbins_vdist * 2 )) allocate ( fvel_yz_sum ( nbins_vdist * 2 , nbins_vdist * 2 )) endif call set_vdist_2d_zero end subroutine init_vdist_2d !--------------------------------------------------------------------------- ! Initialize 2D velocity distributions for a single process. !--------------------------------------------------------------------------- subroutine init_vdist_2d_single use spectrum_config , only : nbins_vdist implicit none allocate ( fvel_2d ( nbins_vdist * 2 , nbins_vdist )) allocate ( fvel_xy ( nbins_vdist * 2 , nbins_vdist * 2 )) allocate ( fvel_xz ( nbins_vdist * 2 , nbins_vdist * 2 )) allocate ( fvel_yz ( nbins_vdist * 2 , nbins_vdist * 2 )) call set_vdist_2d_zero_single end subroutine init_vdist_2d_single !--------------------------------------------------------------------------- ! Set 2D velocity distributions to zero for a single process. !--------------------------------------------------------------------------- subroutine set_vdist_2d_zero_single implicit none fvel_2d = 0.0 fvel_xy = 0.0 fvel_xz = 0.0 fvel_yz = 0.0 end subroutine set_vdist_2d_zero_single !--------------------------------------------------------------------------- ! Set the 2D velocity distributions to zeros for analysis using MPI. !--------------------------------------------------------------------------- subroutine set_vdist_2d_zero use mpi_module implicit none call set_vdist_2d_zero_single if ( myid == master ) then fvel_2d_sum = 0.0 fvel_xy_sum = 0.0 fvel_xz_sum = 0.0 fvel_yz_sum = 0.0 endif end subroutine set_vdist_2d_zero !--------------------------------------------------------------------------- ! Free 2D velocity distribution for a parallel analysis using MPI. !--------------------------------------------------------------------------- subroutine free_vdist_2d use mpi_module implicit none call free_vdist_2d_single if ( myid == master ) then deallocate ( fvel_2d_sum ) deallocate ( fvel_xy_sum , fvel_xz_sum , fvel_yz_sum ) endif end subroutine free_vdist_2d !--------------------------------------------------------------------------- ! Free 2D velocity distribution a single process. !--------------------------------------------------------------------------- subroutine free_vdist_2d_single implicit none deallocate ( fvel_2d ) deallocate ( fvel_xy , fvel_xz , fvel_yz ) end subroutine free_vdist_2d_single !--------------------------------------------------------------------------- ! Initialize 1D velocity distributions (parallel and perpendicular to the ! local magnetic field. This is for parallel analysis using MPI !--------------------------------------------------------------------------- subroutine init_vdist_1d use mpi_module use spectrum_config , only : nbins_vdist implicit none call init_vdist_1d_single if ( myid == master ) then allocate ( fvel_para_sum ( nbins_vdist * 2 )) allocate ( fvel_perp_sum ( nbins_vdist )) endif call set_vdist_1d_zero end subroutine init_vdist_1d !--------------------------------------------------------------------------- ! Initialize 1D velocity distributions (parallel and perpendicular to the ! local magnetic field. This is for a single process. !--------------------------------------------------------------------------- subroutine init_vdist_1d_single use spectrum_config , only : nbins_vdist implicit none allocate ( fvel_para ( nbins_vdist * 2 )) allocate ( fvel_perp ( nbins_vdist )) call set_vdist_1d_zero_single end subroutine init_vdist_1d_single !--------------------------------------------------------------------------- ! Set 1D velocity distributions to zero. !--------------------------------------------------------------------------- subroutine set_vdist_1d_zero_single implicit none fvel_para = 0.0 fvel_perp = 0.0 end subroutine set_vdist_1d_zero_single !--------------------------------------------------------------------------- ! Set 1D velocity distributions to zero for parallel analysis using MPI !--------------------------------------------------------------------------- subroutine set_vdist_1d_zero use mpi_module implicit none call set_vdist_1d_zero_single if ( myid == master ) then fvel_para_sum = 0.0 fvel_perp_sum = 0.0 endif end subroutine set_vdist_1d_zero !--------------------------------------------------------------------------- ! Free 1D velocity distributions for a single process. !--------------------------------------------------------------------------- subroutine free_vdist_1d_single implicit none deallocate ( fvel_para , fvel_perp ) end subroutine free_vdist_1d_single !--------------------------------------------------------------------------- ! Free 1D velocity distributions for parallel analysis using MPI. !--------------------------------------------------------------------------- subroutine free_vdist_1d use mpi_module implicit none call free_vdist_1d_single if ( myid == master ) then deallocate ( fvel_para_sum , fvel_perp_sum ) endif end subroutine free_vdist_1d !--------------------------------------------------------------------------- ! Calculate particle 2d velocity distribution from individual particle ! information. ! Input: !   ct: current time frame. !   species: 'e' for electron. 'h' for others. !--------------------------------------------------------------------------- subroutine calc_vdist_2d ( ct , species ) use mpi_module use constants , only : fp use particle_frames , only : tinterval use particle_file , only : check_existence implicit none integer , intent ( in ) :: ct character ( len = 1 ), intent ( in ) :: species integer :: tindex logical :: is_exist tindex = ct * tinterval call check_existence ( tindex , species , is_exist ) if ( is_exist ) then call calc_vdist_2d_mpi ( tindex , species ) call sum_vdist_2d_over_mpi call save_vdist_2d ( ct , species ) endif end subroutine calc_vdist_2d !--------------------------------------------------------------------------- ! Sum the 2D velocity distributions over all of the MPI processes. !--------------------------------------------------------------------------- subroutine sum_vdist_2d_over_mpi use mpi_module use spectrum_config , only : nbins_vdist implicit none ! Sum over all MPI processes to get the total velocity distributions call MPI_REDUCE ( fvel_2d , fvel_2d_sum , 2 * nbins_vdist ** 2 , & MPI_DOUBLE_PRECISION , MPI_SUM , 0 , MPI_COMM_WORLD , ierr ) call MPI_REDUCE ( fvel_xy , fvel_xy_sum , 4 * nbins_vdist ** 2 , & MPI_DOUBLE_PRECISION , MPI_SUM , 0 , MPI_COMM_WORLD , ierr ) call MPI_REDUCE ( fvel_xz , fvel_xz_sum , 4 * nbins_vdist ** 2","tags":"","loc":"sourcefile/vdist.f90.html","title":"vdist.f90 – Fortran Program"},{"text":"Module of time information. It includes subroutines to determine the number\n iterations between output files. Source Code !******************************************************************************* ! Module of time information. It includes subroutines to determine the number ! iterations between output files. !******************************************************************************* module time_info use mpi_module use path_info , only : rootpath implicit none private public nout , output_record , get_nout , adjust_tindex_start , set_output_record integer :: nout , tindex , tindex_first , tindex_next , output_record contains !--------------------------------------------------------------------------- ! Get PIC the number of iterations between output files. !--------------------------------------------------------------------------- subroutine get_nout implicit none logical :: dfile character ( len = 150 ) :: fname if ( myid == master ) then dfile = .false. tindex = 1 do while ( .not. dfile ) tindex = tindex + 1 write ( fname , \"(A, I0, A, I0, A)\" ) & trim ( adjustl ( rootpath )) // \"fields/T.\" , tindex , & \"/fields.\" , tindex , \".0\" if ( tindex .ne. 1 ) inquire ( file = trim ( fname ), exist = dfile ) enddo tindex_first = tindex dfile = .false. do while ( .not. dfile ) tindex = tindex + 1 write ( fname , \"(A, I0, A, I0, A)\" ) & trim ( adjustl ( rootpath )) // \"fields/T.\" , tindex , & \"/fields.\" , tindex , \".0\" if ( tindex .ne. 1 ) inquire ( file = trim ( fname ), exist = dfile ) enddo tindex_next = tindex nout = tindex_next - tindex_first ! Total size of domain print * , \"---------------------------------------------------\" print * , \"Iterations between output = \" , nout print * , \"---------------------------------------------------\" endif call MPI_BCAST ( nout , 1 , MPI_INTEGER , master , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( tindex_first , 1 , MPI_INTEGER , master , MPI_COMM_WORLD , ierr ) end subroutine get_nout !--------------------------------------------------------------------------- ! Adjust tindex_start in case it is smaller than the minimal time step ! output that is available. This occurs when some of the earlier outputs ! are deleted. !--------------------------------------------------------------------------- subroutine adjust_tindex_start use mpi_module use configuration_translate , only : tindex_start implicit none character ( len = 150 ) :: fname logical :: dfile if ( tindex_start < tindex_first ) then dfile = .false. write ( fname , \"(A,I0,A,I0,A)\" ) & trim ( adjustl ( rootpath )) // \"fields/T.0/fields.0.0\" ! 1st frame inquire ( file = trim ( fname ), exist = dfile ) if ( .not. dfile ) then tindex_start = tindex_first if ( myid == master ) then print * , \"---------------------------------------------------\" write ( * , '(A, I0)' ) ' tindex_start is updated to: ' , tindex_start print * , \"---------------------------------------------------\" endif endif endif end subroutine adjust_tindex_start !--------------------------------------------------------------------------- ! Set output_record, which determines the offset from the file beginning ! when writing to a file. It depends on whether to append to previous ! output. It needs to determine the last record written, so we know which ! time slice to process next. !--------------------------------------------------------------------------- subroutine set_output_record use configuration_translate , only : tindex_start , append_to_files implicit none if ( append_to_files == 1 ) then output_record = ( tindex_start / nout ) + 1 else output_record = 1 endif end subroutine set_output_record end module time_info","tags":"","loc":"sourcefile/get_info_translate.f90.html","title":"get_info_translate.f90 – Fortran Program"},{"text":"This module includes the electric field data, methods to read, free the\n electric field and get the electric field at one point. Source Code !******************************************************************************* ! This module includes the electric field data, methods to read, free the ! electric field and get the electric field at one point. !******************************************************************************* module electric_field use constants , only : fp implicit none private public init_electric_fields , read_electric_fields , & free_electric_fields , get_electric_field_at_point public ex0 , ey0 , ez0 real ( fp ), allocatable , dimension (:,:) :: Ex , Ey , Ez integer :: nx , nz , ix1 , ix2 , iz1 , iz2 real ( fp ) :: shiftx , shiftz ! The offset of one point from the corner. real ( fp ) :: ex0 , ey0 , ez0 ! electric field at one point. contains !--------------------------------------------------------------------------- ! Initialize the electric field. !--------------------------------------------------------------------------- subroutine init_electric_fields use picinfo , only : domain implicit none nx = domain % nx nz = domain % nz allocate ( Ex ( nx , nz )) allocate ( Ey ( nx , nz )) allocate ( Ez ( nx , nz )) Ex = 0.0 Ez = 0.0 Ez = 0.0 end subroutine init_electric_fields !--------------------------------------------------------------------------- ! Free the electric field. !--------------------------------------------------------------------------- subroutine free_electric_fields implicit none deallocate ( ex , ey , ez ) end subroutine free_electric_fields !--------------------------------------------------------------------------- ! Read the electric field using the master MPI process and broadcast to ! other MPI processes. !--------------------------------------------------------------------------- subroutine read_electric_fields ( ct ) use mpi_module use constants , only : fp , dp use path_info , only : rootpath use parameters , only : tp1 implicit none integer , intent ( in ) :: ct character ( len = 150 ) :: filename integer ( dp ) :: pos1 integer :: fh fh = 101 if ( myid == master ) then ! Ex filename = trim ( adjustl ( rootpath )) // 'data/ex.gda' open ( unit = fh , file = trim ( filename ), access = 'stream' ,& status = 'unknown' , form = 'unformatted' , action = 'read' ) pos1 = nx * nz * sizeof ( fp ) * ( ct - tp1 ) + 1 read ( fh , pos = pos1 ) Ex close ( fh ) ! Ey filename = trim ( adjustl ( rootpath )) // 'data/ey.gda' open ( unit = fh , file = trim ( filename ), access = 'stream' ,& status = 'unknown' , form = 'unformatted' , action = 'read' ) read ( fh , pos = pos1 ) Ey close ( fh ) ! Ez filename = trim ( adjustl ( rootpath )) // 'data/ez.gda' open ( unit = fh , file = trim ( filename ), access = 'stream' ,& status = 'unknown' , form = 'unformatted' , action = 'read' ) read ( fh , pos = pos1 ) Ez close ( fh ) endif call MPI_BCAST ( Ex , nx * nz , MPI_REAL , master , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( Ey , nx * nz , MPI_REAL , master , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( Ez , nx * nz , MPI_REAL , master , MPI_COMM_WORLD , ierr ) end subroutine read_electric_fields !--------------------------------------------------------------------------- ! Calculate the 2D grid indices for one point. ! Input: !   x, z: the coordinates of the point. !   dx, dz: the grid sizes. ! Updates: !   ix1, iz1: grid indices for the bottom left corner. !   ix2, iz2: grid indices for the top right corner. !   shiftx, shifty: the offsets from the bottom left corner. ! Note: !   Make sure that x, z, dx, dz are in the same unit (di or de). !--------------------------------------------------------------------------- subroutine calc_grid_indices ( x , z , dx , dz ) implicit none real ( fp ), intent ( in ) :: x , z , dx , dz ix1 = floor ( x / dx ) iz1 = floor ( z / dz ) ix2 = ix1 + 1 iz2 = iz1 + 1 shiftx = x / dx - ix1 shiftz = z / dz - iz1 end subroutine calc_grid_indices !--------------------------------------------------------------------------- ! Get electric field at one point. ! Inputs: !   x, z: the coordinates of the point. !   dx, dz: the grid sizes. !--------------------------------------------------------------------------- subroutine get_electric_field_at_point ( x , z , dx , dz ) implicit none real ( fp ), intent ( in ) :: x , z , dx , dz real ( fp ) :: v1 , v2 , v3 , v4 call calc_grid_indices ( x , z , dx , dz ) if ( ix1 >= 1 .and. ix1 <= nx .and. ix2 >= 0 .and. ix2 <= nx .and. & iz1 >= 1 .and. iz1 <= nz .and. iz2 >= 1 .and. iz2 <= nz ) then v1 = ( 1.0 - shiftx ) * ( 1.0 - shiftz ) v2 = shiftx * ( 1.0 - shiftz ) v3 = shiftx * shiftz v4 = ( 1.0 - shiftx ) * shiftz ex0 = Ex ( ix1 , iz1 ) * v1 + Ex ( ix1 , iz2 ) * v2 + Ex ( ix2 , iz2 ) * v3 + Ex ( ix2 , iz1 ) * v4 ey0 = Ey ( ix1 , iz1 ) * v1 + Ey ( ix1 , iz2 ) * v2 + Ey ( ix2 , iz2 ) * v3 + Ey ( ix2 , iz1 ) * v4 ez0 = Ez ( ix1 , iz1 ) * v1 + Ez ( ix1 , iz2 ) * v2 + Ez ( ix2 , iz2 ) * v3 + Ez ( ix2 , iz1 ) * v4 endif end subroutine get_electric_field_at_point end module electric_field","tags":"","loc":"sourcefile/electric_field.f90.html","title":"electric_field.f90 – Fortran Program"},{"text":"Module of the header of a file. Source Code !******************************************************************************* ! Module of the header of a file. !******************************************************************************* module file_header implicit none private public v0 , pheader , fheader , read_boilerplate , read_fields_header , & read_particle_header integer :: itype , ndim ! Define structure for V0 header type v0header integer ( kind = 4 ) :: version , type , nt , nx , ny , nz real ( kind = 4 ) :: dt , dx , dy , dz real ( kind = 4 ) :: x0 , y0 , z0 real ( kind = 4 ) :: cvac , eps0 , damp integer ( kind = 4 ) :: rank , ndom , spid , spqm end type v0header type header_particle integer :: size , ndim , dim end type header_particle type header_fields integer :: itype , ndim integer , dimension ( 3 ) :: nc end type header_fields ! Declare the headers type ( v0header ) :: v0 type ( header_particle ) :: pheader type ( header_fields ) :: fheader contains !--------------------------------------------------------------------------- ! Read boilerplate of a file. !--------------------------------------------------------------------------- subroutine read_boilerplate ( fh ) implicit none integer , intent ( in ) :: fh integer ( kind = 1 ) sizearr ( 5 ) integer ( kind = 2 ) cafevar integer ( kind = 4 ) deadbeefvar real ( kind = 4 ) realone real ( kind = 8 ) doubleone read ( fh ) sizearr read ( fh ) cafevar read ( fh ) deadbeefvar read ( fh ) realone read ( fh ) doubleone !  print *, sizearr,cafevar, deadbeefvar, realone, doubleone return end subroutine read_boilerplate !--------------------------------------------------------------------------- ! Read fields header. !--------------------------------------------------------------------------- subroutine read_fields_header ( fh ) implicit none integer , intent ( in ) :: fh read ( fh ) v0 read ( fh ) fheader end subroutine read_fields_header !--------------------------------------------------------------------------- ! Read particle header. !--------------------------------------------------------------------------- subroutine read_particle_header ( fh ) implicit none integer , intent ( in ) :: fh read ( fh ) v0 read ( fh ) pheader end subroutine read_particle_header end module file_header","tags":"","loc":"sourcefile/file_header.f90.html","title":"file_header.f90 – Fortran Program"},{"text":"Mass and charge for particles used in current analysis. Source Code !******************************************************************************* ! Mass and charge for particles used in current analysis. !******************************************************************************* module particle_info use constants , only : fp implicit none private public ptl_mass , ptl_charge , get_ptl_mass_charge , species , ibtag , & sqrt_ptl_mass real ( fp ) :: ptl_mass , ptl_charge , sqrt_ptl_mass character ( len = 1 ) :: species character ( len = 2 ) :: ibtag ! Current energy band (transferred to string). contains subroutine get_ptl_mass_charge ( species ) use constants , only : qi , qe use picinfo , only : mime implicit none character ( * ), intent ( in ) :: species if ( species == 'e' ) then ptl_mass = 1.0 sqrt_ptl_mass = 1.0 ptl_charge = qe else if ( species == 'i' ) then ptl_mass = mime sqrt_ptl_mass = sqrt ( mime ) ptl_charge = qi else print * , \"Error: particles don't exist.\" stop endif end subroutine get_ptl_mass_charge end module particle_info","tags":"","loc":"sourcefile/particle_info.f90.html","title":"particle_info.f90 – Fortran Program"},{"text":"Module of doing interpolation in electromagnetic fields and their derivatives Source Code !******************************************************************************* ! Module of doing interpolation in electromagnetic fields and their derivatives !******************************************************************************* module interpolation_emf use constants , only : fp implicit none private public init_emfields , free_emfields , init_emfields_derivatives , & free_emfields_derivatives , read_emfields_single , & calc_interp_weights , calc_emfields_derivatives , calc_b_norm , & calc_gradient_B , calc_curvature , trilinear_interp_bx ,& trilinear_interp_by , trilinear_interp_bz , trilinear_interp_ex , & trilinear_interp_ey , trilinear_interp_ez public bx0 , by0 , bz0 , ex0 , ey0 , ez0 , absB0 , dbxdx0 , dbxdy0 , dbxdz0 , & dbydx0 , dbydy0 , dbydz0 , dbzdx0 , dbzdy0 , dbzdz0 , bxn , byn , bzn , & dBdx , dBdy , dBdz , kappax , kappay , kappaz real ( fp ), allocatable , dimension (:,:,:) :: ex , ey , ez , bx , by , bz real ( fp ), allocatable , dimension (:,:,:) :: ex1 , ey1 , ez1 , bx1 , by1 , bz1 real ( fp ), allocatable , dimension (:,:,:) :: dbxdx , dbxdy , dbxdz real ( fp ), allocatable , dimension (:,:,:) :: dbydx , dbydy , dbydz real ( fp ), allocatable , dimension (:,:,:) :: dbzdx , dbzdy , dbzdz real ( fp ) :: bx0 , by0 , bz0 , ex0 , ey0 , ez0 , absB0 real ( fp ) :: dbxdx0 , dbxdy0 , dbxdz0 real ( fp ) :: dbydx0 , dbydy0 , dbydz0 real ( fp ) :: dbzdx0 , dbzdy0 , dbzdz0 real ( fp ) :: bxn , byn , bzn ! Norm of the magnetic field real ( fp ) :: dBdx , dBdy , dBdz ! The gradient of B real ( fp ) :: kappax , kappay , kappaz ! The curvature of the magnetic field real ( fp ), dimension ( 2 , 2 , 2 ) :: weights ! The weights for trilinear interpolation integer :: nx , ny , nz contains !--------------------------------------------------------------------------- ! Initialize the electromagnetic fields !--------------------------------------------------------------------------- subroutine init_emfields use picinfo , only : domain implicit none nx = domain % pic_nx + 2 ! Including ghost cells ny = domain % pic_ny + 2 nz = domain % pic_nz + 2 allocate ( ex ( 0 : nx - 1 , 0 : ny - 1 , 0 : nz - 1 )) allocate ( ey ( 0 : nx - 1 , 0 : ny - 1 , 0 : nz - 1 )) allocate ( ez ( 0 : nx - 1 , 0 : ny - 1 , 0 : nz - 1 )) allocate ( bx ( 0 : nx - 1 , 0 : ny - 1 , 0 : nz - 1 )) allocate ( by ( 0 : nx - 1 , 0 : ny - 1 , 0 : nz - 1 )) allocate ( bz ( 0 : nx - 1 , 0 : ny - 1 , 0 : nz - 1 )) allocate ( ex1 ( 0 : nx - 1 , 0 : ny - 1 , 0 : nz - 1 )) allocate ( ey1 ( 0 : nx - 1 , 0 : ny - 1 , 0 : nz - 1 )) allocate ( ez1 ( 0 : nx - 1 , 0 : ny - 1 , 0 : nz - 1 )) allocate ( bx1 ( 0 : nx - 1 , 0 : ny - 1 , 0 : nz - 1 )) allocate ( by1 ( 0 : nx - 1 , 0 : ny - 1 , 0 : nz - 1 )) allocate ( bz1 ( 0 : nx - 1 , 0 : ny - 1 , 0 : nz - 1 )) ex = 0.0 ; ey = 0.0 ; ez = 0.0 bx = 0.0 ; by = 0.0 ; bz = 0.0 ex1 = 0.0 ; ey1 = 0.0 ; ez1 = 0.0 bx1 = 0.0 ; by1 = 0.0 ; bz1 = 0.0 end subroutine init_emfields !--------------------------------------------------------------------------- ! Initialize the derivatives of the electromagnetic fields !--------------------------------------------------------------------------- subroutine init_emfields_derivatives use picinfo , only : domain implicit none allocate ( dbxdx ( 0 : nx - 1 , 0 : ny - 1 , 0 : nz - 1 )) allocate ( dbxdy ( 0 : nx - 1 , 0 : ny - 1 , 0 : nz - 1 )) allocate ( dbxdz ( 0 : nx - 1 , 0 : ny - 1 , 0 : nz - 1 )) allocate ( dbydx ( 0 : nx - 1 , 0 : ny - 1 , 0 : nz - 1 )) allocate ( dbydy ( 0 : nx - 1 , 0 : ny - 1 , 0 : nz - 1 )) allocate ( dbydz ( 0 : nx - 1 , 0 : ny - 1 , 0 : nz - 1 )) allocate ( dbzdx ( 0 : nx - 1 , 0 : ny - 1 , 0 : nz - 1 )) allocate ( dbzdy ( 0 : nx - 1 , 0 : ny - 1 , 0 : nz - 1 )) allocate ( dbzdz ( 0 : nx - 1 , 0 : ny - 1 , 0 : nz - 1 )) dbxdx = 0.0 ; dbxdy = 0.0 ; dbxdz = 0.0 dbydx = 0.0 ; dbydy = 0.0 ; dbydz = 0.0 dbzdx = 0.0 ; dbzdy = 0.0 ; dbzdz = 0.0 end subroutine init_emfields_derivatives !--------------------------------------------------------------------------- ! Free the electromagnetic fields !--------------------------------------------------------------------------- subroutine free_emfields implicit none deallocate ( ex , ey , ez ) deallocate ( bx , by , bz ) deallocate ( ex1 , ey1 , ez1 ) deallocate ( bx1 , by1 , bz1 ) end subroutine free_emfields !--------------------------------------------------------------------------- ! Free the derivatives of the electromagnetic fields !--------------------------------------------------------------------------- subroutine free_emfields_derivatives implicit none deallocate ( dbxdx , dbxdy , dbxdz ) deallocate ( dbydx , dbydy , dbydz ) deallocate ( dbzdx , dbzdy , dbzdz ) end subroutine free_emfields_derivatives !--------------------------------------------------------------------------- ! Open the fields file for a single MPI process of PIC simulation. ! Inputs: !   fh: file handler. !   tindex0: the time step index. !   pic_mpi_id: MPI id for the PIC simulation to identify the file. !--------------------------------------------------------------------------- subroutine open_emfields_file ( fh , tindex0 , pic_mpi_id ) use path_info , only : rootpath use file_header , only : read_boilerplate , read_fields_header implicit none integer , intent ( in ) :: fh , tindex0 , pic_mpi_id character ( len = 150 ) :: fname logical :: is_exist integer :: tindex tindex = tindex0 ! Index 0 does not have proper current, so use index 1 if it exists if ( tindex == 0 ) then write ( fname , \"(A,I0,A8,I0,A1,I0)\" ) trim ( adjustl ( rootpath )) // \"fields/T.\" , & 1 , \"/fields.\" , 1 , \".\" , pic_mpi_id is_exist = .false. inquire ( file = trim ( fname ), exist = is_exist ) if ( is_exist ) tindex = 1 endif write ( fname , \"(A,I0,A8,I0,A1,I0)\" ) trim ( adjustl ( rootpath )) // \"fields/T.\" , & tindex , \"/fields.\" , tindex , \".\" , pic_mpi_id is_exist = .false. inquire ( file = trim ( fname ), exist = is_exist ) if ( is_exist ) then open ( unit = 10 , file = trim ( fname ), access = 'stream' , status = 'unknown' , & form = 'unformatted' , action = 'read' ) else print * , \"Can't find file:\" , fname print * print * , \" ***  Terminating ***\" stop endif call read_boilerplate ( fh ) call read_fields_header ( fh )","tags":"","loc":"sourcefile/interpolation_emf.f90.html","title":"interpolation_emf.f90 – Fortran Program"},{"text":"Module for calculating particle energy spectrum and velocity distributions\n in a box. Source Code !******************************************************************************* ! Module for calculating particle energy spectrum and velocity distributions ! in a box. !******************************************************************************* module particle_spectrum_vdist_module use mpi_module use constants , only : dp use path_info , only : get_file_paths use picinfo , only : read_domain , broadcast_pic_info , domain use particle_frames , only : get_particle_frames , nt , tinterval use spectrum_config , only : read_spectrum_config , set_spatial_range_de , & calc_pic_mpi_ids , tframe , init_pic_mpi_ranks , free_pic_mpi_ranks , & calc_pic_mpi_ranks , calc_velocity_interval use velocity_distribution , only : init_velocity_bins , free_velocity_bins , & init_vdist_2d , set_vdist_2d_zero , free_vdist_2d , init_vdist_1d , & set_vdist_1d_zero , free_vdist_1d , calc_vdist_2d , calc_vdist_1d use particle_energy_spectrum , only : init_energy_spectra , & free_energy_spectra , calc_energy_spectra , & set_energy_spectra_zero use parameters , only : get_start_end_time_points , get_inductive_flag , & get_relativistic_flag use magnetic_field , only : init_magnetic_fields , free_magnetic_fields , & read_magnetic_fields use particle_info , only : species , get_ptl_mass_charge implicit none private public particle_spectrum_vdist_main contains subroutine particle_spectrum_vdist_main use commandline_arguments , only : is_species , get_cmdline_arguments implicit none integer :: ct , ct_field , ratio_particle_field real ( dp ) :: mp_elapsed ! Initialize Message Passing call MPI_INIT ( ierr ) call MPI_COMM_RANK ( MPI_COMM_WORLD , myid , ierr ) call MPI_COMM_SIZE ( MPI_COMM_WORLD , numprocs , ierr ) call get_cmdline_arguments call get_file_paths if ( myid == master ) then call get_particle_frames endif call MPI_BCAST ( nt , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( tinterval , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierr ) if ( myid == master ) then call read_domain endif call broadcast_pic_info call get_start_end_time_points call get_inductive_flag call get_relativistic_flag call read_spectrum_config call calc_velocity_interval call set_spatial_range_de call calc_pic_mpi_ids call init_pic_mpi_ranks call calc_pic_mpi_ranks call init_energy_spectra call init_velocity_bins call init_vdist_2d call init_vdist_1d call init_magnetic_fields mp_elapsed = MPI_WTIME () ! Ratio of particle output interval to fields output interval ratio_particle_field = domain % Particle_interval / domain % fields_interval ct_field = ratio_particle_field * tframe call read_magnetic_fields ( ct_field ) if ( is_species ) then ! The particle species is given by the command line argument call get_ptl_mass_charge ( species ) if ( species == 'i' ) then call calc_spectrum_vdist ( tframe , 'h' ) else call calc_spectrum_vdist ( tframe , 'e' ) endif else species = 'e' call get_ptl_mass_charge ( species ) call calc_spectrum_vdist ( tframe , 'e' ) call set_energy_spectra_zero call set_vdist_2d_zero call set_vdist_1d_zero species = 'i' call get_ptl_mass_charge ( species ) call calc_spectrum_vdist ( tframe , 'h' ) endif mp_elapsed = MPI_WTIME () - mp_elapsed if ( myid == master ) then write ( * , '(A, F6.1)' ) \" Total time used (s): \" , mp_elapsed endif call free_magnetic_fields call free_vdist_1d call free_vdist_2d call free_velocity_bins call free_pic_mpi_ranks call free_energy_spectra call MPI_FINALIZE ( ierr ) end subroutine particle_spectrum_vdist_main !--------------------------------------------------------------------------- ! Calculate spectrum and velocity distributions. !--------------------------------------------------------------------------- subroutine calc_spectrum_vdist ( ct , species ) use mpi_module use constants , only : fp use particle_frames , only : tinterval use spectrum_config , only : nbins use particle_file , only : check_existence use particle_energy_spectrum , only : save_particle_spectra , & sum_spectra_over_mpi , calc_energy_bins use velocity_distribution , only : sum_vdist_1d_over_mpi , & sum_vdist_2d_over_mpi , save_vdist_1d , save_vdist_2d implicit none integer , intent ( in ) :: ct character ( len = 1 ), intent ( in ) :: species integer :: tindex logical :: is_exist call calc_energy_bins tindex = ct * tinterval call set_energy_spectra_zero call check_existence ( tindex , species , is_exist ) if ( is_exist ) then call calc_distributions_mpi ( tindex , species ) call sum_vdist_1d_over_mpi call sum_vdist_2d_over_mpi call sum_spectra_over_mpi if ( myid == master ) then call save_vdist_1d ( ct , species ) call save_vdist_2d ( ct , species ) call save_particle_spectra ( ct , species ) endif endif end subroutine calc_spectrum_vdist !--------------------------------------------------------------------------- ! Calculate spectrum and velocity distributions for multiple PIC MPI ranks. !--------------------------------------------------------------------------- subroutine calc_distributions_mpi ( tindex , species ) use mpi_module use picinfo , only : domain use file_header , only : pheader use spectrum_config , only : spatial_range , tot_pic_mpi , pic_mpi_ranks use particle_file , only : open_particle_file , check_particle_in_range , & close_particle_file , fh implicit none character ( len = 1 ), intent ( in ) :: species integer , intent ( in ) :: tindex character ( len = 50 ) :: cid logical :: isrange integer :: np , iptl integer :: IOstatus ! Read particle data in parallel to generate distributions do np = myid , tot_pic_mpi - 1 , numprocs write ( cid , \"(I0)\" ) pic_mpi_ranks ( np + 1 ) call open_particle_file ( tindex , species , cid ) isrange = check_particle_in_range ( spatial_range ) if ( isrange ) then ! Loop over particles do iptl = 1 , pheader % dim , 1 IOstatus = single_particle_energy_vel ( fh ) if ( IOstatus /= 0 ) exit enddo endif call close_particle_file enddo end subroutine calc_distributions_mpi !--------------------------------------------------------------------------- ! Calculate energy and velocities for one single particle and update the ! distribution arrays. !--------------------------------------------------------------------------- function single_particle_energy_vel ( fh ) result ( IOstatus ) use particle_module , only : ptl , calc_particle_energy , px , py , pz , & calc_ptl_coord , calc_para_perp_velocity use particle_energy_spectrum , only : update_energy_spectrum use velocity_distribution , only : update_vdist_1d , update_vdist_2d use spectrum_config , only : spatial_range use constants , only : fp implicit none integer , intent ( in ) :: fh integer :: IOstatus read ( fh , IOSTAT = IOstatus ) ptl if ( IOstatus == 0 ) then call calc_ptl_coord if (( px >= spatial_range ( 1 , 1 )) .and. ( px <= spatial_range ( 2 , 1 )) .and. & ( py >= spatial_range ( 1 , 2 )) .and. ( py <= spatial_range ( 2 , 2 )) .and. & ( pz >= spatial_range ( 1 , 3 )) .and. ( pz <= spatial_range ( 2 , 3 ))) then call calc_particle_energy call calc_para_perp_velocity call update_energy_spectrum call update_vdist_2d call update_vdist_1d endif endif end function single_particle_energy_vel end module particle_spectrum_vdist_module","tags":"","loc":"sourcefile/particle_spectrum_vdist.f90.html","title":"particle_spectrum_vdist.f90 – Fortran Program"},{"text":"Module of pressure tensor. It contains subroutines to calculate the scalar\n pressure from the pressure tensor, to calculate the divergence of the pressure\n tensor, the gradient of the scalar pressure. Source Code !******************************************************************************* ! Module of pressure tensor. It contains subroutines to calculate the scalar ! pressure from the pressure tensor, to calculate the divergence of the pressure ! tensor, the gradient of the scalar pressure. !******************************************************************************* module pressure_tensor use constants , only : fp use mpi_topology , only : htg use pic_fields , only : pxx , pyy , pzz , pxy , pxz , pyz implicit none private public init_scalar_pressure , init_div_ptensor , init_grad_pscalar , & free_scalar_pressure , free_div_ptensor , free_grad_pscalar , & calc_scalar_pressure , calc_grad_pscalar , calc_div_ptensor public pscalar , divp_x , divp_y , divp_z , gradp_x , gradp_y , gradp_z real ( fp ), allocatable , dimension (:, :, :) :: pscalar ! Divergence of the pressure tensor. real ( fp ), allocatable , dimension (:, :, :) :: divp_x , divp_y , divp_z ! Gradient of the scalar pressure. real ( fp ), allocatable , dimension (:, :, :) :: gradp_x , gradp_y , gradp_z contains !--------------------------------------------------------------------------- ! Initialize the scalar pressure. !--------------------------------------------------------------------------- subroutine init_scalar_pressure implicit none allocate ( pscalar ( htg % nx , htg % ny , htg % nz )) end subroutine init_scalar_pressure !--------------------------------------------------------------------------- ! Initialize the divergence of the pressure tensor. !--------------------------------------------------------------------------- subroutine init_div_ptensor implicit none allocate ( divp_x ( htg % nx , htg % ny , htg % nz )) allocate ( divp_y ( htg % nx , htg % ny , htg % nz )) allocate ( divp_z ( htg % nx , htg % ny , htg % nz )) end subroutine init_div_ptensor !--------------------------------------------------------------------------- ! Initialize the gradient of the scalar pressure. !--------------------------------------------------------------------------- subroutine init_grad_pscalar implicit none allocate ( gradp_x ( htg % nx , htg % ny , htg % nz )) allocate ( gradp_y ( htg % nx , htg % ny , htg % nz )) allocate ( gradp_z ( htg % nx , htg % ny , htg % nz )) end subroutine init_grad_pscalar !--------------------------------------------------------------------------- ! Free the scalar pressure. !--------------------------------------------------------------------------- subroutine free_scalar_pressure implicit none deallocate ( pscalar ) end subroutine free_scalar_pressure !--------------------------------------------------------------------------- ! Free the divergence of the pressure tensor. !--------------------------------------------------------------------------- subroutine free_div_ptensor implicit none deallocate ( divp_x , divp_y , divp_z ) end subroutine free_div_ptensor !--------------------------------------------------------------------------- ! Free the gradient of the scalar pressure. !--------------------------------------------------------------------------- subroutine free_grad_pscalar implicit none deallocate ( gradp_x , gradp_y , gradp_z ) end subroutine free_grad_pscalar !--------------------------------------------------------------------------- ! Calculate the scalar pressure from the pressure tensor. !--------------------------------------------------------------------------- subroutine calc_scalar_pressure implicit none pscalar = ( pxx + pyy + pzz ) / 3.0 end subroutine calc_scalar_pressure !--------------------------------------------------------------------------- ! Calculate the divergence of the pressure tensor. !--------------------------------------------------------------------------- subroutine calc_div_ptensor use constants , only : dp use neighbors_module , only : ixl , iyl , izl , ixh , iyh , izh , idx , idy , idz implicit none integer :: nx , ny , nz , ix , iy , iz nx = htg % nx ny = htg % ny nz = htg % nz do iz = 1 , nz do iy = 1 , ny do ix = 1 , nx divp_x ( ix , iy , iz ) = & ( pxx ( ixh ( ix ), iy , iz ) - pxx ( ixl ( ix ), iy , iz )) * idx ( ix ) + & ( pxy ( ix , iyh ( iy ), iz ) - pxy ( ix , iyl ( iy ), iz )) * idy ( iy ) + & ( pxz ( ix , iy , izh ( iz )) - pxz ( ix , iy , izl ( iz ))) * idz ( iz ) divp_y ( ix , iy , iz ) = & ( pxy ( ixh ( ix ), iy , iz ) - pxy ( ixl ( ix ), iy , iz )) * idx ( ix ) + & ( pyy ( ix , iyh ( iy ), iz ) - pyy ( ix , iyl ( iy ), iz )) * idy ( iy ) + & ( pyz ( ix , iy , izh ( iz )) - pyz ( ix , iy , izl ( iz ))) * idz ( iz ) divp_z ( ix , iy , iz ) = & ( pxz ( ixh ( ix ), iy , iz ) - pxz ( ixl ( ix ), iy , iz )) * idx ( ix ) + & ( pyz ( ix , iyh ( iy ), iz ) - pyz ( ix , iyl ( iy ), iz )) * idy ( iy ) + & ( pzz ( ix , iy , izh ( iz )) - pzz ( ix , iy , izl ( iz ))) * idz ( iz ) enddo ! X enddo ! Y enddo ! Z end subroutine calc_div_ptensor !--------------------------------------------------------------------------- ! Calculate the gradient of the scalar pressure. !--------------------------------------------------------------------------- subroutine calc_grad_pscalar use constants , only : dp use neighbors_module , only : ixl , iyl , izl , ixh , iyh , izh , idx , idy , idz implicit none integer :: nx , ny , nz , ix , iy , iz nx = htg % nx ny = htg % ny nz = htg % nz do iz = 1 , nz do iy = 1 , ny do ix = 1 , nx gradp_x ( ix , iy , iz ) = ( pscalar ( ixh ( ix ), iy , iz ) - & pscalar ( ixl ( ix ), iy , iz )) * idx ( ix ) gradp_y ( ix , iy , iz ) = ( pscalar ( ix , iyh ( iy ), iz ) - & pscalar ( ix , iyl ( iy ), iz )) * idy ( iy ) gradp_z ( ix , iy , iz ) = ( pscalar ( ix , iy , izh ( iz )) - & pscalar ( ix , iy , izl ( iz ))) * idz ( iz ) enddo ! X enddo ! Y enddo ! Z end subroutine calc_grad_pscalar !--------------------------------------------------------------------------- ! Save the gradient of pscalar. ! Input: !   ct: current time frame. !--------------------------------------------------------------------------- subroutine save_grad_pscalar ( ct ) use mpi_module use constants , only : fp use mpi_io_fields , only : save_field implicit none integer , intent ( in ) :: ct if ( myid == master ) then print * , 'Saving the gradient of the scalar pressure' , ct endif call save_field ( gradp_x , 'gradp_x' , ct ) call save_field ( gradp_y , 'gradp_y' , ct ) call save_field ( gradp_z , 'gradp_z' , ct ) end subroutine save_grad_pscalar !--------------------------------------------------------------------------- ! Save the divergence of the pressure tensor. ! Input: !   ct: current time frame. !--------------------------------------------------------------------------- subroutine save_div_ptensor ( ct ) use mpi_module use constants , only : fp use mpi_io_fields , only : save_field implicit none integer , intent ( in ) :: ct if ( myid == master ) then print * , 'Saving the divergence of the pressure tensor' , ct endif call save_field ( divp_x , 'divp_x' , ct ) call save_field ( divp_y , 'divp_y' , ct ) call save_field ( divp_z , 'divp_z' , ct ) end subroutine save_div_ptensor end module pressure_tensor","tags":"","loc":"sourcefile/pressure_tensor.f90.html","title":"pressure_tensor.f90 – Fortran Program"},{"text":"Source Code ! ! Copyright (c) 2015 Edward D. Zaron, Portland, Oregon, USA ! ! Permission is hereby granted, free of charge, to any person obtaining a copy of this ! software and associated documentation files (the \"Software\"), to deal in the Software ! without restriction, including without limitation the rights to use, copy, modify, merge, ! publish, distribute, sublicense, and/or sell copies of the Software, and to permit ! persons to whom the Software is furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in all copies or ! substantial portions of the Software. ! ! Except as contained in this notice, the name(s) of the above copyright holders shall not ! be used in advertising or otherwise to promote the sale, use or other dealings in this ! Software without prior written authorization. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, ! INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR ! PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE ! FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR ! OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER ! DEALINGS IN THE SOFTWARE. ! module kinds implicit none integer ( kind = 4 ), public , parameter :: int_kind = 4 integer ( kind = 4 ), public , parameter :: real_kind = 4 integer ( kind = 4 ), public , parameter :: ptr_kind = 8 integer ( kind = 4 ), public , parameter :: STRLEN = 64 integer ( kind = 4 ), public , parameter :: XSTRLEN = 256 end module kinds","tags":"","loc":"sourcefile/kinds.f90.html","title":"kinds.f90 – Fortran Program"},{"text":"This module includes the magnetic field data, methods to read, free the\n magnetic field and get the magnetic field at one point. Source Code !******************************************************************************* ! This module includes the magnetic field data, methods to read, free the ! magnetic field and get the magnetic field at one point. !******************************************************************************* module magnetic_field use constants , only : fp implicit none private public init_magnetic_fields , read_magnetic_fields , & free_magnetic_fields , get_magnetic_field_at_point public bx0 , by0 , bz0 real ( fp ), allocatable , dimension (:,:) :: Bx , By , Bz integer :: nx , nz , ix1 , ix2 , iz1 , iz2 real ( fp ) :: shiftx , shiftz ! The offset of one point from the corner. real ( fp ) :: bx0 , by0 , bz0 ! Magnetic field at one point. contains !--------------------------------------------------------------------------- ! Initialize the magnetic field. !--------------------------------------------------------------------------- subroutine init_magnetic_fields use picinfo , only : domain implicit none nx = domain % nx nz = domain % nz allocate ( Bx ( nx , nz )) allocate ( By ( nx , nz )) allocate ( Bz ( nx , nz )) Bx = 0.0 Bz = 0.0 Bz = 0.0 end subroutine init_magnetic_fields !--------------------------------------------------------------------------- ! Free the magnetic field. !--------------------------------------------------------------------------- subroutine free_magnetic_fields implicit none deallocate ( Bx , By , Bz ) end subroutine free_magnetic_fields !--------------------------------------------------------------------------- ! Read the magnetic field using the master MPI process and broadcast to ! other MPI processes. !--------------------------------------------------------------------------- subroutine read_magnetic_fields ( ct ) use mpi_module use constants , only : fp , dp use path_info , only : rootpath use parameters , only : tp1 implicit none integer , intent ( in ) :: ct character ( len = 150 ) :: filename integer ( dp ) :: pos1 integer :: fh fh = 101 if ( myid == master ) then ! Bx filename = trim ( adjustl ( rootpath )) // 'data/bx.gda' open ( unit = fh , file = trim ( filename ), access = 'stream' ,& status = 'unknown' , form = 'unformatted' , action = 'read' ) pos1 = nx * nz * sizeof ( fp ) * ( ct - tp1 ) + 1 read ( fh , pos = pos1 ) Bx close ( fh ) ! By filename = trim ( adjustl ( rootpath )) // 'data/by.gda' open ( unit = fh , file = trim ( filename ), access = 'stream' ,& status = 'unknown' , form = 'unformatted' , action = 'read' ) read ( fh , pos = pos1 ) By close ( fh ) ! Bz filename = trim ( adjustl ( rootpath )) // 'data/bz.gda' open ( unit = fh , file = trim ( filename ), access = 'stream' ,& status = 'unknown' , form = 'unformatted' , action = 'read' ) read ( fh , pos = pos1 ) Bz close ( fh ) endif call MPI_BCAST ( Bx , nx * nz , MPI_REAL , master , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( By , nx * nz , MPI_REAL , master , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( Bz , nx * nz , MPI_REAL , master , MPI_COMM_WORLD , ierr ) end subroutine read_magnetic_fields !--------------------------------------------------------------------------- ! Calculate the 2D grid indices for one point. ! Input: !   x, z: the coordinates of the point. !   dx, dz: the grid sizes. ! Updates: !   ix1, iz1: grid indices for the bottom left corner. !   ix2, iz2: grid indices for the top right corner. !   shiftx, shifty: the offsets from the bottom left corner. ! Note: !   Make sure that x, z, dx, dz are in the same unit (di or de). !--------------------------------------------------------------------------- subroutine calc_grid_indices ( x , z , dx , dz ) use picinfo , only : domain implicit none real ( fp ), intent ( in ) :: x , z , dx , dz real ( fp ) :: izf izf = ( z + domain % lz_de * 0.5 ) / dz ix1 = floor ( x / dx ) iz1 = floor ( izf ) ix2 = ix1 + 1 iz2 = iz1 + 1 shiftx = x / dx - ix1 shiftz = izf - iz1 end subroutine calc_grid_indices !--------------------------------------------------------------------------- ! Get magnetic field at one point. ! Inputs: !   x, z: the coordinates of the point. !   dx, dz: the grid sizes. !--------------------------------------------------------------------------- subroutine get_magnetic_field_at_point ( x , z , dx , dz ) implicit none real ( fp ), intent ( in ) :: x , z , dx , dz real ( fp ) :: v1 , v2 , v3 , v4 call calc_grid_indices ( x , z , dx , dz ) if ( ix1 >= 1 .and. ix1 <= nx .and. ix2 >= 0 .and. ix2 <= nx .and. & iz1 >= 1 .and. iz1 <= nz .and. iz2 >= 1 .and. iz2 <= nz ) then v1 = ( 1.0 - shiftx ) * ( 1.0 - shiftz ) v2 = shiftx * ( 1.0 - shiftz ) v3 = shiftx * shiftz v4 = ( 1.0 - shiftx ) * shiftz bx0 = Bx ( ix1 , iz1 ) * v1 + Bx ( ix1 , iz2 ) * v2 + Bx ( ix2 , iz2 ) * v3 + Bx ( ix2 , iz1 ) * v4 by0 = By ( ix1 , iz1 ) * v1 + By ( ix1 , iz2 ) * v2 + By ( ix2 , iz2 ) * v3 + By ( ix2 , iz1 ) * v4 bz0 = Bz ( ix1 , iz1 ) * v1 + Bz ( ix1 , iz2 ) * v2 + Bz ( ix2 , iz2 ) * v3 + Bz ( ix2 , iz1 ) * v4 endif end subroutine get_magnetic_field_at_point end module magnetic_field","tags":"","loc":"sourcefile/magnetic_field.f90.html","title":"magnetic_field.f90 – Fortran Program"},{"text":"Parser for the commandline arguments. Source Code !******************************************************************************* ! Parser for the commandline arguments. !******************************************************************************* module commandline_arguments use mpi_module use kinds use cla implicit none private public is_species , is_config_dist , is_emax_cell public get_cmdline_arguments logical :: is_species , is_config_dist , is_emax_cell contains !--------------------------------------------------------------------------- ! Get the commandline arguments and update corresponding variables. !--------------------------------------------------------------------------- subroutine get_cmdline_arguments implicit none character ( len = STRLEN ) :: config_dist call cla_init call get_particle_species call get_config_dist call get_emax_cell_flag end subroutine get_cmdline_arguments !--------------------------------------------------------------------------- ! Get particle species. ! Note: the species_local should be 'e' for electron and 'i' for ion. !--------------------------------------------------------------------------- subroutine get_particle_species use particle_info , only : species implicit none character ( len = STRLEN ) :: species_local logical :: log1 , log2 species_local = 'e' call cla_register ( '-s' , '--species' , 'character' , cla_char , & species_local ) log1 = cla_key_present ( '-s' ) log2 = cla_key_present ( '--species' ) is_species = log1 .or. log2 call cla_get ( '-s' , species_local ) if ( is_species ) then species = species_local if ( myid == master ) then print * , \"---------------------------------------------------\" if ( species == 'e' ) then write ( * , '(A)' ) ' Particle species is electron' else write ( * , '(A)' ) ' Particle species is ion' endif endif else if ( myid == master ) then print * , \"---------------------------------------------------\" write ( * , '(A)' ) ' Doing analysis for both species' endif endif end subroutine get_particle_species !--------------------------------------------------------------------------- ! Get configuration filename for particle energy distribution or velocity ! distributions, since they share the same configuration file. !--------------------------------------------------------------------------- subroutine get_config_dist use spectrum_config , only : config_name implicit none character ( len = STRLEN ) :: config_name_arg logical :: log1 , log2 config_name_arg = 'config_files/spectrum_config.dat' config_name = config_name_arg call cla_register ( '-c' , '--config_dist' , 'character' , cla_char , & config_name_arg ) log1 = cla_key_present ( '-c' ) log2 = cla_key_present ( '--config_dist' ) is_config_dist = log1 .or. log2 call cla_get ( '-c' , config_name_arg ) if ( is_config_dist ) then config_name = config_name_arg endif if ( myid == master ) then write ( * , '(A)' ) ' The configuration file for spectrum and velocity' write ( * , '(A,A)' ) ' distributions is ' , config_name endif end subroutine get_config_dist !--------------------------------------------------------------------------- ! Get flag on whether to get the maximum energy for each cell. !--------------------------------------------------------------------------- subroutine get_emax_cell_flag implicit none logical :: log1 , log2 is_emax_cell = .False. call cla_register ( '-e' , '--emax' , 'character' , cla_flag , 'f' ) log1 = cla_key_present ( '-e' ) log2 = cla_key_present ( '--emax' ) is_emax_cell = log1 .or. log2 if ( is_emax_cell ) then if ( myid == master ) then print * , \"---------------------------------------------------\" write ( * , '(A)' ) ' Get the maximum energy for each cell' endif endif end subroutine get_emax_cell_flag end module commandline_arguments","tags":"","loc":"sourcefile/commandline_arguments.f90.html","title":"commandline_arguments.f90 – Fortran Program"},{"text":"This module includes the inductive electric field, and the method to\n calculate it. Source Code !******************************************************************************* ! This module includes the inductive electric field, and the method to ! calculate it. !******************************************************************************* module inductive_electric_field use mpi_module use constants , only : fp use picinfo , only : domain implicit none private public exin , eyin , ezin public init_inductive , free_inductive , calc_inductive_e public init_inductive_electric_field , free_inductive_electric_field real ( fp ), allocatable , dimension (:,:,:) :: exin , eyin , ezin ! Single fluid velocity. integer , dimension ( 3 ) :: fh_vel ! File handler for velocity field. integer , dimension ( 3 ) :: fh_nrho ! File handler for number density. contains !--------------------------------------------------------------------------- ! Initialize the inductive electric field. !--------------------------------------------------------------------------- subroutine init_inductive_electric_field use mpi_topology , only : htg implicit none integer :: nx , ny , nz nx = htg % nx ny = htg % ny nz = htg % nz allocate ( exin ( nx , ny , nz )) allocate ( eyin ( nx , ny , nz )) allocate ( ezin ( nx , ny , nz )) exin = 0.0 eyin = 0.0 ezin = 0.0 end subroutine init_inductive_electric_field !--------------------------------------------------------------------------- ! Free the inductive electric field. !--------------------------------------------------------------------------- subroutine free_inductive_electric_field implicit none deallocate ( exin , eyin , ezin ) end subroutine free_inductive_electric_field !--------------------------------------------------------------------------- ! Initialize the calculation of the inductive electric field. ! Input: !   species: current particle species. 'e' for electron. 'i' for ion. !--------------------------------------------------------------------------- subroutine init_inductive ( species ) use usingle , only : open_velocity_density_files , init_usingle implicit none character ( len = 1 ), intent ( in ) :: species call init_inductive_electric_field call init_usingle ( species ) call open_velocity_density_files ( species ) end subroutine init_inductive !--------------------------------------------------------------------------- ! Finalize the calculation of the inductive electric field. ! Input: !   species: current particle species. 'e' for electron. 'i' for ion. !--------------------------------------------------------------------------- subroutine free_inductive ( species ) use usingle , only : close_velocity_density_files , free_usingle implicit none character ( len = 1 ), intent ( in ) :: species call free_inductive_electric_field call free_usingle ( species ) call close_velocity_density_files ( species ) end subroutine free_inductive !--------------------------------------------------------------------------- ! Calculate the inductive electric field -v*B. ! Input: !   ct: current time point. It is from tp1 to tp2. !   species: particle species. 'e' for electron. 'i' for ion. !--------------------------------------------------------------------------- subroutine calc_inductive_e ( ct , species ) use mpi_module use parameters , only : tp1 use pic_fields , only : bx , by , bz use picinfo , only : domain , mime use mpi_datatype_fields , only : filetype_ghost , subsizes_ghost use mpi_io_module , only : read_data_mpi_io use usingle , only : calc_usingle , vsx , vsy , vsz implicit none integer , intent ( in ) :: ct character ( * ), intent ( in ) :: species call calc_usingle ( species ) exin = by * vsz - bz * vsy eyin = bz * vsx - bx * vsz ezin = bx * vsy - by * vsx end subroutine calc_inductive_e end module inductive_electric_field","tags":"","loc":"sourcefile/inductive_efield.f90.html","title":"inductive_efield.f90 – Fortran Program"},{"text":"This module gives the parameters and routines for analysis dealing with\n particle information along a field line, e.g. particle spectrum along a\n field line or particle velocity distribution along a field line. Source Code !******************************************************************************* ! This module gives the parameters and routines for analysis dealing with ! particle information along a field line, e.g. particle spectrum along a ! field line or particle velocity distribution along a field line. !******************************************************************************* module particle_fieldline use mpi_module use constants , only : fp implicit none private public init_analysis , end_analysis , get_fieldline_points public nptot , np , startp , endp integer :: nptot ! The actual number of points along the field line. integer :: np ! Number of points for current MPI process. integer :: startp , endp ! Starting and ending points. contains !--------------------------------------------------------------------------- ! Initialize this analysis ! Input: !   ct: current time frame for fields. !--------------------------------------------------------------------------- subroutine init_analysis ( ct ) use path_info , only : get_file_paths use picinfo , only : read_domain , broadcast_pic_info use particle_frames , only : get_particle_frames , tinterval use fieldline_tracing , only : init_fieldline_tracing , & Dormand_Prince_parameters , init_fieldline_points use magnetic_field , only : read_magnetic_fields use parameters , only : get_start_end_time_points , get_inductive_flag , & get_relativistic_flag implicit none integer , intent ( in ) :: ct call MPI_INIT ( ierr ) call MPI_COMM_RANK ( MPI_COMM_WORLD , myid , ierr ) call MPI_COMM_SIZE ( MPI_COMM_WORLD , numprocs , ierr ) call get_file_paths call validate_time_frame ( ct ) ! The PIC simulation information. if ( myid == master ) then call read_domain call get_particle_frames endif call MPI_BCAST ( tinterval , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierr ) call broadcast_pic_info call get_start_end_time_points call get_inductive_flag call get_relativistic_flag ! Get the information for field line tracing. call init_fieldline_tracing call init_fieldline_points call Dormand_Prince_parameters call read_magnetic_fields ( ct ) end subroutine init_analysis !--------------------------------------------------------------------------- ! Trace a field line starting at one point, save the points along the field ! line, and distribute the coordinates of the points for further analysis. ! Inputs: !   x0, z0: the coordinates of the starting point. !--------------------------------------------------------------------------- subroutine get_fieldline_points ( x0 , z0 ) use fieldline_tracing , only : npoints , trace_field_line use mpi_topology , only : distribute_tasks implicit none real ( fp ), intent ( in ) :: x0 , z0 ! Set the tasks for each MPI process. call trace_field_line ( x0 , z0 ) ! Recored npoints at the same time. nptot = npoints call distribute_tasks ( nptot , numprocs , myid , np , startp , endp ) end subroutine get_fieldline_points !--------------------------------------------------------------------------- ! End the analysis. !--------------------------------------------------------------------------- subroutine end_analysis use fieldline_tracing , only : end_fieldline_tracing , free_fieldline_points implicit none call free_fieldline_points call end_fieldline_tracing call MPI_FINALIZE ( ierr ) end subroutine end_analysis !--------------------------------------------------------------------------- ! Check if both particle and fields exist at current time frame. If not, ! the analysis is ended and an error message is given. !--------------------------------------------------------------------------- subroutine validate_time_frame ( ct ) use particle_file , only : check_both_particle_fields_exist , & get_ratio_interval , ratio_interval implicit none integer , intent ( in ) :: ct logical :: is_time_valid ! Get the ratio of the particle output and field output. if ( myid == master ) then call get_ratio_interval endif call MPI_BCAST ( ratio_interval , 1 , MPI_INTEGER , master , & MPI_COMM_WORLD , ierr ) ! Check whether the time frame is valid for both fields and particles. is_time_valid = check_both_particle_fields_exist ( ct ) if ( .not. is_time_valid ) then if ( myid == master ) then write ( * , '(A,I0,A)' ) 'ct = ' , ct , ' is invalid.' write ( * , '(A,I0)' ) 'Choose a time that is a multiple of ' , & ratio_interval endif call MPI_FINALIZE ( ierr ) stop endif end subroutine validate_time_frame end module particle_fieldline","tags":"","loc":"sourcefile/particle_fieldline.f90.html","title":"particle_fieldline.f90 – Fortran Program"},{"text":"Module of particle output frames. Source Code !******************************************************************************* ! Module of particle output frames. !******************************************************************************* module particle_frames implicit none private public get_particle_frames_hydro , get_particle_frames public nt , tinterval , is_frame0 integer :: nt , tinterval ! Number of time frames and time interval logical :: is_frame0 ! Whether time 0 is saved contains !--------------------------------------------------------------------------- ! Get the number of particle frames and the time step interval. This is ! based on particle dump. !--------------------------------------------------------------------------- subroutine get_particle_frames implicit none character ( len = 64 ) :: fpath fpath = '../particle/' call get_particle_frames_general ( trim ( fpath )) end subroutine get_particle_frames !--------------------------------------------------------------------------- ! Get the number of particle frames and the time step interval. This is ! based on spectra dump for each MPI process. The spectra are calculated ! for each MPI process of the PIC simulation and saved in \"hydro\" directory. !--------------------------------------------------------------------------- subroutine get_particle_frames_hydro implicit none character ( len = 64 ) :: fpath fpath = '../hydro/' call get_particle_frames_general ( trim ( fpath )) end subroutine get_particle_frames_hydro !--------------------------------------------------------------------------- ! Get the number of particle frames and the time step interval. ! Input: !   fpath: the file path which contains the data !--------------------------------------------------------------------------- subroutine get_particle_frames_general ( fpath ) implicit none character ( * ), intent ( in ) :: fpath character ( len = 64 ) :: fname , fname_full integer :: reason , tmp , tmax , stat , access integer :: nt0 call system ( 'ls ' // fpath // ' > fileContents.txt' ) open ( 31 , file = 'fileContents.txt' , action = 'read' ) is_frame0 = .False. ! How many nt = 0 tinterval = 1000000 ! some large number tmax = 1 ! Maximum time do read ( 31 , '(A)' , iostat = reason ) fname read ( fname ( index ( fname , '.' ) + 1 :), * ) tmp if ( reason /= 0 ) exit if ( tmp < tinterval .and. tmp > 0 ) tinterval = tmp if ( tmp > tmax ) tmax = tmp nt = nt + 1 enddo close ( 31 ) ! In case there is time gap nt0 = tmax / tinterval fname_full = trim ( fpath ) // 'T.0' ! Time 0 frame stat = access ( fname_full , 'r' ) if ( stat .eq. 0 ) then nt0 = nt0 + 1 is_frame0 = .True. endif nt = nt0 ! Echo this information print * , \"---------------------------------------------------\" write ( * , '(A,I0)' ) ' Number of time frames: ' , nt write ( * , '(A,I0)' ) ' The time interval is: ' , tinterval print * , \"---------------------------------------------------\" end subroutine get_particle_frames_general end module particle_frames","tags":"","loc":"sourcefile/particle_frames.f90.html","title":"particle_frames.f90 – Fortran Program"},{"text":"Module for velocities of previous and post time frames. Module for number density of previous and post time frames. This module include the methods to calculate current densities due to\n different fluid drifts. Not all of currents due to drifts are expressed in\n explicit form to save space. The suffix 1, 2 of each variable indicate two\n different set of data. They can be used to express different kind of currents.\n The energy conversion due to j \\cdot E is calculated when the current\n denisities are calculated, since jx, jy, jz are going to be re-used. Source Code !******************************************************************************* ! Module for velocities of previous and post time frames. !******************************************************************************* module previous_post_velocities use constants , only : fp implicit none private public vdx1 , vdy1 , vdz1 , vdx2 , vdy2 , vdz2 public init_pre_post_velocities , free_pre_post_velocities , & read_pre_post_velocities real ( fp ), allocatable , dimension (:, :, :) :: vdx1 , vdy1 , vdz1 real ( fp ), allocatable , dimension (:, :, :) :: vdx2 , vdy2 , vdz2 contains !--------------------------------------------------------------------------- ! Initialize velocities of the previous time frame and post time frame. ! They are going be be used to calculate polarization drift current. !--------------------------------------------------------------------------- subroutine init_pre_post_velocities use mpi_topology , only : htg implicit none integer :: nx , ny , nz nx = htg % nx ny = htg % ny nz = htg % nz allocate ( vdx1 ( nx , ny , nz )) allocate ( vdy1 ( nx , ny , nz )) allocate ( vdz1 ( nx , ny , nz )) allocate ( vdx2 ( nx , ny , nz )) allocate ( vdy2 ( nx , ny , nz )) allocate ( vdz2 ( nx , ny , nz )) vdx1 = 0.0 ; vdy1 = 0.0 ; vdz1 = 0.0 vdx2 = 0.0 ; vdy2 = 0.0 ; vdz2 = 0.0 end subroutine init_pre_post_velocities !--------------------------------------------------------------------------- ! Free the velocities of the previous time frame and post time frame. !--------------------------------------------------------------------------- subroutine free_pre_post_velocities implicit none deallocate ( vdx1 , vdy1 , vdz1 , vdx2 , vdy2 , vdz2 ) end subroutine free_pre_post_velocities !--------------------------------------------------------------------------- ! Read previous and post velocities. Only one of them is read in the ! first and last time frame. ! Input: !   ct: current time frame. !   fh: the file handlers for the velocities. !--------------------------------------------------------------------------- subroutine read_pre_post_velocities ( ct , fh ) use mpi_module use constants , only : fp use parameters , only : tp1 use picinfo , only : domain , nt ! Total number of output time frames. use mpi_datatype_fields , only : filetype_ghost , subsizes_ghost use mpi_io_module , only : read_data_mpi_io use pic_fields , only : vx , vy , vz implicit none integer , intent ( in ) :: ct integer , dimension ( 3 ), intent ( in ) :: fh integer ( kind = MPI_OFFSET_KIND ) :: disp , offset offset = 0 if (( ct >= tp1 ) .and. ( ct < nt )) then disp = domain % nx * domain % ny * domain % nz * sizeof ( fp ) * ( ct - tp1 + 1 ) call read_data_mpi_io ( fh ( 1 ), filetype_ghost , subsizes_ghost , & disp , offset , vdx2 ) call read_data_mpi_io ( fh ( 2 ), filetype_ghost , subsizes_ghost , & disp , offset , vdy2 ) call read_data_mpi_io ( fh ( 3 ), filetype_ghost , subsizes_ghost , & disp , offset , vdz2 ) else ! ct = nt, last time frame. vdx2 = vx vdy2 = vy vdz2 = vz endif if (( ct <= nt ) .and. ( ct > tp1 )) then disp = domain % nx * domain % ny * domain % nz * sizeof ( fp ) * ( ct - tp1 - 1 ) call read_data_mpi_io ( fh ( 1 ), filetype_ghost , subsizes_ghost , & disp , offset , vdx1 ) call read_data_mpi_io ( fh ( 2 ), filetype_ghost , subsizes_ghost , & disp , offset , vdy1 ) call read_data_mpi_io ( fh ( 3 ), filetype_ghost , subsizes_ghost , & disp , offset , vdz1 ) else ! ct = tp1, The first time frame. vdx1 = vx vdy1 = vy vdz1 = vz endif end subroutine read_pre_post_velocities end module previous_post_velocities !******************************************************************************* ! Module for number density of previous and post time frames. !******************************************************************************* module previous_post_density use constants , only : fp implicit none private public nrho1 , nrho2 public init_pre_post_density , free_pre_post_density , read_pre_post_density real ( fp ), allocatable , dimension (:, :, :) :: nrho1 , nrho2 contains !--------------------------------------------------------------------------- ! Initialize density of the previous time frame and post time frame. ! They are going be be used to calculate polarization drift current. !--------------------------------------------------------------------------- subroutine init_pre_post_density use mpi_topology , only : htg implicit none integer :: nx , ny , nz nx = htg % nx ny = htg % ny nz = htg % nz allocate ( nrho1 ( nx , ny , nz )) allocate ( nrho2 ( nx , ny , nz )) nrho1 = 0.0 nrho2 = 0.0 end subroutine init_pre_post_density !--------------------------------------------------------------------------- ! Free the density of the previous time frame and post time frame. !--------------------------------------------------------------------------- subroutine free_pre_post_density implicit none deallocate ( nrho1 , nrho2 ) end subroutine free_pre_post_density !--------------------------------------------------------------------------- ! Read previous and post densities. Only one of them is read in the ! first and last time frame. ! Input: !   ct: current time frame. !   fh: the file handlers for the velocities. !--------------------------------------------------------------------------- subroutine read_pre_post_density ( ct , fh ) use mpi_module use constants , only : fp use parameters , only : tp1 use picinfo , only : domain , nt ! Total number of output time frames. use mpi_datatype_fields , only : filetype_ghost , subsizes_ghost use mpi_io_module , only : read_data_mpi_io use pic_fields , only : num_rho implicit none integer , intent ( in ) :: ct integer , intent ( in ) :: fh integer ( kind = MPI_OFFSET_KIND ) :: disp , offset offset = 0 if (( ct >= tp1 ) .and. ( ct < nt )) then disp = domain % nx * domain % ny * domain % nz * sizeof ( fp ) * ( ct - tp1 + 1 ) call read_data_mpi_io ( fh , filetype_ghost , subsizes_ghost , & disp , offset , nrho2 ) else ! ct = nt, last time frame. nrho2 = num_rho endif if (( ct <= nt ) .and. ( ct > tp1 )) then disp = domain % nx * domain % ny * domain % nz * sizeof ( fp ) * ( ct - tp1 - 1 ) call read_data_mpi_io ( fh , filetype_ghost , subsizes_ghost , & disp , offset , nrho1 ) else ! ct = tp1, The first time frame. nrho1 = num_rho endif end subroutine read_pre_post_density end module previous_post_density !******************************************************************************* ! This module include the methods to calculate current densities due to ! different fluid drifts. Not all of currents due to drifts are expressed in ! explicit form to save space. The suffix 1, 2 of each variable indicate two ! different set of data. They can be used to express different kind of currents. ! The energy conversion due to j \\cdot E is calculated when the current ! denisities are calculated, since jx, jy, jz are going to be re-used. !******************************************************************************* module current_densities use constants , only : fp , dp use pic_fields , only : bx , by , bz , ex , ey , ez , pxx , pxy , pxz , pyy , & pyz , pzz , pyx , pzx , pzy , vx , vy , vz , ux , uy , uz , & num_rho , absB , jx , jy , jz use para_perp_pressure , only : ppara , pperp use neighbors_module , only : ixl , iyl , izl , ixh , iyh , izh , idx , idy , idz use jdote_module , only : jdote , calc_jdote use mpi_topology , only : htg use picinfo , only : domain use mpi_io_fields , only : save_field use parameters , only : is_rel implicit none private public jx1 , jy1 , jz1 , jx2 , jy2 ,","tags":"","loc":"sourcefile/current_densities.f90.html","title":"current_densities.f90 – Fortran Program"},{"text":"Module including the indices of the two adjoint points for finite difference\n method. Source Code !******************************************************************************* ! Module including the indices of the two adjoint points for finite difference ! method. !******************************************************************************* module neighbors_module use constants , only : fp , dp use picinfo , only : domain implicit none private public ixl , ixh , iyl , iyh , izl , izh , idx , idy , idz public init_neighbors , free_neighbors , get_neighbors , get_mpi_neighbors ! The indices of the neighbors. integer , allocatable , dimension (:) :: ixl , ixh , iyl , iyh , izl , izh ! The inverse of the distance between the neighbors. real ( dp ), allocatable , dimension (:) :: idx , idy , idz ! The sizes in each dimension. integer :: nx , ny , nz contains !--------------------------------------------------------------------------- ! Initialize the indices of the neighbors and the inverse of the distance ! between them. !--------------------------------------------------------------------------- subroutine init_neighbors ( nx0 , ny0 , nz0 ) implicit none integer , intent ( in ) :: nx0 , ny0 , nz0 nx = nx0 ny = ny0 nz = nz0 allocate ( ixl ( nx )) allocate ( ixh ( nx )) allocate ( idx ( nx )) allocate ( iyl ( ny )) allocate ( iyh ( ny )) allocate ( idy ( ny )) allocate ( izl ( nz )) allocate ( izh ( nz )) allocate ( idz ( nz )) ixl = 0 ; iyl = 0 ; izl = 0 ixh = 0 ; iyh = 0 ; izh = 0 idx = 0.0 ; idy = 0.0 ; idz = 0.0 end subroutine init_neighbors !--------------------------------------------------------------------------- ! Free the indices of the neighbors and the inverse of the distance between ! them. !--------------------------------------------------------------------------- subroutine free_neighbors implicit none deallocate ( ixl , iyl , izl ) deallocate ( ixh , iyh , izh ) deallocate ( idx , idy , idz ) end subroutine free_neighbors !--------------------------------------------------------------------------- ! Decide the indices of two neighbors. ! Input: !   ntot: total number of points in this dimension. !   indexc: index of current point. ! Output: !   indexl: index of the neighbor with lower index. !   indexh: index of the neighbor with higher index. !--------------------------------------------------------------------------- subroutine neighbors ( ntot , indexc , indexl , indexh ) implicit none integer , intent ( in ) :: ntot , indexc integer , intent ( out ) :: indexl , indexh if ( ntot == 1 ) then indexl = 1 indexh = 1 else if ( indexc == 1 ) then indexl = 1 indexh = 2 else if ( indexc == ntot ) then indexl = ntot - 1 indexh = ntot else indexl = indexc - 1 indexh = indexc + 1 endif end subroutine neighbors !--------------------------------------------------------------------------- ! Get the indices of the neighbors and the inverse of the distance between ! them. !--------------------------------------------------------------------------- subroutine get_neighbors implicit none integer :: ix , iy , iz do ix = 1 , nx call neighbors ( nx , ix , ixl ( ix ), ixh ( ix )) if (( ixh ( ix ) - ixl ( ix )) /= 0 ) then idx ( ix ) = domain % idx / ( ixh ( ix ) - ixl ( ix )) else idx ( ix ) = 0.0 endif enddo do iy = 1 , ny call neighbors ( ny , iy , iyl ( iy ), iyh ( iy )) if (( iyh ( iy ) - iyl ( iy )) /= 0 ) then idy ( iy ) = domain % idy / ( iyh ( iy ) - iyl ( iy )) else idy ( iy ) = 0.0 endif enddo do iz = 1 , nz call neighbors ( nz , iz , izl ( iz ), izh ( iz )) if (( izh ( iz ) - izl ( iz )) /= 0 ) then idz ( iz ) = domain % idz / ( izh ( iz ) - izl ( iz )) else idz ( iz ) = 0.0 endif enddo end subroutine get_neighbors !--------------------------------------------------------------------------- ! Get the MPI process neighbors in the PIC simulation ! Input: !   pic_mpi_id: PIC simulation mpi rank ! Output: !   nxl, nxh, nyl, nyh, nzl, nzh: the six neighbors. !--------------------------------------------------------------------------- subroutine get_mpi_neighbors ( pic_mpi_id , nxl , nxh , nyl , nyh , nzl , nzh ) use picinfo , only : domain implicit none integer , intent ( in ) :: pic_mpi_id integer , intent ( out ) :: nxl , nxh , nyl , nyh , nzl , nzh integer :: ix , iy , iz , tx , ty , tz tx = domain % pic_tx ty = domain % pic_ty tz = domain % pic_tz iz = pic_mpi_id / ( tx * ty ) iy = ( pic_mpi_id - iz * tx * ty ) / tx ix = pic_mpi_id - iz * tx * ty - iy * tx ! Initialize the neighbors to be zeros nxl = - 1 nxh = - 1 nyl = - 1 nyh = - 1 nzl = - 1 nzh = - 1 if ( ix > 0 ) nxl = pic_mpi_id - 1 if ( ix < tx - 1 ) nxh = pic_mpi_id + 1 if ( iy > 0 ) nyl = pic_mpi_id - ty if ( iy < ty - 1 ) nyh = pic_mpi_id + ty if ( iz > 0 ) nzl = pic_mpi_id - tx * ty if ( iz < tz - 1 ) nzh = pic_mpi_id + tx * ty end subroutine get_mpi_neighbors end module neighbors_module","tags":"","loc":"sourcefile/neighbors.f90.html","title":"neighbors.f90 – Fortran Program"},{"text":"Flags for whether save one kind of calculated field. 0 for not. 1 for yes.\n This is for saving large 2D or 3D data. Source Code !******************************************************************************* ! Flags for whether save one kind of calculated field. 0 for not. 1 for yes. ! This is for saving large 2D or 3D data. !******************************************************************************* module saving_flags implicit none private public save_jcpara , save_jcperp , save_jmag , save_jgrad , save_jdiagm , & save_jpolar , save_jexb , save_jpara , save_jperp , save_jperp1 , & save_jperp2 , save_jqnvpara , save_jqnvperp , save_jagy , save_jtot , & save_jdivv , save_pre , & save_jcpara_dote , save_jcperp_dote , save_jmag_dote , save_jgrad_dote , & save_jdiagm_dote , save_jpolar_dote , save_jexb_dote , save_jpara_dote , & save_jperp_dote , save_jperp1_dote , save_jperp2_dote , & save_jqnvpara_dote , save_jqnvperp_dote , save_jagy_dote , & save_jtot_dote , save_jdivv_dote public get_saving_flags integer :: save_jcpara , save_jcperp , save_jmag integer :: save_jgrad , save_jdiagm , save_jpolar integer :: save_jexb , save_jpara , save_jperp integer :: save_jperp1 , save_jperp2 , save_jqnvpara integer :: save_jqnvperp , save_jagy , save_jtot , save_jdivv integer :: save_jcpara_dote , save_jcperp_dote , save_jmag_dote integer :: save_jgrad_dote , save_jdiagm_dote , save_jpolar_dote integer :: save_jexb_dote , save_jpara_dote , save_jperp_dote integer :: save_jperp1_dote , save_jperp2_dote , save_jqnvpara_dote integer :: save_jqnvperp_dote , save_jagy_dote , save_jtot_dote , save_jdivv_dote integer :: save_pre contains !--------------------------------------------------------------------------- ! Read the saving flags from configuration file. !--------------------------------------------------------------------------- subroutine get_saving_flags use read_config , only : get_variable_int implicit none integer :: fh fh = 15 open ( unit = fh , file = 'config_files/saving_flags.dat' , status = 'old' ) save_jcpara = get_variable_int ( fh , 'save_jcpara' , '=' ) save_jcperp = get_variable_int ( fh , 'save_jcperp' , '=' ) save_jmag = get_variable_int ( fh , 'save_jmag' , '=' ) save_jgrad = get_variable_int ( fh , 'save_jgrad' , '=' ) save_jdiagm = get_variable_int ( fh , 'save_jdiagm' , '=' ) save_jpolar = get_variable_int ( fh , 'save_jpolar' , '=' ) save_jexb = get_variable_int ( fh , 'save_jexb' , '=' ) save_jpara = get_variable_int ( fh , 'save_jpara' , '=' ) save_jperp = get_variable_int ( fh , 'save_jperp' , '=' ) save_jperp1 = get_variable_int ( fh , 'save_jperp1' , '=' ) save_jperp2 = get_variable_int ( fh , 'save_jperp2' , '=' ) save_jqnvpara = get_variable_int ( fh , 'save_jqnvpara' , '=' ) save_jqnvperp = get_variable_int ( fh , 'save_jqnvperp' , '=' ) save_jagy = get_variable_int ( fh , 'save_jagy' , '=' ) save_jtot = get_variable_int ( fh , 'save_jtot' , '=' ) save_jtot = get_variable_int ( fh , 'save_jdivv' , '=' ) save_pre = get_variable_int ( fh , 'save_pre' , '=' ) save_jcpara_dote = get_variable_int ( fh , 'save_jcpara_dote' , '=' ) save_jcperp_dote = get_variable_int ( fh , 'save_jcperp_dote' , '=' ) save_jmag_dote = get_variable_int ( fh , 'save_jmag_dote' , '=' ) save_jgrad_dote = get_variable_int ( fh , 'save_jgrad_dote' , '=' ) save_jdiagm_dote = get_variable_int ( fh , 'save_jdiagm_dote' , '=' ) save_jpolar_dote = get_variable_int ( fh , 'save_jpolar_dote' , '=' ) save_jexb_dote = get_variable_int ( fh , 'save_jexb_dote' , '=' ) save_jpara_dote = get_variable_int ( fh , 'save_jpara_dote' , '=' ) save_jperp_dote = get_variable_int ( fh , 'save_jperp_dote' , '=' ) save_jperp1_dote = get_variable_int ( fh , 'save_jperp1_dote' , '=' ) save_jperp2_dote = get_variable_int ( fh , 'save_jperp2_dote' , '=' ) save_jqnvpara_dote = get_variable_int ( fh , 'save_jqnvpara_dote' , '=' ) save_jqnvperp_dote = get_variable_int ( fh , 'save_jqnvperp_dote' , '=' ) save_jagy_dote = get_variable_int ( fh , 'save_jagy_dote' , '=' ) save_jtot_dote = get_variable_int ( fh , 'save_jtot_dote' , '=' ) save_jtot_dote = get_variable_int ( fh , 'save_jdivv_dote' , '=' ) close ( fh ) end subroutine get_saving_flags end module saving_flags","tags":"","loc":"sourcefile/saving_flags.f90.html","title":"saving_flags.f90 – Fortran Program"},{"text":"Main program to calculate particle spectrum and velocity distributions in a\n user defined box. Source Code !******************************************************************************* ! Main program to calculate particle spectrum and velocity distributions in a ! user defined box. !******************************************************************************* program particle_spectrum_vdist_box use particle_spectrum_vdist_module implicit none call particle_spectrum_vdist_main end program particle_spectrum_vdist_box","tags":"","loc":"sourcefile/particle_spectrum_vdist_box.f90.html","title":"particle_spectrum_vdist_box.f90 – Fortran Program"},{"text":"The main procedure. Source Code !******************************************************************************* ! The main procedure. !******************************************************************************* program dissipation use mpi_module use particle_info , only : species , ibtag , get_ptl_mass_charge use analysis_management , only : init_analysis , end_analysis use commandline_arguments , only : is_species implicit none integer :: ct ibtag = '00' ct = 1 call init_analysis if ( is_species ) then ! The particle species is given by the command line argument call commit_analysis else species = 'e' call commit_analysis call MPI_BARRIER ( MPI_COMM_WORLD , ierror ) species = 'i' call commit_analysis endif call end_analysis contains !--------------------------------------------------------------------------- ! This subroutine does the analysis. !--------------------------------------------------------------------------- subroutine commit_analysis use mpi_topology , only : htg use particle_info , only : species use para_perp_pressure , only : init_para_perp_pressure , & free_para_perp_pressure , save_averaged_para_perp_pressure use pic_fields , only : open_pic_fields , init_pic_fields , & free_pic_fields , close_pic_fields_file use saving_flags , only : get_saving_flags use neighbors_module , only : init_neighbors , free_neighbors , get_neighbors use compression_shear , only : init_div_v , free_div_v use configuration_translate , only : output_format implicit none call get_ptl_mass_charge ( species ) call init_pic_fields call init_para_perp_pressure call init_div_v ! For compression related current density. call get_saving_flags if ( output_format == 1 ) then call open_pic_fields ( species ) endif call init_neighbors ( htg % nx , htg % ny , htg % nz ) call get_neighbors call energy_conversion_from_current call free_neighbors call free_para_perp_pressure call free_pic_fields if ( output_format == 1 ) then call close_pic_fields_file endif call free_div_v end subroutine commit_analysis !--------------------------------------------------------------------------- ! This subroutine calculates the energy conversion through electric current. !--------------------------------------------------------------------------- subroutine energy_conversion_from_current use mpi_module use picinfo , only : domain use parameters , only : tp1 , tp2 , inductive , is_rel use particle_info , only : ibtag , species use pic_fields , only : open_pic_fields , read_pic_fields , & close_pic_fields_file use pic_fields , only : vfields_fh , ufields_fh , nrho_fh use inductive_electric_field , only : calc_inductive_e , & init_inductive , free_inductive use previous_post_velocities , only : init_pre_post_velocities , & read_pre_post_velocities , free_pre_post_velocities use previous_post_density , only : init_pre_post_density , & read_pre_post_density , free_pre_post_density use current_densities , only : init_current_densities , & free_current_densities , set_current_densities_to_zero , & init_ava_current_densities , free_avg_current_densities , & save_averaged_current use para_perp_pressure , only : save_averaged_para_perp_pressure use jdote_module , only : init_jdote , free_jdote , & init_jdote_total , free_jdote_total , save_jdote_total use configuration_translate , only : output_format implicit none integer :: input_record , output_record integer :: tindex if ( inductive == 1 ) then call init_inductive ( species ) endif ! Calculate electric current due to all kinds of terms. ! And calculate energy conversion due to j.E. call init_current_densities call init_ava_current_densities call init_pre_post_velocities call init_pre_post_density call init_jdote call init_jdote_total do input_record = tp1 , tp2 if ( myid == master ) print * , input_record output_record = input_record - tp1 + 1 if ( output_format /= 1 ) then tindex = domain % fields_interval * ( input_record - tp1 ) call open_pic_fields ( species , tindex ) output_record = 1 call read_pic_fields ( tp1 ) else call read_pic_fields ( input_record ) endif if ( inductive == 1 ) then call calc_inductive_e ( input_record , species ) endif if ( is_rel == 1 ) then call read_pre_post_velocities ( input_record , ufields_fh ) else call read_pre_post_velocities ( input_record , vfields_fh ) endif call read_pre_post_density ( input_record , nrho_fh ) call calc_energy_conversion ( input_record ) call set_current_densities_to_zero if ( output_format /= 1 ) then call close_pic_fields_file endif enddo if ( myid == master ) then call save_averaged_current call save_jdote_total call save_averaged_para_perp_pressure endif call free_jdote_total call free_jdote call free_pre_post_velocities call free_pre_post_density call free_avg_current_densities call free_current_densities if ( inductive == 1 ) then call free_inductive ( species ) endif end subroutine energy_conversion_from_current !--------------------------------------------------------------------------- ! This subroutine calculates energy conversion for one time frame. ! Input: !   ct: current time frame. !--------------------------------------------------------------------------- subroutine calc_energy_conversion ( ct ) use para_perp_pressure , only : calc_para_perp_pressure , & calc_real_para_perp_pressure use current_densities , only : calc_current_densities implicit none integer , intent ( in ) :: ct call calc_real_para_perp_pressure ( ct ) ! call calc_para_perp_pressure(ct) call calc_current_densities ( ct ) end subroutine calc_energy_conversion end program dissipation","tags":"","loc":"sourcefile/dissipation.f90.html","title":"dissipation.f90 – Fortran Program"},{"text":"Program to calculate the bulk flow energy and internal energy. Source Code !******************************************************************************* ! Program to calculate the bulk flow energy and internal energy. !******************************************************************************* program bulk_flow_energy use particle_info , only : species , get_ptl_mass_charge use analysis_management , only : init_analysis , end_analysis implicit none call init_analysis species = 'e' call get_ptl_mass_charge ( species ) call commit_analysis species = 'i' call get_ptl_mass_charge ( species ) call commit_analysis call end_analysis contains !--------------------------------------------------------------------------- ! Commit analysis. !--------------------------------------------------------------------------- subroutine commit_analysis use mpi_module use constants , only : fp use mpi_topology , only : htg use pic_fields , only : vx , vy , vz , ux , uy , uz , pxx , pyy , pzz , num_rho , & open_velocity_field_files , open_pressure_tensor_files , & init_velocity_fields , init_pressure_tensor , & read_velocity_fields , read_pressure_tensor , & free_velocity_fields , free_pressure_tensor , & close_velocity_field_files , close_pressure_tensor_files , & open_number_density_file , init_number_density , & read_number_density , free_number_density , & close_number_density_file use particle_info , only : species , ibtag , ptl_mass use parameters , only : tp1 , tp2 , is_rel use mpi_io_fields , only : save_field use statistics , only : get_average_and_total implicit none real ( fp ), allocatable , dimension (:, :) :: bulk_energy , internal_energy real ( fp ), dimension ( 4 ) :: bene_tot , iene_tot real ( fp ) :: avg logical :: dir_e integer :: ct bene_tot = 0.0 ! Bulk energy iene_tot = 0.0 ! Internal energy if ( myid == master ) then allocate ( bulk_energy ( 4 , tp2 - tp1 + 1 )) allocate ( internal_energy ( 4 , tp2 - tp1 + 1 )) bulk_energy = 0.0 internal_energy = 0.0 endif call open_velocity_field_files ( species ) call open_pressure_tensor_files ( species ) call open_number_density_file ( species ) call init_velocity_fields ( htg % nx , htg % ny , htg % nz ) call init_pressure_tensor ( htg % nx , htg % ny , htg % nz ) call init_number_density ( htg % nx , htg % ny , htg % nz ) do ct = tp1 , tp2 if ( myid == master ) then print * , ct endif call read_velocity_fields ( ct ) call read_pressure_tensor ( ct ) call read_number_density ( ct ) if ( is_rel == 0 ) then call get_average_and_total ( 0.5 * vx * vx * ptl_mass * num_rho , & avg , bene_tot ( 1 )) call get_average_and_total ( 0.5 * vy * vy * ptl_mass * num_rho , & avg , bene_tot ( 2 )) call get_average_and_total ( 0.5 * vz * vz * ptl_mass * num_rho , & avg , bene_tot ( 3 )) bene_tot ( 4 ) = sum ( bene_tot ( 1 : 3 )) else call get_average_and_total ( ux * ux * ptl_mass ** 2 * num_rho ** 2 , & avg , bene_tot ( 1 )) call get_average_and_total ( uy * uy * ptl_mass ** 2 * num_rho ** 2 , & avg , bene_tot ( 2 )) call get_average_and_total ( uz * uz * ptl_mass ** 2 * num_rho ** 2 , & avg , bene_tot ( 3 )) call get_average_and_total (& ( sqrt ( 1.0 + ux * ux + uy * uy + uz * uz ) - 1.0 ) * ptl_mass * num_rho , & avg , bene_tot ( 4 )) endif call get_average_and_total ( 0.5 * pxx , avg , iene_tot ( 1 )) call get_average_and_total ( 0.5 * pyy , avg , iene_tot ( 2 )) call get_average_and_total ( 0.5 * pzz , avg , iene_tot ( 3 )) iene_tot ( 4 ) = sum ( iene_tot ( 1 : 3 )) if ( myid == master ) then bulk_energy ( 1 : 4 , ct - tp1 + 1 ) = bene_tot internal_energy ( 1 : 4 , ct - tp1 + 1 ) = iene_tot endif enddo call close_number_density_file call close_pressure_tensor_files call close_velocity_field_files call free_number_density call free_velocity_fields call free_pressure_tensor if ( myid == master ) then dir_e = .false. inquire ( file = './data/.' , exist = dir_e ) if ( .not. dir_e ) then call system ( 'mkdir ./data' ) endif open ( unit = 62 , file = 'data/bulk_internal_energy_' // species // '.dat' , & action = \"write\" , status = \"replace\" ) do ct = tp1 , tp2 write ( 62 , \"(8e20.6)\" ) bulk_energy (:, ct ), internal_energy (:, ct ) enddo close ( 62 ) endif if ( myid == master ) then deallocate ( bulk_energy ) deallocate ( internal_energy ) endif end subroutine commit_analysis end program bulk_flow_energy","tags":"","loc":"sourcefile/bulk_internal_energy.f90.html","title":"bulk_internal_energy.f90 – Fortran Program"},{"text":"This module is to calculate 1D velocity distribution along a field line. We\n trace one field line first starting at one point. The particle 1D velocity\n distributions at each point along the field line is then calculated. Source Code !******************************************************************************* ! This module is to calculate 1D velocity distribution along a field line. We ! trace one field line first starting at one point. The particle 1D velocity ! distributions at each point along the field line is then calculated. !******************************************************************************* program vdist_1d_along_fieldline use mpi_module use constants , only : fp use particle_frames , only : nt use spectrum_config , only : nbins_vdist use particle_fieldline , only : init_analysis , end_analysis , & np , get_fieldline_points implicit none integer :: ct ! Current time frame ! The spectra at these points. real ( fp ), allocatable , dimension (:, :) :: vdist_para , vdist_perp real ( fp ) :: x0 , z0 ct = 10 call init_analysis ( ct ) x0 = 1.0 z0 = 6 0.0 call get_fieldline_points ( x0 , z0 ) nbins_vdist = 100 allocate ( vdist_para ( 2 * nbins_vdist , np )) allocate ( vdist_perp ( nbins_vdist , np )) vdist_para = 0.0 vdist_perp = 0.0 call calc_vdist_1d_fieldline ( 'e' ) deallocate ( vdist_para , vdist_perp ) call end_analysis contains !--------------------------------------------------------------------------- ! Calculate the velocity distributions along a line. ! Input: !   species: 'e' for electron; 'i' for ion. !--------------------------------------------------------------------------- subroutine calc_vdist_1d_fieldline ( species ) use spectrum_config , only : vmax , vmin , center , sizes use spectrum_config , only : set_spatial_range_de , & calc_velocity_interval , calc_pic_mpi_ids use velocity_distribution , only : fvel_para , fvel_perp , & init_vdist_1d_single , free_vdist_1d_single , & calc_vdist_1d_single , init_velocity_bins , free_velocity_bins , & set_vdist_1d_zero_single use fieldline_tracing , only : xarr , zarr use particle_frames , only : tinterval use particle_file , only : ratio_interval use particle_fieldline , only : startp , endp implicit none character ( len = 1 ), intent ( in ) :: species integer :: i vmax = 2.0 vmin = 0.0 call calc_velocity_interval call init_vdist_1d_single call init_velocity_bins sizes = [ 5.0 , 1.0 , 5.0 ] do i = startp , endp center = [ xarr ( i ), 0.0 , zarr ( i ) ] call set_spatial_range_de call calc_pic_mpi_ids call calc_vdist_1d_single ( ct * tinterval / ratio_interval , species ) vdist_para (:, i - startp + 1 ) = fvel_para vdist_perp (:, i - startp + 1 ) = fvel_perp call set_vdist_1d_zero_single end do if ( myid == master ) then call check_folder_exist endif call write_vdist_1d ( species ) call free_velocity_bins call free_vdist_1d_single end subroutine calc_vdist_1d_fieldline !--------------------------------------------------------------------------- ! Check if the folder for the data exist. If not, make one. !--------------------------------------------------------------------------- subroutine check_folder_exist implicit none logical :: dir_e dir_e = .false. inquire ( file = './data_vdist_1d/.' , exist = dir_e ) if ( .not. dir_e ) then call system ( 'mkdir ./data_vdist_1d' ) endif end subroutine check_folder_exist !--------------------------------------------------------------------------- ! Write the spectra data to file. !--------------------------------------------------------------------------- subroutine write_vdist_1d ( species ) use mpi_module use mpi_io_module , only : open_data_mpi_io , write_data_mpi_io use mpi_datatype_module , only : set_mpi_datatype use mpi_info_module , only : fileinfo use velocity_distribution , only : vbins_short , vbins_long use particle_fieldline , only : nptot , np , startp use spectrum_config , only : nbins_vdist implicit none character ( len = 1 ), intent ( in ) :: species integer , dimension ( 2 ) :: sizes_short , sizes_long integer , dimension ( 2 ) :: subsizes_short , subsizes_long integer , dimension ( 2 ) :: starts integer ( kind = MPI_OFFSET_KIND ) :: disp , offset character ( len = 150 ) :: fname integer :: datatype_short , datatype_long , fh integer :: pos1 , nbins nbins = nbins_vdist sizes_short ( 1 ) = nbins sizes_short ( 2 ) = nptot sizes_long ( 1 ) = 2 * nbins sizes_long ( 2 ) = nptot subsizes_short ( 1 ) = nbins subsizes_short ( 2 ) = np subsizes_long ( 1 ) = 2 * nbins subsizes_long ( 2 ) = np starts ( 1 ) = 0 starts ( 2 ) = startp datatype_short = set_mpi_datatype ( sizes_short , subsizes_short , starts ) datatype_long = set_mpi_datatype ( sizes_long , subsizes_long , starts ) fname = './data_vdist_1d/vdist_1d_fieldline_' // species // '.gda' ! Save nbins if ( myid == master ) then open ( unit = 41 , file = fname , access = 'stream' ,& status = 'unknown' , form = 'unformatted' , action = 'write' ) pos1 = 1 write ( 41 , pos = pos1 ) nbins , nptot pos1 = 2 * sizeof ( fp ) + pos1 write ( 41 , pos = pos1 ) vbins_short , vbins_long close ( 41 ) endif call MPI_BCAST ( pos1 , 1 , MPI_INTEGER , master , MPI_COMM_WORLD , ierr ) call open_data_mpi_io ( fname , MPI_MODE_WRONLY , fileinfo , fh ) ! Save 1D velocity distribution parallel to local field. disp = pos1 + 3 * sizeof ( fp ) * nbins - 1 offset = 0 call write_data_mpi_io ( fh , datatype_long , & subsizes_long , disp , offset , vdist_para ) ! Save 1D velocity distribution perpendicular to local field. disp = disp + sizeof ( fp ) * nbins * nptot * 2 call write_data_mpi_io ( fh , datatype_short , & subsizes_short , disp , offset , vdist_perp ) call MPI_FILE_CLOSE ( fh , ierror ) call MPI_TYPE_FREE ( datatype_short , ierror ) call MPI_TYPE_FREE ( datatype_long , ierror ) end subroutine write_vdist_1d end program vdist_1d_along_fieldline","tags":"","loc":"sourcefile/vdist_1d_along_fieldline.f90.html","title":"vdist_1d_along_fieldline.f90 – Fortran Program"},{"text":"Calculate the Agyrotropy.\n References:\n   Scudder, Jack, and William Daughton. \"“Illuminating” electron diffusion\n   regions of collisionless magnetic reconnection using electron agyrotropy.\"\n   Journal of Geophysical Research: Space Physics (1978–2012) 113.A6 (2008). Source Code !******************************************************************************* ! Calculate the Agyrotropy. ! References: !   Scudder, Jack, and William Daughton. \"âIlluminatingâ electron diffusion !   regions of collisionless magnetic reconnection using electron agyrotropy.\" !   Journal of Geophysical Research: Space Physics (1978â2012) 113.A6 (2008). !******************************************************************************* program calc_agyrotropy use mpi_module use constants , only : fp use pic_fields , only : bx , by , bz , absB , pxx , pxy , pxz , pyy , pyz , pzz use particle_info , only : species , ibtag , get_ptl_mass_charge use parameters , only : tp1 , tp2 use analysis_management , only : init_analysis , end_analysis use mpi_io_fields , only : save_field implicit none real ( fp ), allocatable , dimension (:, :, :) :: Nxx , Nxy , Nxz , Nyy , Nyz , Nzz real ( fp ), allocatable , dimension (:, :, :) :: bxn , byn , bzn real ( fp ), allocatable , dimension (:, :, :) :: alpha , beta , agyrotropy integer :: input_record , output_record species = 'e' ibtag = '00' call get_ptl_mass_charge ( species ) call init_analysis call init_pic_fields call open_pic_fields ( species ) call init_data if ( myid == master ) then print * , 'Calculating agyrotropy for ' , species endif do input_record = tp1 , 10 if ( myid == master ) print * , input_record output_record = input_record - tp1 + 1 call read_pic_fields ( input_record ) bxn = bx / absB byn = by / absB bzn = bz / absB Nxx = byn * byn * pzz - 2.0 * byn * bzn * pyz + bzn * bzn * pyy Nxy = - byn * bxn * pzz + byn * bzn * pxz + bzn * bxn * pyz - bzn * bzn * pxy Nxz = byn * bxn * pyz - byn * byn * pxz - bzn * bxn * pyy + bzn * byn * pxy Nyy = bxn * bxn * pzz - 2.0 * bxn * bzn * pxz + bzn * bzn * pxx Nyz = - bxn * bxn * pyz + bxn * byn * pxz + bzn * bxn * pxy - bzn * byn * pxx Nzz = bxn * bxn * pyy - 2.0 * bxn * byn * pxy + byn * byn * pxx alpha = Nxx + Nyy + Nzz beta = - ( Nxy ** 2 + Nxz ** 2 + Nyz ** 2 - Nxx * Nyy - Nxx * Nzz - Nyy * Nzz ) !agyrotropy = 2.0*sqrt(alpha**2-4.0*beta)/alpha agyrotropy = 4.0 * ( alpha ** 2 - 4.0 * beta ) / alpha ** 2 agyrotropy = sqrt ( agyrotropy ) where ( ISNAN ( agyrotropy )) agyrotropy = 0.0 end where call save_field ( agyrotropy , 'agyrotropy' , output_record ) enddo call free_data call free_pic_fields call close_pic_fields_file call end_analysis contains !--------------------------------------------------------------------------- ! Initializing the data array for this analysis. !--------------------------------------------------------------------------- subroutine init_data use mpi_topology , only : htg implicit none integer :: nx , ny , nz nx = htg % nx ny = htg % ny nz = htg % nz allocate ( Nxx ( nx , ny , nz )) allocate ( Nxy ( nx , ny , nz )) allocate ( Nxz ( nx , ny , nz )) allocate ( Nyy ( nx , ny , nz )) allocate ( Nyz ( nx , ny , nz )) allocate ( Nzz ( nx , ny , nz )) allocate ( bxn ( nx , ny , nz )) allocate ( byn ( nx , ny , nz )) allocate ( bzn ( nx , ny , nz )) allocate ( alpha ( nx , ny , nz )) allocate ( beta ( nx , ny , nz )) allocate ( agyrotropy ( nx , ny , nz )) Nxx = 0.0 ; Nxy = 0.0 ; Nxz = 0.0 Nyy = 0.0 ; Nyz = 0.0 ; Nzz = 0.0 bxn = 0.0 ; byn = 0.0 ; bzn = 0.0 alpha = 0.0 ; beta = 0.0 ; agyrotropy = 0.0 end subroutine init_data !--------------------------------------------------------------------------- ! Free the data array for this analysis. !--------------------------------------------------------------------------- subroutine free_data implicit none deallocate ( Nxx , Nxy , Nxz , Nyy , Nyz , Nzz ) deallocate ( bxn , byn , bzn , alpha , beta , agyrotropy ) end subroutine free_data !--------------------------------------------------------------------------- ! Initialize PIC fields. Not all PIC fields are required for this analysis. !--------------------------------------------------------------------------- subroutine init_pic_fields use mpi_topology , only : htg use pic_fields , only : init_magnetic_fields , init_pressure_tensor implicit none integer :: nx , ny , nz nx = htg % nx ny = htg % ny nz = htg % nz call init_magnetic_fields ( nx , ny , nz ) call init_pressure_tensor ( nx , ny , nz ) end subroutine init_pic_fields !--------------------------------------------------------------------------- ! Open PIC fields file collectively using MPI procedures. !--------------------------------------------------------------------------- subroutine open_pic_fields ( species ) use pic_fields , only : bfields_fh , pre_fh , open_magnetic_field_files , & open_pressure_tensor_files implicit none character ( * ), intent ( in ) :: species bfields_fh = 0 pre_fh = 0 call open_magnetic_field_files call open_pressure_tensor_files ( species ) end subroutine open_pic_fields !--------------------------------------------------------------------------- ! Read PIC simulation fields. ! Input: !   ct: current time point. !--------------------------------------------------------------------------- subroutine read_pic_fields ( ct ) use pic_fields , only : read_mangeitc_fields , read_pressure_tensor implicit none integer , intent ( in ) :: ct call read_mangeitc_fields ( ct ) call read_pressure_tensor ( ct ) end subroutine read_pic_fields !--------------------------------------------------------------------------- ! Close PIC fields file collectively using MPI procedures. !--------------------------------------------------------------------------- subroutine close_pic_fields_file use pic_fields , only : close_magnetic_field_files , & close_pressure_tensor_files implicit none call close_magnetic_field_files call close_pressure_tensor_files end subroutine close_pic_fields_file !--------------------------------------------------------------------------- ! Free the memory used by the PIC fields. !--------------------------------------------------------------------------- subroutine free_pic_fields use pic_fields , only : free_magnetic_fields , free_pressure_tensor implicit none call free_magnetic_fields call free_pressure_tensor end subroutine free_pic_fields end program calc_agyrotropy","tags":"","loc":"sourcefile/calc_agyrotropy.f90.html","title":"calc_agyrotropy.f90 – Fortran Program"},{"text":"Module for reading and writing HDF5 file in parallel Source Code !******************************************************************************* ! Module for reading and writing HDF5 file in parallel !******************************************************************************* program parallel_hdf5 use constants , only : fp , dp use analysis_management , only : init_analysis , end_analysis use mpi_module use hdf5 implicit none call init_analysis integer ( hid_t ) :: file_id integer ( hid_t ), allocatable , dimension (:) :: group_id , dset_id integer ( hid_t ) :: filespace , memspace , plist_id integer ( hsize_t ), allocatable , dimension (:) :: dset_dims , dcount , offset integer :: rank character ( len = 256 ) :: filename , groupname filename = \"../../../tracer/T.0/electron_tracer.h5p\" groupname = \"/Step#0\" call open_hdf5_parallel ( filename , groupname ) call end_analysis contains !--------------------------------------------------------------------------- ! Open hdf5 file in parallel !--------------------------------------------------------------------------- subroutine open_hdf5_parallel ( filename , groupname ) use mpi_info_module , only : fileinfo implicit none character ( * ), intent ( in ) :: filename , groupname integer :: error call h5open_f ( error ) call h5pcreate_f ( H5P_FILE_ACCESS_F , plist_id , error ) call h5pset_fapl_mpio_f ( plist_id , MPI_COMM_WORLD , info , error ) call h5fopen_f ( filename , H5F_ACC_RDWR_F , file_id , error , & access_prp = plist_id ) call h5pclose_f ( plist_id , error ) call h5fclose_f ( file_id , error ) end subroutine open_hdf5_parallel !--------------------------------------------------------------------------- ! Read hdf5 file in parallel !--------------------------------------------------------------------------- subroutine read_hdf5_parallel implicit none end subroutine read_hdf5_parallel end program parallel_hdf5","tags":"","loc":"sourcefile/parallel_hdf5.f90~2.html","title":"parallel_hdf5.f90 – Fortran Program"},{"text":"The main procedure to calculate jdote for different energy band. Source Code !******************************************************************************* ! The main procedure to calculate jdote for different energy band. !******************************************************************************* program compression use jdote_energy_band , only : read_config_jdote_eband implicit none call read_config_jdote_eband end program compression","tags":"","loc":"sourcefile/jdote_eband.f90.html","title":"jdote_eband.f90 – Fortran Program"},{"text":"The main procedure to calculate the compressional and shear heating terms. Source Code !******************************************************************************* ! The main procedure to calculate the compressional and shear heating terms. !******************************************************************************* program compression use particle_info , only : species , ibtag use analysis_management , only : init_analysis , end_analysis implicit none call init_analysis ibtag = '00' species = 'e' call commit_analysis species = 'i' call commit_analysis call end_analysis contains !--------------------------------------------------------------------------- ! Doing the analysis for one species. !--------------------------------------------------------------------------- subroutine commit_analysis use mpi_module use mpi_topology , only : htg use particle_info , only : species , ibtag , get_ptl_mass_charge use para_perp_pressure , only : init_para_perp_pressure , & free_para_perp_pressure , calc_para_perp_pressure use pic_fields , only : open_pic_fields , init_pic_fields , & free_pic_fields , close_pic_fields_file , & read_pic_fields use saving_flags , only : get_saving_flags use neighbors_module , only : init_neighbors , free_neighbors , get_neighbors use compression_shear , only : init_compression_shear , & free_compression_shear , calc_compression_shear , & save_compression_shear , save_tot_compression_shear use pressure_tensor , only : init_scalar_pressure , init_div_ptensor , & free_scalar_pressure , free_div_ptensor , calc_scalar_pressure , & calc_div_ptensor use parameters , only : tp1 , tp2 implicit none integer :: input_record , output_record call get_ptl_mass_charge ( species ) call init_pic_fields call init_para_perp_pressure call get_saving_flags call open_pic_fields ( species ) call init_neighbors ( htg % nx , htg % ny , htg % nz ) call get_neighbors call init_scalar_pressure call init_div_ptensor call init_compression_shear do input_record = tp1 , tp2 if ( myid == master ) print * , input_record output_record = input_record - tp1 + 1 call read_pic_fields ( input_record ) call calc_para_perp_pressure ( input_record ) call calc_scalar_pressure call calc_div_ptensor call calc_compression_shear call save_compression_shear ( input_record ) call save_tot_compression_shear ( input_record ) enddo call free_compression_shear call free_div_ptensor call free_scalar_pressure call free_neighbors call free_para_perp_pressure call free_pic_fields call close_pic_fields_file end subroutine commit_analysis end program compression","tags":"","loc":"sourcefile/compression.f90.html","title":"compression.f90 – Fortran Program"},{"text":"Get the total number of particles in each energy band. Source Code !******************************************************************************* ! Get the total number of particles in each energy band. !******************************************************************************* program particle_number_eband use mpi_module use constants , only : fp , dp use picinfo , only : domain use mpi_topology , only : htg use particle_info , only : species , ibtag , get_ptl_mass_charge use analysis_management , only : init_analysis , end_analysis use pic_fields , only : open_fraction_eband_file , init_fraction_eband , & free_fraction_eband , close_fraction_eband_file , & read_fraction_eband , eb use statistics , only : get_average_and_total use parameters , only : tp1 , tp2 implicit none character ( len = 150 ) :: fname integer , parameter :: nbands = 5 real ( dp ), allocatable , dimension (:, :) :: rho_band_sum real ( fp ) :: rho_band_tot , rho_band_avg character ( len = 20 ) :: format1 integer :: iband , ct call init_analysis species = 'e' call init_fraction_eband ( htg % nx , htg % ny , htg % nz ) if ( myid == master ) then allocate ( rho_band_sum ( tp2 - tp1 + 1 , nbands )) rho_band_sum = 0.0 endif do iband = 1 , nbands if ( myid == master ) print * , 'Energy band: ' , iband call open_fraction_eband_file ( species , iband ) do ct = tp1 , tp2 call read_fraction_eband ( ct ) call get_average_and_total ( eb , rho_band_avg , rho_band_tot ) rho_band_avg = rho_band_avg / ( domain % dx * domain % dy * domain % dx ) if ( myid == master ) then rho_band_sum ( ct - tp1 + 1 , iband ) = rho_band_avg endif end do call close_fraction_eband_file end do call MPI_BARRIER ( MPI_COMM_WORLD , ierror ) if ( myid == master ) then open ( unit = 62 , file = 'data/rho_eband_' // species // '.dat' , & action = \"write\" , status = \"replace\" ) do ct = tp1 , tp2 do iband = 1 , nbands write ( 62 , '(F14.6)' , advance = \"no\" ) rho_band_sum ( ct - tp1 + 1 , iband ) enddo write ( 62 , * ) enddo close ( 62 ) endif if ( myid == master ) then deallocate ( rho_band_sum ) endif call free_fraction_eband call end_analysis end program particle_number_eband","tags":"","loc":"sourcefile/particle_number_eband.f90.html","title":"particle_number_eband.f90 – Fortran Program"},{"text":"Main program. Source Code !******************************************************************************* ! Main program. !******************************************************************************* program vdistribution use mpi_module use path_info , only : get_file_paths use picinfo , only : read_domain , broadcast_pic_info , domain use particle_frames , only : get_particle_frames , nt , tinterval use spectrum_config , only : read_spectrum_config , set_spatial_range_de , & calc_pic_mpi_ids , tframe , init_pic_mpi_ranks , free_pic_mpi_ranks , & calc_pic_mpi_ranks , calc_velocity_interval use velocity_distribution , only : init_velocity_bins , free_velocity_bins , & init_vdist_2d , set_vdist_2d_zero , free_vdist_2d , init_vdist_1d , & set_vdist_1d_zero , free_vdist_1d , calc_vdist_2d , calc_vdist_1d use parameters , only : get_start_end_time_points , get_inductive_flag , & get_relativistic_flag use magnetic_field , only : init_magnetic_fields , free_magnetic_fields , & read_magnetic_fields use particle_info , only : species , get_ptl_mass_charge implicit none integer :: ct , ct_field , ratio_particle_field ! Initialize Message Passing call MPI_INIT ( ierr ) call MPI_COMM_RANK ( MPI_COMM_WORLD , myid , ierr ) call MPI_COMM_SIZE ( MPI_COMM_WORLD , numprocs , ierr ) call get_file_paths if ( myid == master ) then call get_particle_frames endif call MPI_BCAST ( nt , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( tinterval , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierr ) if ( myid == master ) then call read_domain endif call broadcast_pic_info call get_start_end_time_points call get_inductive_flag call get_relativistic_flag call read_spectrum_config call calc_velocity_interval call set_spatial_range_de call calc_pic_mpi_ids call init_pic_mpi_ranks call calc_pic_mpi_ranks call init_velocity_bins call init_vdist_2d call init_vdist_1d call init_magnetic_fields ! Ratio of particle output interval to fields output interval ratio_particle_field = domain % Particle_interval / domain % fields_interval ct_field = ratio_particle_field * tframe call read_magnetic_fields ( ct_field ) species = 'e' call get_ptl_mass_charge ( species ) call calc_vdist_2d ( tframe , 'e' ) call calc_vdist_1d ( tframe , 'e' ) call set_vdist_2d_zero call set_vdist_1d_zero species = 'i' call get_ptl_mass_charge ( species ) call calc_vdist_2d ( tframe , 'h' ) call calc_vdist_1d ( tframe , 'h' ) call free_magnetic_fields call free_vdist_1d call free_vdist_2d call free_velocity_bins call free_pic_mpi_ranks call MPI_FINALIZE ( ierr ) end program vdistribution","tags":"","loc":"sourcefile/vdistribution.f90.html","title":"vdistribution.f90 – Fortran Program"},{"text":"This module is to calculate 2D velocity distribution along a field line. We\n trace one field line first starting at one point. The particle 2D velocity\n distributions at each point along the field line is then calculated. Source Code !******************************************************************************* ! This module is to calculate 2D velocity distribution along a field line. We ! trace one field line first starting at one point. The particle 2D velocity ! distributions at each point along the field line is then calculated. !******************************************************************************* program vdist_2d_along_fieldline use mpi_module use constants , only : fp use particle_frames , only : nt use spectrum_config , only : nbins_vdist use particle_fieldline , only : init_analysis , end_analysis , & np , get_fieldline_points implicit none integer :: ct ! Current time frame ! The spectra at these points. real ( fp ), allocatable , dimension (:, :, :) :: vdist_2d ! Para and perp to B. real ( fp ), allocatable , dimension (:, :, :) :: vdist_xy , vdist_xz , vdist_yz real ( fp ) :: x0 , z0 ct = 10 call init_analysis ( ct ) x0 = 1.0 z0 = 6 0.0 call get_fieldline_points ( x0 , z0 ) nbins_vdist = 100 allocate ( vdist_2d ( 2 * nbins_vdist , nbins_vdist , np )) allocate ( vdist_xy ( 2 * nbins_vdist , 2 * nbins_vdist , np )) allocate ( vdist_xz ( 2 * nbins_vdist , 2 * nbins_vdist , np )) allocate ( vdist_yz ( 2 * nbins_vdist , 2 * nbins_vdist , np )) vdist_2d = 0.0 vdist_xy = 0.0 vdist_xz = 0.0 vdist_yz = 0.0 call calc_vdist_2d_fieldline ( 'e' ) deallocate ( vdist_2d , vdist_xy , vdist_xz , vdist_yz ) call end_analysis contains !--------------------------------------------------------------------------- ! Calculate the 2D velocity distributions along a line. ! Input: !   species: 'e' for electron; 'i' for ion. !--------------------------------------------------------------------------- subroutine calc_vdist_2d_fieldline ( species ) use spectrum_config , only : vmax , vmin , center , sizes use spectrum_config , only : set_spatial_range_de , & calc_velocity_interval , calc_pic_mpi_ids use velocity_distribution , only : fvel_2d , fvel_xy , fvel_xz , fvel_yz , & init_vdist_2d_single , free_vdist_2d_single , & calc_vdist_2d_single , init_velocity_bins , free_velocity_bins , & set_vdist_2d_zero_single use fieldline_tracing , only : xarr , zarr use particle_frames , only : tinterval use particle_file , only : ratio_interval use particle_fieldline , only : startp , endp implicit none character ( len = 1 ), intent ( in ) :: species integer :: i vmax = 2.0 vmin = 0.0 call calc_velocity_interval call init_vdist_2d_single call init_velocity_bins sizes = [ 5.0 , 1.0 , 5.0 ] do i = startp , endp center = [ xarr ( i ), 0.0 , zarr ( i ) ] call set_spatial_range_de call calc_pic_mpi_ids call calc_vdist_2d_single ( ct * tinterval / ratio_interval , species ) vdist_2d (:, :, i - startp + 1 ) = fvel_2d vdist_xy (:, :, i - startp + 1 ) = fvel_xy vdist_xz (:, :, i - startp + 1 ) = fvel_xz vdist_yz (:, :, i - startp + 1 ) = fvel_yz call set_vdist_2d_zero_single end do if ( myid == master ) then call check_folder_exist endif call write_vdist_2d ( species ) call free_velocity_bins call free_vdist_2d_single end subroutine calc_vdist_2d_fieldline !--------------------------------------------------------------------------- ! Check if the folder for the data exist. If not, make one. !--------------------------------------------------------------------------- subroutine check_folder_exist implicit none logical :: dir_e dir_e = .false. inquire ( file = './data_vdist_2d/.' , exist = dir_e ) if ( .not. dir_e ) then call system ( 'mkdir ./data_vdist_2d' ) endif end subroutine check_folder_exist !--------------------------------------------------------------------------- ! Write the spectra data to file. !--------------------------------------------------------------------------- subroutine write_vdist_2d ( species ) use mpi_module use mpi_io_module , only : open_data_mpi_io , write_data_mpi_io use mpi_datatype_module , only : set_mpi_datatype use mpi_info_module , only : fileinfo use velocity_distribution , only : vbins_short , vbins_long use particle_fieldline , only : nptot , np , startp use spectrum_config , only : nbins_vdist implicit none character ( len = 1 ), intent ( in ) :: species integer , dimension ( 3 ) :: sizes_short , sizes_long integer , dimension ( 3 ) :: subsizes_short , subsizes_long integer , dimension ( 3 ) :: starts integer ( kind = MPI_OFFSET_KIND ) :: disp , offset character ( len = 150 ) :: fname integer :: datatype_short , datatype_long , fh integer :: pos1 , nbins nbins = nbins_vdist sizes_short ( 1 ) = 2 * nbins sizes_short ( 2 ) = nbins sizes_short ( 3 ) = nptot sizes_long ( 1 ) = 2 * nbins sizes_long ( 2 ) = 2 * nbins sizes_long ( 3 ) = nptot subsizes_short ( 1 ) = 2 * nbins subsizes_short ( 2 ) = nbins subsizes_short ( 3 ) = np subsizes_long ( 1 ) = 2 * nbins subsizes_long ( 2 ) = 2 * nbins subsizes_long ( 3 ) = np starts ( 1 ) = 0 starts ( 2 ) = 0 starts ( 3 ) = startp datatype_short = set_mpi_datatype ( sizes_short , subsizes_short , starts ) datatype_long = set_mpi_datatype ( sizes_long , subsizes_long , starts ) fname = './data_vdist_2d/vdist_2d_fieldline_' // species // '.gda' ! Save nbins if ( myid == master ) then open ( unit = 41 , file = fname , access = 'stream' ,& status = 'unknown' , form = 'unformatted' , action = 'write' ) pos1 = 1 write ( 41 , pos = pos1 ) nbins , nptot pos1 = 2 * sizeof ( fp ) + pos1 write ( 41 , pos = pos1 ) vbins_short , vbins_long close ( 41 ) endif call MPI_BCAST ( pos1 , 1 , MPI_INTEGER , master , MPI_COMM_WORLD , ierr ) call open_data_mpi_io ( fname , MPI_MODE_WRONLY , fileinfo , fh ) ! Save 2D velocity distribution para and perp to local field. disp = pos1 + 3 * sizeof ( fp ) * nbins - 1 offset = 0 call write_data_mpi_io ( fh , datatype_short , & subsizes_short , disp , offset , vdist_2d ) ! Save 2D velocity distributions in xy, xz, yz plane. disp = disp + sizeof ( fp ) * nbins * nbins * nptot * 2 call write_data_mpi_io ( fh , datatype_long , & subsizes_long , disp , offset , vdist_xy ) disp = disp + sizeof ( fp ) * nbins * nbins * nptot * 4 call write_data_mpi_io ( fh , datatype_long , & subsizes_long , disp , offset , vdist_xz ) disp = disp + sizeof ( fp ) * nbins * nbins * nptot * 4 call write_data_mpi_io ( fh , datatype_long , & subsizes_long , disp , offset , vdist_yz ) call MPI_FILE_CLOSE ( fh , ierror ) call MPI_TYPE_FREE ( datatype_short , ierror ) call MPI_TYPE_FREE ( datatype_long , ierror ) end subroutine write_vdist_2d end program vdist_2d_along_fieldline","tags":"","loc":"sourcefile/vdist_2d_along_fieldline.f90.html","title":"vdist_2d_along_fieldline.f90 – Fortran Program"},{"text":"Parallel conversion; Using Bill's data type at LANL This code convert VPIC output into gda files, which are \"bricks\" of data Source Code !******************************************************************************* ! Parallel conversion; Using Bill's data type at LANL ! ! This code convert VPIC output into gda files, which are \"bricks\" of data ! !******************************************************************************* program translate use mpi_module use constants , only : dp use configuration_translate , only : tindex_start , tindex_stop use time_info , only : nout , output_record use emfields , only : read_emfields , write_emfields use particle_fields , only : read_particle_fields , set_current_density_zero , & calc_current_density , calc_absJ , write_current_densities , & adjust_particle_fields , write_particle_fields use path_info , only : rootpath implicit none integer :: tindex , tindex_new character ( len = 150 ) :: fname real ( dp ) :: mp_elapsed logical :: dfile call init_analysis mp_elapsed = MPI_WTIME () ! Loop over time slices dfile = .true. tindex = tindex_start do while ( dfile ) if ( myid == master ) print * , \" Time slice: \" , tindex ! EMF call read_emfields ( tindex ) call write_emfields ( tindex , output_record ) ! Particle fields call read_particle_fields ( tindex , 'e' ) call calc_current_density call adjust_particle_fields ( 'e' ) call write_particle_fields ( tindex , output_record , 'e' ) call read_particle_fields ( tindex , 'H' ) call calc_current_density call adjust_particle_fields ( 'H' ) call write_particle_fields ( tindex , output_record , 'i' ) call calc_absJ call write_current_densities ( tindex , output_record ) ! Avoid accumulation in calc_current_density call set_current_density_zero ! Might as well just wait here call MPI_BARRIER ( MPI_COMM_WORLD , ierror ) ! Check if there is another time slice to read dfile = .false. tindex_new = tindex + nout if ( tindex_new <= tindex_stop ) then write ( fname , \"(A,I0,A,I0,A)\" ) & trim ( adjustl ( rootpath )) // \"fields/T.\" , tindex_new , & \"/fields.\" , tindex_new , \".0\" inquire ( file = trim ( fname ), exist = dfile ) endif tindex = tindex_new if ( dfile ) output_record = output_record + 1 enddo mp_elapsed = MPI_WTIME () - mp_elapsed if ( myid == master ) then write ( * , '(A, F6.1)' ) \" Total time used (s): \" , mp_elapsed endif call end_analysis contains !--------------------------------------------------------------------------- ! Initialize the analysis. !--------------------------------------------------------------------------- subroutine init_analysis use mpi_module use path_info , only : get_file_paths use picinfo , only : read_domain , broadcast_pic_info , write_pic_info , & get_energy_band_number use configuration_translate , only : read_configuration use topology_translate , only : set_topology , set_start_stop_cells use time_info , only : get_nout , adjust_tindex_start , set_output_record use mpi_io_translate , only : set_mpi_io use emfields , only : init_emfields use particle_fields , only : init_particle_fields use parameters , only : get_relativistic_flag implicit none call MPI_INIT ( ierr ) call MPI_COMM_RANK ( MPI_COMM_WORLD , myid , ierr ) call MPI_COMM_SIZE ( MPI_COMM_WORLD , numprocs , ierr ) call get_file_paths if ( myid == master ) then call read_domain call write_pic_info endif call broadcast_pic_info call get_relativistic_flag call get_energy_band_number call read_configuration call set_topology call set_start_stop_cells call get_nout call adjust_tindex_start call set_output_record call set_mpi_io call init_emfields call init_particle_fields end subroutine init_analysis !--------------------------------------------------------------------------- ! End the analysis by free the memory. !--------------------------------------------------------------------------- subroutine end_analysis use mpi_module use topology_translate , only : free_start_stop_cells use mpi_io_translate , only : datatype use mpi_info_module , only : fileinfo use emfields , only : free_emfields use particle_fields , only : free_particle_fields implicit none call free_particle_fields call free_emfields call free_start_stop_cells call MPI_TYPE_FREE ( datatype , ierror ) call MPI_INFO_FREE ( fileinfo , ierror ) call MPI_FINALIZE ( ierr ) end subroutine end_analysis end program translate","tags":"","loc":"sourcefile/translate.f90.html","title":"translate.f90 – Fortran Program"},{"text":"Main program. Source Code !******************************************************************************* ! Main program. !******************************************************************************* program parspec use mpi_module use constants , only : dp use path_info , only : get_file_paths use picinfo , only : read_domain , broadcast_pic_info use particle_frames , only : get_particle_frames , nt , tinterval use spectrum_config , only : read_spectrum_config , set_spatial_range_de , & calc_pic_mpi_ids , tframe , init_pic_mpi_ranks , free_pic_mpi_ranks , & calc_pic_mpi_ranks use particle_energy_spectrum , only : init_energy_spectra , & free_energy_spectra , calc_energy_spectra , & set_energy_spectra_zero , init_maximum_energy , free_maximum_energy , & set_maximum_energy_zero , get_maximum_energy_global , & save_maximum_energy , init_emax_pic_mpi , free_emax_pic_mpi use particle_maximum_energy , only : distribute_pic_mpi , init_emax_array , & free_emax_array , set_emax_datatype , free_emax_datatype use parameters , only : get_start_end_time_points , get_inductive_flag , & get_relativistic_flag use commandline_arguments , only : get_cmdline_arguments , is_emax_cell use mpi_info_module , only : set_mpi_info implicit none integer :: ct real ( dp ) :: mp_elapsed ! Initialize Message Passing call MPI_INIT ( ierr ) call MPI_COMM_RANK ( MPI_COMM_WORLD , myid , ierr ) call MPI_COMM_SIZE ( MPI_COMM_WORLD , numprocs , ierr ) call get_cmdline_arguments call get_file_paths if ( myid == master ) then call get_particle_frames endif call MPI_BCAST ( nt , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( tinterval , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierr ) if ( myid == master ) then call read_domain endif call broadcast_pic_info call get_start_end_time_points call get_inductive_flag call get_relativistic_flag call read_spectrum_config call set_spatial_range_de call calc_pic_mpi_ids call init_pic_mpi_ranks call calc_pic_mpi_ranks call init_energy_spectra call init_maximum_energy ( nt ) ! Get the maximum energy in each cell if ( is_emax_cell ) then call distribute_pic_mpi call init_emax_array call set_emax_datatype call init_emax_pic_mpi call set_mpi_info endif mp_elapsed = MPI_WTIME () do ct = 1 , nt call calc_energy_spectra ( ct , 'e' ) call set_energy_spectra_zero enddo call get_maximum_energy_global ( nt ) if ( myid == master ) then call save_maximum_energy ( nt , 'e' ) endif call set_maximum_energy_zero do ct = 1 , nt call calc_energy_spectra ( ct , 'h' ) call set_energy_spectra_zero enddo call get_maximum_energy_global ( nt ) if ( myid == master ) then call save_maximum_energy ( nt , 'h' ) endif mp_elapsed = MPI_WTIME () - mp_elapsed if ( myid == master ) then write ( * , '(A, F6.1)' ) \" Total time used (s): \" , mp_elapsed endif if ( is_emax_cell ) then call free_emax_datatype call free_emax_pic_mpi call free_emax_array endif call free_pic_mpi_ranks call free_maximum_energy call free_energy_spectra call MPI_FINALIZE ( ierr ) end program parspec","tags":"","loc":"sourcefile/parspec.f90.html","title":"parspec.f90 – Fortran Program"},{"text":"Main program to get particle energy spectrum. The spectra are pre-calculated\n during PIC simulations for each MPI process. This program is going to sum\n over all the MPI processes to get the energy spectrum over the whole box. Source Code !******************************************************************************* ! Main program to get particle energy spectrum. The spectra are pre-calculated ! during PIC simulations for each MPI process. This program is going to sum ! over all the MPI processes to get the energy spectrum over the whole box. !******************************************************************************* program parspec_cpu_based use mpi_module use constants , only : fp , dp use path_info , only : get_file_paths use picinfo , only : read_domain , broadcast_pic_info use particle_frames , only : get_particle_frames_hydro , nt , tinterval use commandline_arguments , only : get_cmdline_arguments , is_emax_cell use mpi_info_module , only : set_mpi_info use particle_energy_spectrum , only : init_energy_spectra , & free_energy_spectra , set_energy_spectra_zero , & sum_spectra_over_mpi , save_particle_spectra , calc_energy_bins implicit none real ( dp ) :: mp_elapsed integer :: ct real ( fp ), allocatable , dimension (:) :: fcore ! Initialize Message Passing call MPI_INIT ( ierr ) call MPI_COMM_RANK ( MPI_COMM_WORLD , myid , ierr ) call MPI_COMM_SIZE ( MPI_COMM_WORLD , numprocs , ierr ) call get_cmdline_arguments call get_file_paths if ( myid == master ) then call get_particle_frames_hydro endif call MPI_BCAST ( nt , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( tinterval , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierr ) if ( myid == master ) then call read_domain endif call broadcast_pic_info call get_spectra_config call init_energy_spectra call calc_energy_bins call init_spectrum_one_core mp_elapsed = MPI_WTIME () do ct = 1 , nt if ( myid == master ) then print * , \"electron\" , ct endif call get_energy_spectrum ( ct , 'e' ) call sum_spectra_over_mpi if ( myid == master ) then call differentiate_spectrum endif if ( myid == master ) then call save_particle_spectra ( ct , 'e' ) endif call set_energy_spectra_zero enddo do ct = 1 , nt if ( myid == master ) then print * , \"ion\" , ct endif call get_energy_spectrum ( ct , 'h' ) call sum_spectra_over_mpi if ( myid == master ) then call differentiate_spectrum endif if ( myid == master ) then call save_particle_spectra ( ct , 'h' ) endif call set_energy_spectra_zero enddo mp_elapsed = MPI_WTIME () - mp_elapsed if ( myid == master ) then write ( * , '(A, F6.1)' ) \" Total time used (s): \" , mp_elapsed endif call free_spectrum_one_core call free_energy_spectra call MPI_FINALIZE ( ierr ) contains !--------------------------------------------------------------------------- ! Get the energy spectra configuration from energy.cxx !--------------------------------------------------------------------------- subroutine get_spectra_config use path_info , only : rootpath use read_config , only : get_variable use spectrum_config , only : nbins , emin , emax , dve , dlogve , & calc_energy_interval implicit none integer :: fh real ( fp ) :: tmp fh = 101 open ( unit = fh , file = trim ( rootpath ) // 'energy.cxx' , status = 'old' ) tmp = get_variable ( fh , 'int nbin' , '=' ) nbins = int ( tmp ) emin = get_variable ( fh , 'float eminp' , '=' ) emax = get_variable ( fh , 'float emaxp' , '=' ) close ( fh ) if ( myid == master ) then write ( * , \"(A,I0)\" ) \" Number of energy bins: \" , nbins write ( * , \"(A,E12.4,E12.4)\" ) \" Energy range: \" , emin , emax endif call calc_energy_interval end subroutine get_spectra_config !--------------------------------------------------------------------------- ! Get the energy spectra from one time frame. The spectra are saved for ! each MPI process of the PIC simulation. !--------------------------------------------------------------------------- subroutine get_energy_spectrum ( ct , species ) use particle_frames , only : is_frame0 , tinterval use path_info , only : rootpath use picinfo , only : domain use particle_energy_spectrum , only : flog implicit none integer , intent ( in ) :: ct character ( len = 1 ), intent ( in ) :: species character ( len = 256 ) :: fpath , dataset , fname character ( len = 16 ) :: cid , ctindex character ( len = 1 ) :: ptl integer :: np , fh , tindex , stat , access if ( species == 'e' ) then ptl = 'e' else ptl = 'H' endif if ( is_frame0 ) then ! The zeroth frame is saved tindex = ( ct - 1 ) * tinterval else tindex = ct * tinterval endif write ( ctindex , \"(I0)\" ) tindex fpath = trim ( rootpath ) // \"hydro/T.\" // trim ( ctindex ) // \"/\" ! Check whether the file can be accessed stat = access ( trim ( fpath ), 'r' ) fh = 201 if ( stat == 0 ) then do np = myid , domain % nproc - 1 , numprocs write ( cid , \"(I0)\" ) np dataset = trim ( fpath ) // \"spectrum-\" // ptl // \"hydro.\" fname = trim ( dataset ) // trim ( ctindex ) // \".\" // trim ( cid ) open ( unit = fh , file = trim ( fname ), status = 'unknown' , & form = 'unformatted' , access = 'stream' , action = 'read' ) ! print*, trim(fname) read ( fh ) fcore flog = flog + fcore close ( fh ) enddo endif end subroutine get_energy_spectrum !--------------------------------------------------------------------------- ! Initialize spectrum for one core. !--------------------------------------------------------------------------- subroutine init_spectrum_one_core use spectrum_config , only : nbins implicit none allocate ( fcore ( nbins )) fcore = 0.0 end subroutine init_spectrum_one_core !--------------------------------------------------------------------------- ! Free spectrum for one core. !--------------------------------------------------------------------------- subroutine free_spectrum_one_core implicit none deallocate ( fcore ) end subroutine free_spectrum_one_core !--------------------------------------------------------------------------- ! Differentiate the spectra w.r.t the energy. !--------------------------------------------------------------------------- subroutine differentiate_spectrum use spectrum_config , only : nbins use particle_energy_spectrum , only : ebins_log , flogsum implicit none integer :: i flogsum ( 1 ) = flogsum ( 1 ) / ebins_log ( 1 ) do i = 2 , nbins flogsum ( i ) = flogsum ( i ) / ( ebins_log ( i ) - ebins_log ( i - 1 )) enddo end subroutine differentiate_spectrum end program parspec_cpu_based","tags":"","loc":"sourcefile/parspec_cpu_based.f90.html","title":"parspec_cpu_based.f90 – Fortran Program"},{"text":"Main program to calculate particle spectrum in a user defined box. Source Code !******************************************************************************* ! Main program to calculate particle spectrum in a user defined box. !******************************************************************************* program particle_spectrum_box use mpi_module use constants , only : dp use path_info , only : get_file_paths use picinfo , only : read_domain , broadcast_pic_info use particle_frames , only : get_particle_frames , nt , tinterval use spectrum_config , only : read_spectrum_config , set_spatial_range_de , & calc_pic_mpi_ids , tframe , init_pic_mpi_ranks , free_pic_mpi_ranks , & calc_pic_mpi_ranks use particle_energy_spectrum , only : init_energy_spectra , & free_energy_spectra , calc_energy_spectra , & set_energy_spectra_zero use parameters , only : get_start_end_time_points , get_inductive_flag , & get_relativistic_flag implicit none integer :: ct real ( dp ) :: mp_elapsed ! Initialize Message Passing call MPI_INIT ( ierr ) call MPI_COMM_RANK ( MPI_COMM_WORLD , myid , ierr ) call MPI_COMM_SIZE ( MPI_COMM_WORLD , numprocs , ierr ) call get_file_paths if ( myid == master ) then call get_particle_frames endif call MPI_BCAST ( nt , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierr ) call MPI_BCAST ( tinterval , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierr ) if ( myid == master ) then call read_domain endif call broadcast_pic_info call get_start_end_time_points call get_inductive_flag call get_relativistic_flag call read_spectrum_config call set_spatial_range_de call calc_pic_mpi_ids call init_pic_mpi_ranks call calc_pic_mpi_ranks call init_energy_spectra mp_elapsed = MPI_WTIME () call calc_energy_spectra ( tframe , 'e' ) call set_energy_spectra_zero call calc_energy_spectra ( tframe , 'h' ) mp_elapsed = MPI_WTIME () - mp_elapsed if ( myid == master ) then write ( * , '(A, F6.1)' ) \" Total time used (s): \" , mp_elapsed endif call free_pic_mpi_ranks call free_energy_spectra call MPI_FINALIZE ( ierr ) end program particle_spectrum_box","tags":"","loc":"sourcefile/particle_spectrum_box.f90.html","title":"particle_spectrum_box.f90 – Fortran Program"},{"text":"This program is to calculate parallel potential due to parallel electric\n field.\n Reference:\n   Egedal, J., et al. \"Evidence and theory for trapped electrons in guide field\n   magnetotail reconnection.\" Journal of Geophysical Research: Space Physics\n   (1978–2012) 113.A12 (2008). Source Code !******************************************************************************* ! This program is to calculate parallel potential due to parallel electric ! field. ! Reference: !   Egedal, J., et al. \"Evidence and theory for trapped electrons in guide field !   magnetotail reconnection.\" Journal of Geophysical Research: Space Physics !   (1978â2012) 113.A12 (2008). !******************************************************************************* program parallel_potential use mpi_module use constants , only : fp use fieldline_tracing , only : init_fieldline_tracing , end_fieldline_tracing , & Cash_Karp_parameters , Dormand_Prince_parameters use analysis_management , only : init_analysis , end_analysis use magnetic_field , only : read_magnetic_fields use electric_field , only : init_electric_fields , read_electric_fields , & free_electric_fields implicit none real ( fp ), allocatable , dimension (:,:) :: phi_para integer :: nx_local , nx_offset , nx , nz integer :: ct call init_analysis call init_calculation call init_fieldline_tracing call init_electric_fields !call Cash_Karp_parameters call Dormand_Prince_parameters do ct = 30 , 30 if ( myid == master ) then print * , ct endif call read_electric_fields ( ct ) call read_magnetic_fields ( ct ) call calc_phi_parallel ( ct ) enddo call free_electric_fields call end_fieldline_tracing call end_calculation call MPI_BARRIER ( MPI_COMM_WORLD , ierror ) call end_analysis contains !--------------------------------------------------------------------------- ! Initialize the calculation by setting the domain information and ! initializing parallel potential. !--------------------------------------------------------------------------- subroutine init_calculation use mpi_module use picinfo , only : domain implicit none nx = domain % nx nz = domain % nz ! The whole domain is equally divided along the x-direction. nx_local = nx / numprocs nx_offset = nx_local * myid allocate ( phi_para ( nx_local , nz )) phi_para = 0.0 end subroutine init_calculation !--------------------------------------------------------------------------- ! Finish the calculation. !--------------------------------------------------------------------------- subroutine end_calculation use mpi_module implicit none deallocate ( phi_para ) end subroutine end_calculation !--------------------------------------------------------------------------- ! Calculate the parallel potential, which often appears in Jan Egedal's papers. ! phi_para is calculated for any point along the magnetic field fields to the ! simulation boundary. phi_para = \\int_\\vec{x}&#94;\\infty \\vec{E}\\cdot d\\vec{s}. ! Input: !   ct: current time frame. !--------------------------------------------------------------------------- subroutine calc_phi_parallel ( ct ) use mpi_module use constants , only : fp use fieldline_tracing , only : gdx , gdz implicit none integer , intent ( in ) :: ct integer :: i , k real ( fp ) :: x , z , h , hinit , phi_parallel1 , phi_parallel2 hinit = gdx phi_para = 0.0 do k = 1 , nz !print*, k do i = 1 , nx_local phi_parallel1 = 0.0 phi_parallel2 = 0.0 h = hinit x = ( nx_offset + i - 0.5 ) * gdx z = ( k - 1 ) * gdz call tracing ( x , z , h , phi_parallel1 , 1 ) ! Forward h = hinit x = ( nx_offset + i - 0.5 ) * gdx z = ( k - 1 ) * gdz call tracing ( x , z , h , phi_parallel2 , - 1 ) ! Backward phi_para ( i , k ) = ( phi_parallel1 + phi_parallel2 ) * 0.5 enddo ! x loop enddo ! z loop call MPI_BARRIER ( MPI_COMM_WORLD , ierror ) ! print*, \"__________________\", myid call save_phi_parallel ( ct ) end subroutine calc_phi_parallel !--------------------------------------------------------------------------- ! Trace the magnetic field starting at one point and accumulate to get ! the parallel potential at the same time. ! Inputs: !   htry: the first-try step size. ! Inputs & Outputs: !   x, z: the coordinates of current point. !   phi_parallel: parallel potential at current point. !   direction_flag: 1 for forward, -1 for backward to the local B field. !--------------------------------------------------------------------------- subroutine tracing ( x , z , htry , phi_parallel , direction_flag ) use fieldline_tracing , only : push , derivs , get_crossing_point , & controller , Cash_Karp_parameters , Dormand_Prince_parameters , & lx , lz , gdx , hmax implicit none real ( fp ), intent ( inout ) :: x , z , phi_parallel real ( fp ), intent ( in ) :: htry integer , intent ( in ) :: direction_flag real ( fp ), dimension ( 0 : 6 ) :: kx , ky , kz real ( fp ) :: arc_length , xout , zout , xold , zold real ( fp ) :: dxds , dyds , dzds , dxdsnew , dydsnew , dzdsnew real ( fp ) :: xcross , zcross real ( fp ) :: h , hnext , errold , h_old logical :: is_accept phi_parallel = 0.0 arc_length = 0.0 h = htry h_old = h errold = 1.0e-4 is_accept = .false. call derivs ( x , z , direction_flag , dxds , dyds , dzds ) do while ( x > 0 .and. x < lx .and. z > 0 .and. z < lz .and. & arc_length < 2 * lx ) call push ( dxds , dyds , dzds , direction_flag , x , z , h , kx , ky , kz , & xout , zout , dxdsnew , dydsnew , dzdsnew ) call controller ( h , hmax , hnext , x , z , xout , zout , & kx , kz , is_accept , errold ) if ( is_accept ) then arc_length = arc_length + h xold = x zold = z x = xout z = zout dxds = dxdsnew dyds = dydsnew dzds = dzdsnew call update_phi_parallel ( xold , zold , kx , ky , kz , h , phi_parallel ) h_old = h h = hnext endif enddo ! while loop ! Make sure it integrates to the boundary. if ( x < 0 .or. x > lx .or. z < 0 .or. z > lz ) then ! This excludes the closed field inside the domain. arc_length = arc_length - h_old xcross = 0.0 zcross = 0.0 call get_crossing_point ( x , z , xold , zold , lx , lz , xcross , zcross ) h = sqrt (( xcross - xold ) ** 2 + ( zcross - zold ) ** 2 ) arc_length = arc_length + h call push ( dxds , dyds , dzds , direction_flag , x , z , h , kx , ky , kz , & xout , zout , dxdsnew , dydsnew , dzdsnew ) call update_phi_parallel ( xold , zold , kx , ky , kz , h , phi_parallel ) endif ! Exclude the closed field lines if ( arc_length > ( 2 * lx - 1 0.0 )) then phi_parallel = 0.0 endif end subroutine tracing !--------------------------------------------------------------------------- ! Update parallel potential. ! Input: !   xold, zold: the starting point of current step. !   kx, ky, kz: the derivatives (actually the direction of the field) !   h: the step size. ! Input and Output: !   phi_parallel: current parallel potential to be updated. !--------------------------------------------------------------------------- subroutine update_phi_parallel ( xold , zold , kx , ky , kz , h , phi_parallel ) use constants , only : fp use fieldline_tracing , only : b , c , gdx , gdz use electric_field , only : get_electric_field_at_point , ex0 , ey0 , ez0 implicit none real ( fp ), intent ( in ), dimension ( 0 : 6 ) :: kx , ky , kz real ( fp ), intent ( in ) :: xold , zold , h real ( fp ), intent ( inout ) :: phi_parallel real ( fp ), dimension ( 0 : 6 ) :: exs , eys , ezs real ( fp ) :: xtemp , ztemp integer :: i call get_electric_field_at_point ( xold , zold , gdx , gdz ) exs ( 0 ) = ex0","tags":"","loc":"sourcefile/parallel_potential.f90.html","title":"parallel_potential.f90 – Fortran Program"},{"text":"This module is to calculate particle energy spectrum along a field line.\n We trace one field line first starting at one point. The particle energy\n spectrum at each point along the field line is then calculated. Source Code !******************************************************************************* ! This module is to calculate particle energy spectrum along a field line. ! We trace one field line first starting at one point. The particle energy ! spectrum at each point along the field line is then calculated. !******************************************************************************* program spectrum_along_fieldline use mpi_module use constants , only : fp use particle_frames , only : nt use spectrum_config , only : nbins use particle_fieldline , only : init_analysis , end_analysis , & np , get_fieldline_points implicit none integer :: ct ! Current time frame ! The spectra at these points. real ( fp ), allocatable , dimension (:, :) :: flog_np , flin_np real ( fp ) :: x0 , z0 ct = 10 call init_analysis ( ct ) x0 = 1.0 z0 = 6 0.0 call get_fieldline_points ( x0 , z0 ) nbins = 100 allocate ( flin_np ( nbins , np )) allocate ( flog_np ( nbins , np )) flin_np = 0.0 flog_np = 0.0 call calc_particle_energy_spectrum ( 'e' ) deallocate ( flin_np , flog_np ) call end_analysis contains !--------------------------------------------------------------------------- ! Calculate the particle energy spectrum along a line. ! Input: !   species: 'e' for electron; 'i' for ion. !--------------------------------------------------------------------------- subroutine calc_particle_energy_spectrum ( species ) use spectrum_config , only : emax , emin , center , sizes use spectrum_config , only : set_spatial_range_de , & calc_energy_interval , calc_pic_mpi_ids use particle_energy_spectrum , only : init_energy_spectra_single , & free_energy_spectra_single , calc_energy_spectrum_single , & calc_energy_bins , set_energy_spectra_zero_single , f , flog use fieldline_tracing , only : xarr , zarr use particle_frames , only : tinterval use particle_file , only : ratio_interval use particle_fieldline , only : startp , endp implicit none character ( len = 1 ), intent ( in ) :: species integer :: i emax = 1.0E2 emin = 1.0E-4 call calc_energy_interval call init_energy_spectra_single call calc_energy_bins sizes = [ 5.0 , 1.0 , 5.0 ] do i = startp , endp center = [ xarr ( i ), 0.0 , zarr ( i ) ] call set_spatial_range_de call calc_pic_mpi_ids call calc_energy_spectrum_single ( ct * tinterval / ratio_interval , species ) flin_np (:, i - startp + 1 ) = f flog_np (:, i - startp + 1 ) = flog call set_energy_spectra_zero_single end do ! Save the spectrum to file. if ( myid == master ) then call check_folder_exist endif call write_particle_spectrum ( species ) call free_energy_spectra_single end subroutine calc_particle_energy_spectrum !--------------------------------------------------------------------------- ! Check if the folder for the data exist. If not, make one. !--------------------------------------------------------------------------- subroutine check_folder_exist implicit none logical :: dir_e dir_e = .false. inquire ( file = './data_double_layer/.' , exist = dir_e ) if ( .not. dir_e ) then call system ( 'mkdir ./data_double_layer' ) endif end subroutine check_folder_exist !--------------------------------------------------------------------------- ! Write the spectra data to file. !--------------------------------------------------------------------------- subroutine write_particle_spectrum ( species ) use mpi_module use mpi_io_module , only : open_data_mpi_io , write_data_mpi_io use mpi_datatype_module , only : set_mpi_datatype use mpi_info_module , only : fileinfo use particle_energy_spectrum , only : ebins_lin , ebins_log use particle_fieldline , only : nptot , np , startp implicit none character ( len = 1 ), intent ( in ) :: species integer , dimension ( 2 ) :: sizes , subsizes , starts integer ( kind = MPI_OFFSET_KIND ) :: disp , offset character ( len = 150 ) :: fname integer :: datatype , fh integer :: pos1 sizes ( 1 ) = nbins sizes ( 2 ) = nptot subsizes ( 1 ) = nbins subsizes ( 2 ) = np starts ( 1 ) = 0 starts ( 2 ) = startp datatype = set_mpi_datatype ( sizes , subsizes , starts ) fname = './data_double_layer/spect_fieldline_' // species // '.gda' ! Save nbins, npoints, ebins_lin, ebins_log if ( myid == master ) then open ( unit = 41 , file = fname , access = 'stream' ,& status = 'unknown' , form = 'unformatted' , action = 'write' ) pos1 = 1 write ( 41 , pos = pos1 ) nbins , nptot pos1 = 2 * sizeof ( fp ) + pos1 write ( 41 , pos = pos1 ) ebins_lin , ebins_log close ( 41 ) endif call MPI_BCAST ( pos1 , 1 , MPI_INTEGER , master , MPI_COMM_WORLD , ierr ) call open_data_mpi_io ( fname , MPI_MODE_WRONLY , fileinfo , fh ) ! Save spectrum with linear bins disp = pos1 + 2 * sizeof ( fp ) * nbins - 1 offset = 0 call write_data_mpi_io ( fh , datatype , subsizes , disp , offset , flin_np ) ! Save spectrum with logarithmic bins. disp = disp + sizeof ( fp ) * nbins * nptot offset = 0 call write_data_mpi_io ( fh , datatype , subsizes , disp , offset , flin_np ) call MPI_FILE_CLOSE ( fh , ierror ) call MPI_TYPE_FREE ( datatype , ierror ) end subroutine write_particle_spectrum end program spectrum_along_fieldline","tags":"","loc":"sourcefile/spectrum_along_fieldline.f90.html","title":"spectrum_along_fieldline.f90 – Fortran Program"},{"text":"Source Code ! ! To compile: ! !   Pre-processor now required: !   /opt/local/bin/gfortran-mp-4.8 -cpp kinds.f90 cla.f90 cla_test.f90 -o cla_test ! ! To run: !   ./cla_test -h                             : -h is a command line flag !   ./cla_test --jello 999                    : --jello is long form key, matched with value 999 !   ./cla_test --jello=999                    : --jello is long form key, matched with value 999, alternate syntax !   ./cla_test -j 999                         : -j is short form key, matched with value 999 ! ! Copyright (c) 2015 Edward D. Zaron, Portland, Oregon, USA ! ! Permission is hereby granted, free of charge, to any person obtaining a copy of this ! software and associated documentation files (the \"Software\"), to deal in the Software ! without restriction, including without limitation the rights to use, copy, modify, merge, ! publish, distribute, sublicense, and/or sell copies of the Software, and to permit ! persons to whom the Software is furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in all copies or ! substantial portions of the Software. ! ! Except as contained in this notice, the name(s) of the above copyright holders shall not ! be used in advertising or otherwise to promote the sale, use or other dealings in this ! Software without prior written authorization. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, ! INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR ! PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE ! FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR ! OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER ! DEALINGS IN THE SOFTWARE. ! program cla_test use kinds use cla implicit none character ( len = STRLEN ) :: key character ( len = XSTRLEN ) :: description integer ( kind = int_kind ) :: kkind character ( len = STRLEN ) :: default integer ( kind = int_kind ) :: i integer ( kind = 8 ) :: j , jello real ( kind = real_kind ) :: x real ( kind = 4 ) :: y4 real ( kind = 8 ) :: y8 , arg4 character ( len = STRLEN ) :: a !character(len=XSTRLEN) :: b logical :: l , ll , arg1 , f , s character ( len = STRLEN ) :: arg2 , arg3 ! Test using command line arguments: call cla_init !    ! Test using values supplied in a string: !    call cla_init(trim('f  edztest_pos2 edztest_pos3 9.626   -j 999 --integer   9 -f')) ! Register your keys for key/value pairs. ! EACH KEY MUST BEGIN WITH - ! (long form, maybe more readable) key = '-i' description = 'an integer parameter' kkind = cla_int default = '0' call cla_register ( key , '--integer' , description , kkind , default ) ! (compact form) call cla_register ( '-j' , '--jello' , 'another int' , cla_int , '72' ) call cla_register ( '-x' , '--xcrypt' , 'real' , cla_float , '3.14159' ) call cla_register ( '-y' , '-yellow' , 'a real for testing r4, r8' , cla_float , '3.14159' ) call cla_register ( '-a' , '--author' , 'str' , cla_char , 'Ed Zaron' ) call cla_register ( '-f' , '--theflag' , 'a flag' , cla_flag , 'f' ) call cla_register ( '-s' , '--second' , 'another flag' , cla_flag , 'f' ) call cla_register ( '-l' , '--logical' , 'bool' , cla_logical , 't' ) ! Register positional parameters in the order they appear on the ! command line. call cla_posarg_register ( 'arg1' , 'first positional' , cla_logical , 't' ) call cla_posarg_register ( 'arg2' , 'second positional' , cla_char , 'Eli S' ) call cla_posarg_register ( 'arg3' , 'third positional' , cla_char , 'posthree' ) call cla_posarg_register ( 'arg4' , 'fourth positional' , cla_float , '3.14159265358' ) ! These can be called in any order: print * , '*********************************************************' print * , 'Calling cla_help:' call cla_help ( \"cla_test\" ) print * , '-------> Returned from cla_help.' print * , '*********************************************************' print * , '*********************************************************' print * , 'Calling cla_show:' call cla_show print * , '-------> Returned from cla_show.' print * , '*********************************************************' print * , '*********************************************************' print * , 'Calling cla_validate:' call cla_validate ( \"cla_test\" ) print * , '-------> Returned from cla_validate.' print * , '*********************************************************' ! Test to see if the --jello key is present using short and long key: ll = cla_key_present ( '--jello' ) if ( ll ) then print * , ' --jello is present' else print * , ' --jello is not present' endif ll = cla_key_present ( '-j' ) if ( ll ) then print * , ' -j is present' else print * , ' -j is not present' endif ! Test to see if the -f flag is present: ll = cla_key_present ( '-f' ) if ( ll ) then print * , ' -f is present' else print * , ' -f is not present' endif ll = cla_key_present ( '-s' ) if ( ll ) then print * , ' -s is present' else print * , ' -s is not present' endif print * , \"***********************\" ! Get values: call cla_get ( '-i' , i ) call cla_get ( '-j' , j ) call cla_get ( '--jello' , jello ) call cla_get ( '-x' , x ) call cla_get ( '-y' , y4 ) call cla_get ( '-y' , y8 ) call cla_get ( '-a' , a ) !    call cla_get_xchar('-b',b) ! Looks like extended character strings not implemented. call cla_get ( '-l' , l ) call cla_get ( '-f' , f ) call cla_get ( '-s' , s ) print * , \"***********************\" ! Code crashes if no positional arguments are present --> fixed print * , \"Get positional arguments\" call cla_get ( 'arg1' , arg1 ) call cla_get ( 'arg2' , arg2 ) call cla_get ( 'arg3' , arg3 ) call cla_get ( 'arg4' , arg4 ) print * , \"***********************\" print * , 'After processing command line arguments:' print * , ' i     = ' , i print * , ' j     = ' , j , ' should equal jello:' print * , ' jello = ' , jello print * , ' x     = ' , x print * , ' y (r4)= ' , y4 print * , ' y (r8)= ' , y8 print * , ' a     = ' , trim ( a ) print * , ' l     = ' , l print * , ' f     = ' , f print * , ' s     = ' , s print * , ' arg1  = ' , arg1 print * , ' arg2  = ' , arg2 print * , ' arg3  = ' , arg3 print * , ' arg4  = ' , arg4 end program cla_test","tags":"","loc":"sourcefile/cla_test.f90.html","title":"cla_test.f90 – Fortran Program"},{"text":"Main program for particle based drift analysis Source Code !******************************************************************************* ! Main program for particle based drift analysis !******************************************************************************* program particle_based_jdote use mpi_module use constants , only : dp use particle_info , only : species implicit none integer :: ct real ( dp ) :: mp_elapsed ct = 1 species = 'e' call init_analysis call commit_analysis call end_analysis ! call MPI_BARRIER(MPI_COMM_WORLD, ierror) ! species = 'i' ! call init_analysis ! call commit_analysis ! call end_analysis contains !--------------------------------------------------------------------------- ! Initialize the analysis. !--------------------------------------------------------------------------- subroutine init_analysis use mpi_module use particle_info , only : species , get_ptl_mass_charge use path_info , only : get_file_paths use picinfo , only : read_domain , broadcast_pic_info , & get_total_time_frames , get_energy_band_number , & read_thermal_params , calc_energy_interval , nbands , & write_pic_info , domain use configuration_translate , only : read_configuration use topology_translate , only : set_topology , set_start_stop_cells use time_info , only : get_nout , adjust_tindex_start , set_output_record use mpi_io_translate , only : set_mpi_io use parameters , only : get_relativistic_flag , get_start_end_time_points , tp2 use interpolation_emf , only : init_emfields , init_emfields_derivatives use particle_drift , only : init_drift_fields , init_para_perp_fields , & init_jdote_sum use neighbors_module , only : init_neighbors , get_neighbors use particle_fields , only : init_density_fields implicit none integer :: nx , ny , nz call MPI_INIT ( ierr ) call MPI_COMM_RANK ( MPI_COMM_WORLD , myid , ierr ) call MPI_COMM_SIZE ( MPI_COMM_WORLD , numprocs , ierr ) call get_ptl_mass_charge ( species ) call get_file_paths if ( myid == master ) then call read_domain call write_pic_info endif call broadcast_pic_info call get_start_end_time_points call get_relativistic_flag call get_energy_band_number call read_thermal_params if ( nbands > 0 ) then call calc_energy_interval endif call read_configuration call get_total_time_frames ( tp2 ) call set_topology call set_start_stop_cells call get_nout call adjust_tindex_start call set_output_record call set_mpi_io nx = domain % pic_nx + 2 ! Including ghost cells ny = domain % pic_ny + 2 nz = domain % pic_nz + 2 call init_neighbors ( nx , ny , nz ) call get_neighbors call init_density_fields call init_emfields call init_emfields_derivatives call init_drift_fields call init_para_perp_fields call init_jdote_sum end subroutine init_analysis !--------------------------------------------------------------------------- ! This subroutine does the analysis. !--------------------------------------------------------------------------- subroutine commit_analysis use mpi_module use constants , only : dp use configuration_translate , only : tindex_start , tindex_stop use time_info , only : nout , output_record use path_info , only : rootpath use particle_drift , only : save_jdote_sum use picinfo , only : domain implicit none integer :: tindex , tindex_new , ct character ( len = 150 ) :: fname real ( dp ) :: mp_elapsed logical :: dfile mp_elapsed = MPI_WTIME () ! Loop over time slices dfile = .true. tindex = domain % particle_interval ct = 1 do while ( dfile ) if ( myid == master ) print * , \" Time slice: \" , tindex call analysis_single_frame ( tindex , ct , output_record ) ! Might as well just wait here call MPI_BARRIER ( MPI_COMM_WORLD , ierror ) ! Check if there is another time slice to read dfile = .false. tindex_new = tindex + domain % particle_interval if ( tindex_new <= tindex_stop ) then ! if (tindex_new <= 5000) then write ( fname , \"(A,I0,A,I0,A)\" ) & trim ( adjustl ( rootpath )) // \"fields/T.\" , tindex_new , & \"/fields.\" , tindex_new , \".0\" inquire ( file = trim ( fname ), exist = dfile ) else dfile = .false. endif tindex = tindex_new if ( dfile ) then output_record = output_record + 1 ct = ct + 1 endif enddo call save_jdote_sum mp_elapsed = MPI_WTIME () - mp_elapsed if ( myid == master ) then write ( * , '(A, F6.1)' ) \" Total time used (s): \" , mp_elapsed endif end subroutine commit_analysis !--------------------------------------------------------------------------- ! For one time frame. ! Input: !   tindex0: the time step index. !   ct: current time frame. !   output_record: the record number for data output. !--------------------------------------------------------------------------- subroutine analysis_single_frame ( tindex0 , ct , output_record ) use particle_info , only : species use interpolation_emf , only : read_emfields_single , & calc_emfields_derivatives use particle_drift , only : calc_particle_energy_change_rate , & set_drift_fields_zero , set_para_perp_fields_zero , & sum_data_arrays , save_data_arrays use rank_index_mapping , only : index_to_rank use picinfo , only : domain use topology_translate , only : ht use particle_fields , only : read_density_fields_single implicit none integer , intent ( in ) :: tindex0 , ct , output_record integer :: dom_x , dom_y , dom_z , n integer :: ix , iy , iz do dom_x = ht % start_x , ht % stop_x ix = ( dom_x - ht % start_x ) * domain % pic_nx do dom_y = ht % start_y , ht % stop_y iy = ( dom_y - ht % start_y ) * domain % pic_ny do dom_z = ht % start_z , ht % stop_z iz = ( dom_z - ht % start_z ) * domain % pic_nz call index_to_rank ( dom_x , dom_y , dom_z , domain % pic_tx , & domain % pic_ty , domain % pic_tz , n ) call read_emfields_single ( tindex0 , n - 1 ) call calc_emfields_derivatives call read_density_fields_single ( tindex0 , n - 1 , species ) call calc_particle_energy_change_rate ( tindex0 , species , & n - 1 , ix , iy , iz ) enddo ! x enddo ! y enddo ! z call sum_data_arrays ( ct ) call save_data_arrays ( tindex0 , output_record ) call set_drift_fields_zero call set_para_perp_fields_zero end subroutine analysis_single_frame !--------------------------------------------------------------------------- ! End the analysis by free the memory. !--------------------------------------------------------------------------- subroutine end_analysis use mpi_module use topology_translate , only : free_start_stop_cells use mpi_io_translate , only : datatype use mpi_info_module , only : fileinfo use interpolation_emf , only : free_emfields , free_emfields_derivatives use particle_drift , only : free_drift_fields , free_para_perp_fields , & free_jdote_sum use neighbors_module , only : free_neighbors use particle_fields , only : free_density_fields implicit none call free_neighbors call free_jdote_sum call free_para_perp_fields call free_drift_fields call free_emfields_derivatives call free_emfields call free_density_fields call free_start_stop_cells call MPI_TYPE_FREE ( datatype , ierror ) call MPI_INFO_FREE ( fileinfo , ierror ) call MPI_FINALIZE ( ierr ) end subroutine end_analysis end program particle_based_jdote","tags":"","loc":"sourcefile/particle_based_jdote.f90.html","title":"particle_based_jdote.f90 – Fortran Program"},{"text":"type, public :: picdomain Components Type Visibility Attributes Name Initial real(kind=dp), public :: dx real(kind=dp), public :: dy real(kind=dp), public :: dz real(kind=dp), public :: idx real(kind=dp), public :: idy real(kind=dp), public :: idz real(kind=dp), public :: idxh real(kind=dp), public :: idyh real(kind=dp), public :: idzh real(kind=fp), public :: lx_de real(kind=fp), public :: ly_de real(kind=fp), public :: lz_de real(kind=fp), public :: dtwpe real(kind=fp), public :: dtwce real(kind=fp), public :: dtwpi real(kind=fp), public :: dtwci real(kind=fp), public :: dt real(kind=fp), public :: idt integer, public :: energies_interval integer, public :: fields_interval integer, public :: hydro_interval integer, public :: particle_interval integer, public :: nx integer, public :: ny integer, public :: nz integer, public :: pic_tx integer, public :: pic_ty integer, public :: pic_tz integer, public :: pic_nx integer, public :: pic_ny integer, public :: pic_nz integer, public :: nppc integer, public :: nproc","tags":"","loc":"type/picdomain.html","title":"picdomain – Fortran Program "},{"text":"type, public :: ht_type Components Type Visibility Attributes Name Initial integer, public :: tx integer, public :: ty integer, public :: tz integer, public :: nx integer, public :: ny integer, public :: nz integer, public :: start_x integer, public :: start_y integer, public :: start_z integer, public :: stop_x integer, public :: stop_y integer, public :: stop_z integer, public :: ix integer, public :: iy integer, public :: iz","tags":"","loc":"type/ht_type.html","title":"ht_type – Fortran Program "},{"text":"subroutine particle_spectrum_vdist_box() Uses: particle_spectrum_vdist_module Arguments None","tags":"","loc":"proc/particle_spectrum_vdist_box.html","title":"particle_spectrum_vdist_box – Fortran Program"},{"text":"public subroutine read_spectrum_config() Uses: mpi_module read_config Arguments None Variables Type Visibility Attributes Name Initial integer, public :: fh real(kind=fp), public :: temp","tags":"","loc":"proc/read_spectrum_config.html","title":"read_spectrum_config – Fortran Program"},{"text":"public subroutine calc_energy_interval() Arguments None","tags":"","loc":"proc/calc_energy_interval.html","title":"calc_energy_interval – Fortran Program"},{"text":"public subroutine calc_velocity_interval() Arguments None","tags":"","loc":"proc/calc_velocity_interval.html","title":"calc_velocity_interval – Fortran Program"},{"text":"public subroutine init_pic_mpi_ranks() Arguments None","tags":"","loc":"proc/init_pic_mpi_ranks.html","title":"init_pic_mpi_ranks – Fortran Program"},{"text":"public subroutine calc_pic_mpi_ranks() Uses: picinfo Arguments None Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: k integer, public :: tx integer, public :: ty integer, public :: tz integer, public :: index1","tags":"","loc":"proc/calc_pic_mpi_ranks.html","title":"calc_pic_mpi_ranks – Fortran Program"},{"text":"public subroutine free_pic_mpi_ranks() Arguments None","tags":"","loc":"proc/free_pic_mpi_ranks.html","title":"free_pic_mpi_ranks – Fortran Program"},{"text":"public subroutine set_spatial_range_de() Uses: picinfo Arguments None Variables Type Visibility Attributes Name Initial real(kind=fp), public :: dx real(kind=fp), public :: dy real(kind=fp), public :: dz real(kind=fp), public :: lx real(kind=fp), public :: ly real(kind=fp), public :: lz","tags":"","loc":"proc/set_spatial_range_de.html","title":"set_spatial_range_de – Fortran Program"},{"text":"public subroutine calc_pic_mpi_ids() Uses: picinfo Arguments None Variables Type Visibility Attributes Name Initial real(kind=dp), public :: cx real(kind=dp), public :: cy real(kind=dp), public :: cz","tags":"","loc":"proc/calc_pic_mpi_ids.html","title":"calc_pic_mpi_ids – Fortran Program"},{"text":"public subroutine init_jdote() Uses: mpi_topology Arguments None","tags":"","loc":"proc/init_jdote.html","title":"init_jdote – Fortran Program"},{"text":"public subroutine init_jdote_total() Uses: parameters Arguments None","tags":"","loc":"proc/init_jdote_total.html","title":"init_jdote_total – Fortran Program"},{"text":"public subroutine free_jdote() Arguments None","tags":"","loc":"proc/free_jdote.html","title":"free_jdote – Fortran Program"},{"text":"public subroutine free_jdote_total() Arguments None","tags":"","loc":"proc/free_jdote_total.html","title":"free_jdote_total – Fortran Program"},{"text":"public subroutine save_jdote_total() Uses: constants parameters parameters particle_info Arguments None Variables Type Visibility Attributes Name Initial integer, public :: pos1 integer, public :: output_record logical, public :: dir_e integer, public :: ct","tags":"","loc":"proc/save_jdote_total.html","title":"save_jdote_total – Fortran Program"},{"text":"public subroutine calc_jdote(jx, jy, jz, jdote_tot) Uses: mpi_module constants parameters pic_fields inductive_electric_field statistics Arguments Type Intent Optional Attributes Name real(kind=fp), intent(in), dimension(:, :, :) :: jx real(kind=fp), intent(in), dimension(:, :, :) :: jy real(kind=fp), intent(in), dimension(:, :, :) :: jz real(kind=fp), intent(out) :: jdote_tot Variables Type Visibility Attributes Name Initial real(kind=fp), public :: avg","tags":"","loc":"proc/calc_jdote.html","title":"calc_jdote – Fortran Program"},{"text":"public subroutine get_start_end_time_points() Uses: mpi_module constants read_config Arguments None Variables Type Visibility Attributes Name Initial integer, public :: fh real(kind=fp), public :: temp","tags":"","loc":"proc/get_start_end_time_points.html","title":"get_start_end_time_points – Fortran Program"},{"text":"public subroutine get_inductive_flag() Uses: mpi_module constants read_config Arguments None Variables Type Visibility Attributes Name Initial integer, public :: fh real(kind=fp), public :: temp","tags":"","loc":"proc/get_inductive_flag.html","title":"get_inductive_flag – Fortran Program"},{"text":"public subroutine get_relativistic_flag() Uses: mpi_module constants read_config Arguments None Variables Type Visibility Attributes Name Initial integer, public :: fh real(kind=fp), public :: temp","tags":"","loc":"proc/get_relativistic_flag.html","title":"get_relativistic_flag – Fortran Program"},{"text":"public subroutine init_drift_fields() Uses: topology_translate picinfo Arguments None","tags":"","loc":"proc/init_drift_fields.html","title":"init_drift_fields – Fortran Program"},{"text":"public subroutine set_drift_fields_zero() Arguments None","tags":"","loc":"proc/set_drift_fields_zero.html","title":"set_drift_fields_zero – Fortran Program"},{"text":"public subroutine init_para_perp_fields() Uses: topology_translate picinfo Arguments None","tags":"","loc":"proc/init_para_perp_fields.html","title":"init_para_perp_fields – Fortran Program"},{"text":"public subroutine set_para_perp_fields_zero() Arguments None","tags":"","loc":"proc/set_para_perp_fields_zero.html","title":"set_para_perp_fields_zero – Fortran Program"},{"text":"public subroutine init_jdote_sum() Uses: picinfo Arguments None","tags":"","loc":"proc/init_jdote_sum.html","title":"init_jdote_sum – Fortran Program"},{"text":"public subroutine free_drift_fields() Arguments None","tags":"","loc":"proc/free_drift_fields.html","title":"free_drift_fields – Fortran Program"},{"text":"public subroutine free_para_perp_fields() Arguments None","tags":"","loc":"proc/free_para_perp_fields.html","title":"free_para_perp_fields – Fortran Program"},{"text":"public subroutine free_jdote_sum() Arguments None","tags":"","loc":"proc/free_jdote_sum.html","title":"free_jdote_sum – Fortran Program"},{"text":"public subroutine calc_particle_energy_change_rate(tindex, species, np, sx, sy, sz) Uses: particle_file particle_module interpolation_emf file_header Arguments Type Intent Optional Attributes Name integer, intent(in) :: tindex character(len=1), intent(in) :: species integer, intent(in) :: np integer, intent(in) :: sx integer, intent(in) :: sy integer, intent(in) :: sz Variables Type Visibility Attributes Name Initial character(len=8), public :: cid integer, public :: iptl","tags":"","loc":"proc/calc_particle_energy_change_rate.html","title":"calc_particle_energy_change_rate – Fortran Program"},{"text":"public subroutine save_data_arrays(tindex, output_record) Uses: path_info mpi_io_translate picinfo particle_info particle_fields Arguments Type Intent Optional Attributes Name integer, intent(in) :: tindex integer, intent(in) :: output_record Variables Type Visibility Attributes Name Initial character(len=150), public :: fname character(len=2), public :: band_tag integer, public :: i integer, public :: ix integer, public :: iy integer, public :: iz","tags":"","loc":"proc/save_data_arrays.html","title":"save_data_arrays – Fortran Program"},{"text":"public subroutine sum_data_arrays(ct) Uses: picinfo Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct Variables Type Visibility Attributes Name Initial integer, public :: iband real(kind=fp), public :: dv","tags":"","loc":"proc/sum_data_arrays.html","title":"sum_data_arrays – Fortran Program"},{"text":"public subroutine save_jdote_sum() Uses: particle_info picinfo Arguments None Variables Type Visibility Attributes Name Initial integer, public :: ct integer, public :: fh logical, public :: dir_e","tags":"","loc":"proc/save_jdote_sum.html","title":"save_jdote_sum – Fortran Program"},{"text":"public function get_variable(fh, var_name, delimiter) result(var_value) Uses: constants Arguments Type Intent Optional Attributes Name integer, intent(in) :: fh character(len=*), intent(in) :: var_name character(len=*), intent(in) :: delimiter Return Value real(kind=fp) Variables Type Visibility Attributes Name Initial character(len=150), public :: single_line integer, public :: len1 integer, public :: IOstatus","tags":"","loc":"proc/get_variable.html","title":"get_variable – Fortran Program"},{"text":"public function get_variable_int(fh, var_name, delimiter) result(var_value_int) Uses: constants Arguments Type Intent Optional Attributes Name integer, intent(in) :: fh character(len=*), intent(in) :: var_name character(len=*), intent(in) :: delimiter Return Value integer Variables Type Visibility Attributes Name Initial real(kind=fp), public :: var_value","tags":"","loc":"proc/get_variable_int.html","title":"get_variable_int – Fortran Program"},{"text":"public subroutine read_domain() Uses: constants Arguments None Variables Type Visibility Attributes Name Initial real(kind=fp), public :: temp real(kind=fp), public :: dtf_wpe integer, public :: fh","tags":"","loc":"proc/read_domain.html","title":"read_domain – Fortran Program"},{"text":"public subroutine write_pic_info() Arguments None Variables Type Visibility Attributes Name Initial logical, public :: dir_e","tags":"","loc":"proc/write_pic_info.html","title":"write_pic_info – Fortran Program"},{"text":"public subroutine broadcast_pic_info() Uses: mpi_module Arguments None Variables Type Visibility Attributes Name Initial integer, public :: picInfoType integer, public :: oldtypes (0:2) integer, public :: blockcounts (0:2) integer, public :: offsets (0:2) integer, public :: extent","tags":"","loc":"proc/broadcast_pic_info.html","title":"broadcast_pic_info – Fortran Program"},{"text":"public subroutine get_total_time_frames(tp2) Uses: mpi_module path_info configuration_translate Arguments Type Intent Optional Attributes Name integer, intent(inout) :: tp2 Variables Type Visibility Attributes Name Initial integer(kind=8), public :: filesize logical, public :: is_exist0 logical, public :: is_exist1 logical, public :: is_exist character(len=16), public :: cfname character(len=256), public :: fname integer, public :: tindex integer, public :: nframe","tags":"","loc":"proc/get_total_time_frames.html","title":"get_total_time_frames – Fortran Program"},{"text":"public subroutine get_energy_band_number() Uses: mpi_module constants Arguments None Variables Type Visibility Attributes Name Initial integer, public :: fh integer, public :: index1 integer, public :: index2 character(len=256), public :: buff character(len=256), public :: single_line character(len=20), public :: fname","tags":"","loc":"proc/get_energy_band_number.html","title":"get_energy_band_number – Fortran Program"},{"text":"public subroutine read_thermal_params() Uses: mpi_module constants Arguments None Variables Type Visibility Attributes Name Initial real(kind=fp), public :: temp real(kind=fp), public :: dtf_wpe integer, public :: fh","tags":"","loc":"proc/read_thermal_params.html","title":"read_thermal_params – Fortran Program"},{"text":"public subroutine calc_energy_interval() Uses: mpi_module Arguments None Variables Type Visibility Attributes Name Initial integer, public :: fh real(kind=fp), public :: eratio","tags":"","loc":"proc/calc_energy_interval~2.html","title":"calc_energy_interval – Fortran Program"},{"text":"public subroutine set_mpi_datatype_fields() Uses: mpi_datatype_module Arguments None","tags":"","loc":"proc/set_mpi_datatype_fields.html","title":"set_mpi_datatype_fields – Fortran Program"},{"text":"public subroutine save_field(fdata, varname, ct) Uses: constants picinfo parameters path_info particle_info mpi_datatype_fields mpi_info_module mpi_topology mpi_io_module Arguments Type Intent Optional Attributes Name real(kind=fp), intent(in), dimension(:, :, :) :: fdata character(len=*), intent(in) :: varname integer, intent(in) :: ct Variables Type Visibility Attributes Name Initial character(len=150), public :: fname integer, public :: fh integer, public :: ixl integer, public :: iyl integer, public :: izl integer, public :: ixh integer, public :: iyh integer, public :: izh real(kind=fp), public, allocatable, dimension(:,:,:) :: data_nghost integer(kind=MPI_OFFSET_KIND), public :: disp integer(kind=MPI_OFFSET_KIND), public :: offset","tags":"","loc":"proc/save_field.html","title":"save_field – Fortran Program"},{"text":"public subroutine init_analysis() Uses: mpi_module path_info mpi_topology mpi_datatype_fields mpi_info_module picinfo parameters configuration_translate time_info commandline_arguments Arguments None","tags":"","loc":"proc/init_analysis.html","title":"init_analysis – Fortran Program"},{"text":"public subroutine end_analysis() Uses: mpi_module mpi_datatype_fields mpi_info_module Arguments None","tags":"","loc":"proc/end_analysis.html","title":"end_analysis – Fortran Program"},{"text":"public subroutine get_file_paths() Uses: mpi_module Arguments None Variables Type Visibility Attributes Name Initial integer, public :: status1 integer, public :: getcwd integer, public :: index1","tags":"","loc":"proc/get_file_paths.html","title":"get_file_paths – Fortran Program"},{"text":"public subroutine init_avg_para_perp_pressure() Uses: parameters Arguments None","tags":"","loc":"proc/init_avg_para_perp_pressure.html","title":"init_avg_para_perp_pressure – Fortran Program"},{"text":"public subroutine init_para_perp_pressure() Uses: mpi_topology Arguments None Variables Type Visibility Attributes Name Initial integer, public :: nx integer, public :: ny integer, public :: nz","tags":"","loc":"proc/init_para_perp_pressure.html","title":"init_para_perp_pressure – Fortran Program"},{"text":"public subroutine free_avg_para_perp_pressure() Arguments None","tags":"","loc":"proc/free_avg_para_perp_pressure.html","title":"free_avg_para_perp_pressure – Fortran Program"},{"text":"public subroutine free_para_perp_pressure() Arguments None","tags":"","loc":"proc/free_para_perp_pressure.html","title":"free_para_perp_pressure – Fortran Program"},{"text":"public subroutine calc_para_perp_pressure(ct) Uses: constants parameters pic_fields statistics particle_info mpi_topology saving_flags Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct Variables Type Visibility Attributes Name Initial real(kind=fp), public, allocatable, dimension(:,:,:) :: bsquare real(kind=fp), public, allocatable, dimension(:,:,:) :: prexx real(kind=fp), public, allocatable, dimension(:,:,:) :: preyy real(kind=fp), public, allocatable, dimension(:,:,:) :: prezz real(kind=fp), public :: tot integer, public :: nx integer, public :: ny integer, public :: nz","tags":"","loc":"proc/calc_para_perp_pressure.html","title":"calc_para_perp_pressure – Fortran Program"},{"text":"public subroutine calc_real_para_perp_pressure(ct) Uses: constants parameters pic_fields statistics mpi_topology saving_flags Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct Variables Type Visibility Attributes Name Initial real(kind=fp), public, allocatable, dimension(:,:,:) :: bsquare real(kind=fp), public :: tot integer, public :: nx integer, public :: ny integer, public :: nz","tags":"","loc":"proc/calc_real_para_perp_pressure.html","title":"calc_real_para_perp_pressure – Fortran Program"},{"text":"public subroutine save_para_perp_pressure(ct) Uses: mpi_module constants mpi_io_fields Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct","tags":"","loc":"proc/save_para_perp_pressure.html","title":"save_para_perp_pressure – Fortran Program"},{"text":"public subroutine save_averaged_para_perp_pressure() Uses: constants particle_info parameters Arguments None Variables Type Visibility Attributes Name Initial character(len=100), public :: fname integer, public :: current_pos integer, public :: output_record logical, public :: dir_e integer, public :: ct","tags":"","loc":"proc/save_averaged_para_perp_pressure.html","title":"save_averaged_para_perp_pressure – Fortran Program"},{"text":"public subroutine set_mpi_io() Uses: mpi_module topology_translate picinfo mpi_datatype_module mpi_info_module Arguments None Variables Type Visibility Attributes Name Initial integer, public :: sizes (3) integer, public :: subsizes (3) integer, public :: starts (3)","tags":"","loc":"proc/set_mpi_io.html","title":"set_mpi_io – Fortran Program"},{"text":"public subroutine write_data(fname, fdata, tindex, output_record) Uses: mpi_module constants topology_translate mpi_info_module configuration_translate Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname real(kind=fp), intent(in), dimension(:,:,:) :: fdata integer, intent(in) :: tindex integer, intent(in) :: output_record Variables Type Visibility Attributes Name Initial integer(kind=MPI_OFFSET_KIND), public :: disp integer(kind=MPI_OFFSET_KIND), public :: offset character(len=150), public :: cfname real(kind=dp), public :: mp_elapsed integer, public :: fh","tags":"","loc":"proc/write_data.html","title":"write_data – Fortran Program"},{"text":"public subroutine distribute_pic_mpi() Uses: mpi_module spectrum_config mpi_topology Arguments None Variables Type Visibility Attributes Name Initial integer, public :: tx integer, public :: ty integer, public :: tz integer, public :: txc integer, public :: tyc integer, public :: tzc integer, public :: ix integer, public :: iy integer, public :: iz integer, public :: pic_nx integer, public :: pic_ny integer, public :: pic_nz","tags":"","loc":"proc/distribute_pic_mpi.html","title":"distribute_pic_mpi – Fortran Program"},{"text":"public subroutine init_emax_array() Arguments None","tags":"","loc":"proc/init_emax_array.html","title":"init_emax_array – Fortran Program"},{"text":"public subroutine free_emax_array() Arguments None","tags":"","loc":"proc/free_emax_array.html","title":"free_emax_array – Fortran Program"},{"text":"public subroutine update_emax_array(emax_pic_mpi, otx, oty, otz) Uses: picinfo Arguments Type Intent Optional Attributes Name real(kind=fp), intent(in), dimension(:, :, :) :: emax_pic_mpi integer, intent(in) :: otx integer, intent(in) :: oty integer, intent(in) :: otz Variables Type Visibility Attributes Name Initial integer, public :: ixl integer, public :: ixh integer, public :: iyl integer, public :: iyh integer, public :: izl integer, public :: izh","tags":"","loc":"proc/update_emax_array.html","title":"update_emax_array – Fortran Program"},{"text":"public subroutine write_emax(ct, species) Uses: mpi_module path_info mpi_io_module mpi_info_module Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct character(len=1), intent(in) :: species Variables Type Visibility Attributes Name Initial integer(kind=MPI_OFFSET_KIND), public :: disp integer(kind=MPI_OFFSET_KIND), public :: offset character(len=150), public :: fname integer, public :: fh","tags":"","loc":"proc/write_emax.html","title":"write_emax – Fortran Program"},{"text":"public subroutine set_emax_datatype() Uses: mpi_datatype_module Arguments None","tags":"","loc":"proc/set_emax_datatype.html","title":"set_emax_datatype – Fortran Program"},{"text":"public subroutine free_emax_datatype() Uses: mpi_module Arguments None","tags":"","loc":"proc/free_emax_datatype.html","title":"free_emax_datatype – Fortran Program"},{"text":"public subroutine set_topology() Uses: configuration_translate picinfo Arguments None","tags":"","loc":"proc/set_topology.html","title":"set_topology – Fortran Program"},{"text":"public subroutine set_start_stop_cells() Uses: picinfo Arguments None Variables Type Visibility Attributes Name Initial integer, public :: ndomains integer, public :: ix integer, public :: iy integer, public :: iz integer, public :: n","tags":"","loc":"proc/set_start_stop_cells.html","title":"set_start_stop_cells – Fortran Program"},{"text":"public subroutine free_start_stop_cells() Arguments None","tags":"","loc":"proc/free_start_stop_cells.html","title":"free_start_stop_cells – Fortran Program"},{"text":"public subroutine init_emfields() Uses: topology_translate Arguments None","tags":"","loc":"proc/init_emfields.html","title":"init_emfields – Fortran Program"},{"text":"public subroutine free_emfields() Arguments None","tags":"","loc":"proc/free_emfields.html","title":"free_emfields – Fortran Program"},{"text":"public subroutine read_emfields(tindex0) Uses: rank_index_mapping picinfo topology_translate Arguments Type Intent Optional Attributes Name integer, intent(in) :: tindex0 Variables Type Visibility Attributes Name Initial integer, public :: dom_x integer, public :: dom_y integer, public :: dom_z integer, public :: n","tags":"","loc":"proc/read_emfields.html","title":"read_emfields – Fortran Program"},{"text":"public subroutine write_emfields(tindex, output_record) Uses: path_info mpi_io_translate Arguments Type Intent Optional Attributes Name integer, intent(in) :: tindex integer, intent(in) :: output_record","tags":"","loc":"proc/write_emfields.html","title":"write_emfields – Fortran Program"},{"text":"public subroutine init_fieldline_tracing() Uses: magnetic_field Arguments None","tags":"","loc":"proc/init_fieldline_tracing.html","title":"init_fieldline_tracing – Fortran Program"},{"text":"public subroutine init_fieldline_points() Arguments None","tags":"","loc":"proc/init_fieldline_points.html","title":"init_fieldline_points – Fortran Program"},{"text":"public subroutine free_fieldline_points() Arguments None","tags":"","loc":"proc/free_fieldline_points.html","title":"free_fieldline_points – Fortran Program"},{"text":"public subroutine end_fieldline_tracing() Uses: magnetic_field Arguments None","tags":"","loc":"proc/end_fieldline_tracing.html","title":"end_fieldline_tracing – Fortran Program"},{"text":"public subroutine tracing(x0, z0, htry, direction_flag) Uses: constants Arguments Type Intent Optional Attributes Name real(kind=fp), intent(in) :: x0 real(kind=fp), intent(in) :: z0 real(kind=fp), intent(in) :: htry integer, intent(in) :: direction_flag Variables Type Visibility Attributes Name Initial real(kind=fp), public, dimension(0:6) :: kx real(kind=fp), public, dimension(0:6) :: ky real(kind=fp), public, dimension(0:6) :: kz real(kind=fp), public :: arc_length real(kind=fp), public :: xout real(kind=fp), public :: zout real(kind=fp), public :: xold real(kind=fp), public :: zold real(kind=fp), public :: x real(kind=fp), public :: z real(kind=fp), public :: xcross real(kind=fp), public :: zcross real(kind=fp), public :: dxds real(kind=fp), public :: dyds real(kind=fp), public :: dzds real(kind=fp), public :: dxdsnew real(kind=fp), public :: dydsnew real(kind=fp), public :: dzdsnew real(kind=fp), public :: h real(kind=fp), public :: hnext real(kind=fp), public :: errold logical, public :: is_accept","tags":"","loc":"proc/tracing.html","title":"tracing – Fortran Program"},{"text":"public subroutine trace_field_line(x0, z0) Uses: constants picinfo Arguments Type Intent Optional Attributes Name real(kind=fp), intent(in) :: x0 real(kind=fp), intent(in) :: z0 Variables Type Visibility Attributes Name Initial real(kind=fp), public :: htry integer, public :: direction_flag","tags":"","loc":"proc/trace_field_line.html","title":"trace_field_line – Fortran Program"},{"text":"public subroutine get_crossing_point(x, z, xold, zold, lx, lz, xcross, zcross) Uses: constants Arguments Type Intent Optional Attributes Name real(kind=fp), intent(in) :: x real(kind=fp), intent(in) :: z real(kind=fp), intent(in) :: xold real(kind=fp), intent(in) :: zold real(kind=fp), intent(in) :: lx real(kind=fp), intent(in) :: lz real(kind=fp), intent(out) :: xcross real(kind=fp), intent(out) :: zcross Variables Type Visibility Attributes Name Initial real(kind=fp), public :: k real(kind=fp), public :: xb real(kind=fp), public :: xt real(kind=fp), public :: zr real(kind=fp), public :: zl","tags":"","loc":"proc/get_crossing_point.html","title":"get_crossing_point – Fortran Program"},{"text":"public subroutine controller(h, hmax, hnext, x, z, xout, zout, kx, kz, is_accept, errold) Uses: constants Arguments Type Intent Optional Attributes Name real(kind=fp), intent(inout) :: h real(kind=fp), intent(in) :: hmax real(kind=fp), intent(out) :: hnext real(kind=fp), intent(in) :: x real(kind=fp), intent(in) :: z real(kind=fp), intent(in) :: xout real(kind=fp), intent(in) :: zout real(kind=fp), intent(in), dimension(0:6) :: kx real(kind=fp), intent(in), dimension(0:6) :: kz logical, intent(inout) :: is_accept real(kind=fp), intent(inout) :: errold Variables Type Visibility Attributes Name Initial real(kind=fp), public :: err_tot real(kind=fp), public :: sk real(kind=fp), public :: errx real(kind=fp), public :: errz real(kind=fp), public :: sscale real(kind=fp), public, parameter :: beta = 0.0 real(kind=fp), public, parameter :: alpha = 0.2-beta*0.75 real(kind=fp), public, parameter :: safe = 0.9 real(kind=fp), public, parameter :: minscale = 0.2 real(kind=fp), public, parameter :: maxscale = 10.0 real(kind=fp), public, parameter :: atol = 1.0E-5 real(kind=fp), public, parameter :: rtol = 1.0E-5","tags":"","loc":"proc/controller.html","title":"controller – Fortran Program"},{"text":"public subroutine push(dxds, dyds, dzds, direction_flag, x, z, h, kx, ky, kz, xout, zout, dxdsnew, dydsnew, dzdsnew) Uses: constants Arguments Type Intent Optional Attributes Name real(kind=fp), intent(in) :: dxds real(kind=fp), intent(in) :: dyds real(kind=fp), intent(in) :: dzds integer, intent(in) :: direction_flag real(kind=fp), intent(in) :: x real(kind=fp), intent(in) :: z real(kind=fp), intent(in) :: h real(kind=fp), intent(out), dimension(0:6) :: kx real(kind=fp), intent(out), dimension(0:6) :: ky real(kind=fp), intent(out), dimension(0:6) :: kz real(kind=fp), intent(out) :: xout real(kind=fp), intent(out) :: zout real(kind=fp), intent(out) :: dxdsnew real(kind=fp), intent(out) :: dydsnew real(kind=fp), intent(out) :: dzdsnew Variables Type Visibility Attributes Name Initial real(kind=fp), public :: xtemp real(kind=fp), public :: ztemp integer, public :: i","tags":"","loc":"proc/push.html","title":"push – Fortran Program"},{"text":"public subroutine derivs(x, z, direction_flag, deltax, deltay, deltaz) Uses: magnetic_field constants Arguments Type Intent Optional Attributes Name real(kind=fp), intent(in) :: x real(kind=fp), intent(in) :: z integer, intent(in) :: direction_flag real(kind=fp), intent(out) :: deltax real(kind=fp), intent(out) :: deltay real(kind=fp), intent(out) :: deltaz Variables Type Visibility Attributes Name Initial real(kind=fp), public :: absB","tags":"","loc":"proc/derivs.html","title":"derivs – Fortran Program"},{"text":"public subroutine Cash_Karp_parameters() Arguments None","tags":"","loc":"proc/cash_karp_parameters.html","title":"Cash_Karp_parameters – Fortran Program"},{"text":"public subroutine Dormand_Prince_parameters() Arguments None","tags":"","loc":"proc/dormand_prince_parameters.html","title":"Dormand_Prince_parameters – Fortran Program"},{"text":"public subroutine init_particle_fields() Arguments None","tags":"","loc":"proc/init_particle_fields.html","title":"init_particle_fields – Fortran Program"},{"text":"public subroutine init_density_fields() Uses: topology_translate Arguments None","tags":"","loc":"proc/init_density_fields.html","title":"init_density_fields – Fortran Program"},{"text":"public subroutine init_velocity_fields() Uses: topology_translate Arguments None","tags":"","loc":"proc/init_velocity_fields.html","title":"init_velocity_fields – Fortran Program"},{"text":"public subroutine init_pressure_tensor() Uses: topology_translate Arguments None","tags":"","loc":"proc/init_pressure_tensor.html","title":"init_pressure_tensor – Fortran Program"},{"text":"public subroutine init_current_densities() Uses: topology_translate Arguments None","tags":"","loc":"proc/init_current_densities.html","title":"init_current_densities – Fortran Program"},{"text":"public subroutine set_current_density_zero() Arguments None","tags":"","loc":"proc/set_current_density_zero.html","title":"set_current_density_zero – Fortran Program"},{"text":"public subroutine free_particle_fields() Arguments None","tags":"","loc":"proc/free_particle_fields.html","title":"free_particle_fields – Fortran Program"},{"text":"public subroutine free_density_fields() Arguments None","tags":"","loc":"proc/free_density_fields.html","title":"free_density_fields – Fortran Program"},{"text":"public subroutine free_velocity_fields() Arguments None","tags":"","loc":"proc/free_velocity_fields.html","title":"free_velocity_fields – Fortran Program"},{"text":"public subroutine free_pressure_tensor() Arguments None","tags":"","loc":"proc/free_pressure_tensor.html","title":"free_pressure_tensor – Fortran Program"},{"text":"public subroutine free_current_densities() Arguments None","tags":"","loc":"proc/free_current_densities.html","title":"free_current_densities – Fortran Program"},{"text":"public subroutine read_particle_fields(tindex0, species) Uses: rank_index_mapping picinfo topology_translate Arguments Type Intent Optional Attributes Name integer, intent(in) :: tindex0 character(len=1), intent(in) :: species Variables Type Visibility Attributes Name Initial integer, public :: dom_x integer, public :: dom_y integer, public :: dom_z integer, public :: n","tags":"","loc":"proc/read_particle_fields.html","title":"read_particle_fields – Fortran Program"},{"text":"public subroutine read_velocity_fields_single(tindex0, pic_mpi_id, species) Uses: constants file_header topology_translate Arguments Type Intent Optional Attributes Name integer, intent(in) :: tindex0 integer, intent(in) :: pic_mpi_id character(len=1), intent(in) :: species Variables Type Visibility Attributes Name Initial real(kind=fp), public, allocatable, dimension(:,:,:) :: buffer integer, public :: ixl integer, public :: iyl integer, public :: izl integer, public :: ixh integer, public :: iyh integer, public :: izh integer, public :: nc1 integer, public :: nc2 integer, public :: nc3 integer, public :: i integer, public :: fh","tags":"","loc":"proc/read_velocity_fields_single.html","title":"read_velocity_fields_single – Fortran Program"},{"text":"public subroutine read_pressure_tensor_single(tindex0, pic_mpi_id, species) Uses: constants file_header topology_translate Arguments Type Intent Optional Attributes Name integer, intent(in) :: tindex0 integer, intent(in) :: pic_mpi_id character(len=1), intent(in) :: species Variables Type Visibility Attributes Name Initial real(kind=fp), public, allocatable, dimension(:,:,:) :: buffer integer, public :: ixl integer, public :: iyl integer, public :: izl integer, public :: ixh integer, public :: iyh integer, public :: izh integer, public :: nc1 integer, public :: nc2 integer, public :: nc3 integer, public :: i integer, public :: fh integer, public :: offset integer, public :: buffer_size","tags":"","loc":"proc/read_pressure_tensor_single.html","title":"read_pressure_tensor_single – Fortran Program"},{"text":"public subroutine read_density_fields_single(tindex0, pic_mpi_id, species) Uses: constants file_header topology_translate Arguments Type Intent Optional Attributes Name integer, intent(in) :: tindex0 integer, intent(in) :: pic_mpi_id character(len=1), intent(in) :: species Variables Type Visibility Attributes Name Initial real(kind=fp), public, allocatable, dimension(:,:,:) :: buffer integer, public :: ixl integer, public :: iyl integer, public :: izl integer, public :: ixh integer, public :: iyh integer, public :: izh integer, public :: nc1 integer, public :: nc2 integer, public :: nc3 integer, public :: i integer, public :: fh integer, public :: offset integer, public :: buffer_size","tags":"","loc":"proc/read_density_fields_single.html","title":"read_density_fields_single – Fortran Program"},{"text":"public subroutine calc_current_density() Arguments None","tags":"","loc":"proc/calc_current_density.html","title":"calc_current_density – Fortran Program"},{"text":"public subroutine calc_absJ() Arguments None","tags":"","loc":"proc/calc_absj.html","title":"calc_absJ – Fortran Program"},{"text":"public subroutine adjust_particle_fields(species) Uses: picinfo constants Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: species Variables Type Visibility Attributes Name Initial real(kind=fp), public :: ptl_mass real(kind=fp), public :: ptl_charge","tags":"","loc":"proc/adjust_particle_fields.html","title":"adjust_particle_fields – Fortran Program"},{"text":"public subroutine write_particle_fields(tindex, output_record, species) Uses: mpi_io_translate Arguments Type Intent Optional Attributes Name integer, intent(in) :: tindex integer, intent(in) :: output_record character(len=1), intent(in) :: species Variables Type Visibility Attributes Name Initial character(len=150), public :: fname integer, public :: ib","tags":"","loc":"proc/write_particle_fields.html","title":"write_particle_fields – Fortran Program"},{"text":"public subroutine write_current_densities(tindex, output_record) Uses: mpi_io_translate Arguments Type Intent Optional Attributes Name integer, intent(in) :: tindex integer, intent(in) :: output_record","tags":"","loc":"proc/write_current_densities.html","title":"write_current_densities – Fortran Program"},{"text":"public subroutine calc_particle_energy() Arguments None","tags":"","loc":"proc/calc_particle_energy.html","title":"calc_particle_energy – Fortran Program"},{"text":"public subroutine calc_ptl_coord() Uses: file_header Arguments None Variables Type Visibility Attributes Name Initial integer, public :: nx integer, public :: ny integer, public :: nz integer, public :: icell","tags":"","loc":"proc/calc_ptl_coord.html","title":"calc_ptl_coord – Fortran Program"},{"text":"public subroutine calc_interp_param() Uses: file_header Arguments None Variables Type Visibility Attributes Name Initial integer, public :: nx integer, public :: ny integer, public :: nz integer, public :: icell real(kind=fp), public :: dx real(kind=fp), public :: dy real(kind=fp), public :: dz","tags":"","loc":"proc/calc_interp_param.html","title":"calc_interp_param – Fortran Program"},{"text":"public subroutine calc_para_perp_velocity() Uses: picinfo magnetic_field Arguments None Variables Type Visibility Attributes Name Initial real(kind=fp), public :: absB real(kind=fp), public :: dx real(kind=fp), public :: dz","tags":"","loc":"proc/calc_para_perp_velocity.html","title":"calc_para_perp_velocity – Fortran Program"},{"text":"public subroutine calc_gyrofrequency() Uses: interpolation_emf particle_info Arguments None","tags":"","loc":"proc/calc_gyrofrequency.html","title":"calc_gyrofrequency – Fortran Program"},{"text":"public subroutine calc_para_perp_velocity_3d() Uses: interpolation_emf Arguments None Variables Type Visibility Attributes Name Initial real(kind=fp), public :: vx real(kind=fp), public :: vy real(kind=fp), public :: vz real(kind=fp), public :: vdotb","tags":"","loc":"proc/calc_para_perp_velocity_3d.html","title":"calc_para_perp_velocity_3d – Fortran Program"},{"text":"public subroutine calc_gradient_drift_velocity() Uses: interpolation_emf Arguments None Variables Type Visibility Attributes Name Initial real(kind=fp), public :: param","tags":"","loc":"proc/calc_gradient_drift_velocity.html","title":"calc_gradient_drift_velocity – Fortran Program"},{"text":"public subroutine calc_curvature_drift_velocity() Uses: interpolation_emf Arguments None Variables Type Visibility Attributes Name Initial real(kind=fp), public :: param","tags":"","loc":"proc/calc_curvature_drift_velocity.html","title":"calc_curvature_drift_velocity – Fortran Program"},{"text":"public function check_particle_in_range(spatial_range) result(isrange) Uses: constants picinfo file_header Arguments Type Intent Optional Attributes Name real(kind=fp), intent(in), dimension(2,3) :: spatial_range Return Value logical Variables Type Visibility Attributes Name Initial real(kind=fp), public :: x0 real(kind=fp), public :: y0 real(kind=fp), public :: z0 real(kind=fp), public :: x1 real(kind=fp), public :: y1 real(kind=fp), public :: z1 real(kind=fp), public :: dx real(kind=fp), public :: dy real(kind=fp), public :: dz logical, public :: isrange1 logical, public :: isrange2","tags":"","loc":"proc/check_particle_in_range.html","title":"check_particle_in_range – Fortran Program"},{"text":"public function check_both_particle_fields_exist(ct) result(is_time_valid) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct Return Value logical","tags":"","loc":"proc/check_both_particle_fields_exist.html","title":"check_both_particle_fields_exist – Fortran Program"},{"text":"public subroutine check_existence(tindex, species, existFlag) Arguments Type Intent Optional Attributes Name integer, intent(in) :: tindex character(len=1), intent(in) :: species logical, intent(out) :: existFlag Variables Type Visibility Attributes Name Initial character(len=20), public :: ctindex character(len=150), public :: dataset character(len=150), public :: fname","tags":"","loc":"proc/check_existence.html","title":"check_existence – Fortran Program"},{"text":"public subroutine open_particle_file(tindex, species, cid) Uses: file_header Arguments Type Intent Optional Attributes Name integer, intent(in) :: tindex character(len=1), intent(in) :: species character(len=*), intent(in) :: cid Variables Type Visibility Attributes Name Initial character(len=50), public :: ctindex character(len=150), public :: dataset character(len=150), public :: fname","tags":"","loc":"proc/open_particle_file.html","title":"open_particle_file – Fortran Program"},{"text":"public subroutine close_particle_file() Arguments None","tags":"","loc":"proc/close_particle_file.html","title":"close_particle_file – Fortran Program"},{"text":"public subroutine get_ratio_interval() Arguments None Variables Type Visibility Attributes Name Initial character(len=150), public :: buff character(len=50), public :: buff1 character(len=50), public :: format1 integer, public :: len1 integer, public :: len2 integer, public :: len3","tags":"","loc":"proc/get_ratio_interval.html","title":"get_ratio_interval – Fortran Program"},{"text":"public subroutine distribute_tasks(ntasks, nworkers, worker_id, ntask_current, task_start, task_end) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ntasks integer, intent(in) :: nworkers integer, intent(in) :: worker_id integer, intent(out) :: ntask_current integer, intent(out) :: task_start integer, intent(out) :: task_end Variables Type Visibility Attributes Name Initial integer, public :: mod_tasks","tags":"","loc":"proc/distribute_tasks.html","title":"distribute_tasks – Fortran Program"},{"text":"public subroutine set_mpi_topology() Uses: mpi_module picinfo Arguments None Variables Type Visibility Attributes Name Initial integer, public :: d1 integer, public :: d2","tags":"","loc":"proc/set_mpi_topology.html","title":"set_mpi_topology – Fortran Program"},{"text":"public subroutine init_compression_shear() Arguments None","tags":"","loc":"proc/init_compression_shear.html","title":"init_compression_shear – Fortran Program"},{"text":"public subroutine init_div_v() Arguments None","tags":"","loc":"proc/init_div_v.html","title":"init_div_v – Fortran Program"},{"text":"public subroutine init_div_vdot_ptensor() Arguments None","tags":"","loc":"proc/init_div_vdot_ptensor.html","title":"init_div_vdot_ptensor – Fortran Program"},{"text":"public subroutine free_compression_shear() Arguments None","tags":"","loc":"proc/free_compression_shear.html","title":"free_compression_shear – Fortran Program"},{"text":"public subroutine free_div_v() Arguments None","tags":"","loc":"proc/free_div_v.html","title":"free_div_v – Fortran Program"},{"text":"public subroutine free_div_vdot_ptensor() Arguments None","tags":"","loc":"proc/free_div_vdot_ptensor.html","title":"free_div_vdot_ptensor – Fortran Program"},{"text":"public subroutine calc_div_v() Uses: pic_fields neighbors_module Arguments None Variables Type Visibility Attributes Name Initial integer, public :: nx integer, public :: ny integer, public :: nz integer, public :: ix integer, public :: iy integer, public :: iz","tags":"","loc":"proc/calc_div_v.html","title":"calc_div_v – Fortran Program"},{"text":"public subroutine calc_compression_shear() Arguments None","tags":"","loc":"proc/calc_compression_shear.html","title":"calc_compression_shear – Fortran Program"},{"text":"public subroutine calc_div_vdot_ptensor() Uses: pic_fields neighbors_module Arguments None Variables Type Visibility Attributes Name Initial integer, public :: nx integer, public :: ny integer, public :: nz integer, public :: ix integer, public :: iy integer, public :: iz","tags":"","loc":"proc/calc_div_vdot_ptensor.html","title":"calc_div_vdot_ptensor – Fortran Program"},{"text":"public subroutine save_compression_shear(ct) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct","tags":"","loc":"proc/save_compression_shear.html","title":"save_compression_shear – Fortran Program"},{"text":"public subroutine save_div_vdot_ptensor(ct) Uses: mpi_module constants mpi_io_fields Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct","tags":"","loc":"proc/save_div_vdot_ptensor.html","title":"save_div_vdot_ptensor – Fortran Program"},{"text":"public subroutine save_tot_compression_shear(ct) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct","tags":"","loc":"proc/save_tot_compression_shear.html","title":"save_tot_compression_shear – Fortran Program"},{"text":"public subroutine save_tot_div_vdot_ptensor(ct) Uses: mpi_module constants particle_info statistics parameters Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct Variables Type Visibility Attributes Name Initial real(kind=fp), public :: div_vdot_ptensor_tot real(kind=fp), public :: avg character(len=100), public :: fname integer, public :: current_pos integer, public :: output_record logical, public :: dir_e","tags":"","loc":"proc/save_tot_div_vdot_ptensor.html","title":"save_tot_div_vdot_ptensor – Fortran Program"},{"text":"public subroutine init_energy_spectra() Uses: mpi_module spectrum_config Arguments None","tags":"","loc":"proc/init_energy_spectra.html","title":"init_energy_spectra – Fortran Program"},{"text":"public subroutine init_energy_spectra_single() Uses: spectrum_config Arguments None","tags":"","loc":"proc/init_energy_spectra_single.html","title":"init_energy_spectra_single – Fortran Program"},{"text":"public subroutine set_energy_spectra_zero() Uses: mpi_module Arguments None","tags":"","loc":"proc/set_energy_spectra_zero.html","title":"set_energy_spectra_zero – Fortran Program"},{"text":"public subroutine set_energy_spectra_zero_single() Arguments None","tags":"","loc":"proc/set_energy_spectra_zero_single.html","title":"set_energy_spectra_zero_single – Fortran Program"},{"text":"public subroutine init_maximum_energy(nt) Uses: mpi_module Arguments Type Intent Optional Attributes Name integer, intent(in) :: nt","tags":"","loc":"proc/init_maximum_energy.html","title":"init_maximum_energy – Fortran Program"},{"text":"public subroutine set_maximum_energy_zero() Uses: mpi_module Arguments None","tags":"","loc":"proc/set_maximum_energy_zero.html","title":"set_maximum_energy_zero – Fortran Program"},{"text":"public subroutine free_maximum_energy() Uses: mpi_module Arguments None","tags":"","loc":"proc/free_maximum_energy.html","title":"free_maximum_energy – Fortran Program"},{"text":"public subroutine free_energy_spectra() Uses: mpi_module Arguments None","tags":"","loc":"proc/free_energy_spectra.html","title":"free_energy_spectra – Fortran Program"},{"text":"public subroutine free_energy_spectra_single() Arguments None","tags":"","loc":"proc/free_energy_spectra_single.html","title":"free_energy_spectra_single – Fortran Program"},{"text":"public subroutine init_emax_pic_mpi() Uses: picinfo Arguments None","tags":"","loc":"proc/init_emax_pic_mpi.html","title":"init_emax_pic_mpi – Fortran Program"},{"text":"public subroutine set_emax_pic_mpi_zero() Arguments None","tags":"","loc":"proc/set_emax_pic_mpi_zero.html","title":"set_emax_pic_mpi_zero – Fortran Program"},{"text":"public subroutine free_emax_pic_mpi() Uses: picinfo Arguments None","tags":"","loc":"proc/free_emax_pic_mpi.html","title":"free_emax_pic_mpi – Fortran Program"},{"text":"public subroutine calc_energy_bins() Uses: spectrum_config Arguments None Variables Type Visibility Attributes Name Initial integer, public :: i","tags":"","loc":"proc/calc_energy_bins.html","title":"calc_energy_bins – Fortran Program"},{"text":"public subroutine calc_energy_spectra(ct, species) Uses: mpi_module constants particle_frames particle_file commandline_arguments particle_maximum_energy Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct character(len=1), intent(in) :: species Variables Type Visibility Attributes Name Initial integer, public :: tindex logical, public :: is_exist","tags":"","loc":"proc/calc_energy_spectra.html","title":"calc_energy_spectra – Fortran Program"},{"text":"public subroutine sum_spectra_over_mpi() Uses: mpi_module spectrum_config Arguments None","tags":"","loc":"proc/sum_spectra_over_mpi.html","title":"sum_spectra_over_mpi – Fortran Program"},{"text":"public subroutine get_maximum_energy_global(nt) Uses: mpi_module Arguments Type Intent Optional Attributes Name integer, intent(in) :: nt","tags":"","loc":"proc/get_maximum_energy_global.html","title":"get_maximum_energy_global – Fortran Program"},{"text":"public subroutine save_particle_spectra(ct, species) Uses: spectrum_config Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct character(len=1), intent(in) :: species Variables Type Visibility Attributes Name Initial logical, public :: dir_e character(len=100), public :: fname integer, public :: i","tags":"","loc":"proc/save_particle_spectra.html","title":"save_particle_spectra – Fortran Program"},{"text":"public subroutine save_maximum_energy(nt, species) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nt character(len=1), intent(in) :: species Variables Type Visibility Attributes Name Initial logical, public :: dir_e character(len=100), public :: fname integer, public :: i","tags":"","loc":"proc/save_maximum_energy.html","title":"save_maximum_energy – Fortran Program"},{"text":"public subroutine calc_energy_spectrum_single(tindex, species) Uses: picinfo file_header spectrum_config particle_file Arguments Type Intent Optional Attributes Name integer, intent(in) :: tindex character(len=1), intent(in) :: species Variables Type Visibility Attributes Name Initial character(len=50), public :: cid integer, public :: np integer, public :: iptl integer, public :: ix integer, public :: iy integer, public :: iz integer, public :: IOstatus","tags":"","loc":"proc/calc_energy_spectrum_single.html","title":"calc_energy_spectrum_single – Fortran Program"},{"text":"public subroutine update_energy_spectrum() Uses: particle_module spectrum_config Arguments None Variables Type Visibility Attributes Name Initial real(kind=fp), public :: rbin real(kind=fp), public :: shift real(kind=fp), public :: dke integer, public :: ibin integer, public :: ibin1","tags":"","loc":"proc/update_energy_spectrum.html","title":"update_energy_spectrum – Fortran Program"},{"text":"public subroutine update_maximum_energy() Uses: particle_module Arguments None","tags":"","loc":"proc/update_maximum_energy.html","title":"update_maximum_energy – Fortran Program"},{"text":"public subroutine get_average_and_total(fdata, avg, tot) Uses: mpi_module constants picinfo mpi_topology Arguments Type Intent Optional Attributes Name real(kind=fp), intent(in), dimension(:, :, :) :: fdata real(kind=fp), intent(out) :: avg real(kind=fp), intent(out) :: tot Variables Type Visibility Attributes Name Initial real(kind=fp), public, allocatable, dimension(:) :: tot_array real(kind=fp), public :: tot_local integer, public :: ixl integer, public :: ixh integer, public :: iyl integer, public :: iyh integer, public :: izl integer, public :: izh","tags":"","loc":"proc/get_average_and_total.html","title":"get_average_and_total – Fortran Program"},{"text":"public subroutine get_log_distribution(dataSet, minValue, maxValue, nbins, distData) Uses: constants mpi_topology Arguments Type Intent Optional Attributes Name real(kind=fp), intent(in), dimension(:, :, :) :: dataSet real(kind=fp), intent(in) :: minValue real(kind=fp), intent(in) :: maxValue integer, intent(in) :: nbins real(kind=fp), intent(out), dimension(nbins+2) :: distData Variables Type Visibility Attributes Name Initial integer, public :: ix integer, public :: iy integer, public :: iz integer, public :: ibin integer, public :: ix_start integer, public :: iy_start integer, public :: iz_start integer, public :: ix_stop integer, public :: iy_stop integer, public :: iz_stop real(kind=fp), public :: deltaLog real(kind=fp), public :: minLog real(kind=fp), public :: maxLog","tags":"","loc":"proc/get_log_distribution.html","title":"get_log_distribution – Fortran Program"},{"text":"public subroutine read_config_jdote_eband() Uses: read_config Arguments None Variables Type Visibility Attributes Name Initial integer, public :: fh real(kind=fp), public :: temp character(len=100), public :: fname","tags":"","loc":"proc/read_config_jdote_eband.html","title":"read_config_jdote_eband – Fortran Program"},{"text":"public subroutine read_configuration() Uses: mpi_module Arguments None","tags":"","loc":"proc/read_configuration.html","title":"read_configuration – Fortran Program"},{"text":"public subroutine rank_to_index(rank, nx, ny, nz, ix, iy, iz) Arguments Type Intent Optional Attributes Name integer, intent(in) :: rank integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz integer, intent(out) :: ix integer, intent(out) :: iy integer, intent(out) :: iz","tags":"","loc":"proc/rank_to_index.html","title":"rank_to_index – Fortran Program"},{"text":"public subroutine index_to_rank(ix, iy, iz, nx, ny, nz, rank) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ix integer, intent(in) :: iy integer, intent(in) :: iz integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz integer, intent(out) :: rank Variables Type Visibility Attributes Name Initial integer, public :: iix integer, public :: iiy integer, public :: iiz","tags":"","loc":"proc/index_to_rank.html","title":"index_to_rank – Fortran Program"},{"text":"public subroutine init_velocity_bins() Uses: spectrum_config Arguments None Variables Type Visibility Attributes Name Initial integer, public :: i","tags":"","loc":"proc/init_velocity_bins.html","title":"init_velocity_bins – Fortran Program"},{"text":"public subroutine free_velocity_bins() Arguments None","tags":"","loc":"proc/free_velocity_bins.html","title":"free_velocity_bins – Fortran Program"},{"text":"public subroutine init_vdist_2d() Uses: mpi_module spectrum_config Arguments None","tags":"","loc":"proc/init_vdist_2d.html","title":"init_vdist_2d – Fortran Program"},{"text":"public subroutine init_vdist_2d_single() Uses: spectrum_config Arguments None","tags":"","loc":"proc/init_vdist_2d_single.html","title":"init_vdist_2d_single – Fortran Program"},{"text":"public subroutine set_vdist_2d_zero_single() Arguments None","tags":"","loc":"proc/set_vdist_2d_zero_single.html","title":"set_vdist_2d_zero_single – Fortran Program"},{"text":"public subroutine set_vdist_2d_zero() Uses: mpi_module Arguments None","tags":"","loc":"proc/set_vdist_2d_zero.html","title":"set_vdist_2d_zero – Fortran Program"},{"text":"public subroutine free_vdist_2d() Uses: mpi_module Arguments None","tags":"","loc":"proc/free_vdist_2d.html","title":"free_vdist_2d – Fortran Program"},{"text":"public subroutine free_vdist_2d_single() Arguments None","tags":"","loc":"proc/free_vdist_2d_single.html","title":"free_vdist_2d_single – Fortran Program"},{"text":"public subroutine init_vdist_1d() Uses: mpi_module spectrum_config Arguments None","tags":"","loc":"proc/init_vdist_1d.html","title":"init_vdist_1d – Fortran Program"},{"text":"public subroutine init_vdist_1d_single() Uses: spectrum_config Arguments None","tags":"","loc":"proc/init_vdist_1d_single.html","title":"init_vdist_1d_single – Fortran Program"},{"text":"public subroutine set_vdist_1d_zero_single() Arguments None","tags":"","loc":"proc/set_vdist_1d_zero_single.html","title":"set_vdist_1d_zero_single – Fortran Program"},{"text":"public subroutine set_vdist_1d_zero() Uses: mpi_module Arguments None","tags":"","loc":"proc/set_vdist_1d_zero.html","title":"set_vdist_1d_zero – Fortran Program"},{"text":"public subroutine free_vdist_1d_single() Arguments None","tags":"","loc":"proc/free_vdist_1d_single.html","title":"free_vdist_1d_single – Fortran Program"},{"text":"public subroutine free_vdist_1d() Uses: mpi_module Arguments None","tags":"","loc":"proc/free_vdist_1d.html","title":"free_vdist_1d – Fortran Program"},{"text":"public subroutine calc_vdist_2d(ct, species) Uses: mpi_module constants particle_frames particle_file Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct character(len=1), intent(in) :: species Variables Type Visibility Attributes Name Initial integer, public :: tindex logical, public :: is_exist","tags":"","loc":"proc/calc_vdist_2d.html","title":"calc_vdist_2d – Fortran Program"},{"text":"public subroutine sum_vdist_2d_over_mpi() Uses: mpi_module spectrum_config Arguments None","tags":"","loc":"proc/sum_vdist_2d_over_mpi.html","title":"sum_vdist_2d_over_mpi – Fortran Program"},{"text":"public subroutine save_vdist_2d(ct, species) Uses: mpi_module spectrum_config Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct character(len=1), intent(in) :: species Variables Type Visibility Attributes Name Initial character(len=100), public :: fname logical, public :: dir_e","tags":"","loc":"proc/save_vdist_2d.html","title":"save_vdist_2d – Fortran Program"},{"text":"public subroutine calc_vdist_2d_single(tindex, species) Uses: picinfo file_header spectrum_config particle_file Arguments Type Intent Optional Attributes Name integer, intent(in) :: tindex character(len=1), intent(in) :: species Variables Type Visibility Attributes Name Initial character(len=50), public :: cid integer, public :: np integer, public :: iptl integer, public :: ix integer, public :: iy integer, public :: iz","tags":"","loc":"proc/calc_vdist_2d_single.html","title":"calc_vdist_2d_single – Fortran Program"},{"text":"public subroutine calc_vdist_1d(ct, species) Uses: mpi_module constants particle_frames particle_file Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct character(len=1), intent(in) :: species Variables Type Visibility Attributes Name Initial integer, public :: tindex logical, public :: is_exist","tags":"","loc":"proc/calc_vdist_1d.html","title":"calc_vdist_1d – Fortran Program"},{"text":"public subroutine sum_vdist_1d_over_mpi() Uses: mpi_module spectrum_config Arguments None","tags":"","loc":"proc/sum_vdist_1d_over_mpi.html","title":"sum_vdist_1d_over_mpi – Fortran Program"},{"text":"public subroutine save_vdist_1d(ct, species) Uses: mpi_module spectrum_config Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct character(len=1), intent(in) :: species Variables Type Visibility Attributes Name Initial character(len=100), public :: fname logical, public :: dir_e","tags":"","loc":"proc/save_vdist_1d.html","title":"save_vdist_1d – Fortran Program"},{"text":"public subroutine calc_vdist_1d_single(tindex, species) Uses: picinfo file_header spectrum_config particle_file Arguments Type Intent Optional Attributes Name integer, intent(in) :: tindex character(len=1), intent(in) :: species Variables Type Visibility Attributes Name Initial character(len=50), public :: cid integer, public :: np integer, public :: iptl integer, public :: ix integer, public :: iy integer, public :: iz","tags":"","loc":"proc/calc_vdist_1d_single.html","title":"calc_vdist_1d_single – Fortran Program"},{"text":"public subroutine update_vdist_2d() Arguments None","tags":"","loc":"proc/update_vdist_2d.html","title":"update_vdist_2d – Fortran Program"},{"text":"public subroutine update_vdist_1d() Uses: spectrum_config Arguments None","tags":"","loc":"proc/update_vdist_1d.html","title":"update_vdist_1d – Fortran Program"},{"text":"public subroutine get_nout() Arguments None Variables Type Visibility Attributes Name Initial logical, public :: dfile character(len=150), public :: fname","tags":"","loc":"proc/get_nout.html","title":"get_nout – Fortran Program"},{"text":"public subroutine adjust_tindex_start() Uses: mpi_module configuration_translate Arguments None Variables Type Visibility Attributes Name Initial character(len=150), public :: fname logical, public :: dfile","tags":"","loc":"proc/adjust_tindex_start.html","title":"adjust_tindex_start – Fortran Program"},{"text":"public subroutine set_output_record() Uses: configuration_translate Arguments None","tags":"","loc":"proc/set_output_record.html","title":"set_output_record – Fortran Program"},{"text":"public subroutine init_electric_fields() Uses: picinfo Arguments None","tags":"","loc":"proc/init_electric_fields.html","title":"init_electric_fields – Fortran Program"},{"text":"public subroutine free_electric_fields() Arguments None","tags":"","loc":"proc/free_electric_fields.html","title":"free_electric_fields – Fortran Program"},{"text":"public subroutine read_electric_fields(ct) Uses: mpi_module constants path_info parameters Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct Variables Type Visibility Attributes Name Initial character(len=150), public :: filename integer(kind=dp), public :: pos1 integer, public :: fh","tags":"","loc":"proc/read_electric_fields.html","title":"read_electric_fields – Fortran Program"},{"text":"public subroutine get_electric_field_at_point(x, z, dx, dz) Arguments Type Intent Optional Attributes Name real(kind=fp), intent(in) :: x real(kind=fp), intent(in) :: z real(kind=fp), intent(in) :: dx real(kind=fp), intent(in) :: dz Variables Type Visibility Attributes Name Initial real(kind=fp), public :: v1 real(kind=fp), public :: v2 real(kind=fp), public :: v3 real(kind=fp), public :: v4","tags":"","loc":"proc/get_electric_field_at_point.html","title":"get_electric_field_at_point – Fortran Program"},{"text":"public subroutine read_boilerplate(fh) Arguments Type Intent Optional Attributes Name integer, intent(in) :: fh Variables Type Visibility Attributes Name Initial integer(kind=1), public :: sizearr (5) integer(kind=2), public :: cafevar integer(kind=4), public :: deadbeefvar real(kind=4), public :: realone real(kind=8), public :: doubleone","tags":"","loc":"proc/read_boilerplate.html","title":"read_boilerplate – Fortran Program"},{"text":"public subroutine read_fields_header(fh) Arguments Type Intent Optional Attributes Name integer, intent(in) :: fh","tags":"","loc":"proc/read_fields_header.html","title":"read_fields_header – Fortran Program"},{"text":"public subroutine read_particle_header(fh) Arguments Type Intent Optional Attributes Name integer, intent(in) :: fh","tags":"","loc":"proc/read_particle_header.html","title":"read_particle_header – Fortran Program"},{"text":"public subroutine get_ptl_mass_charge(species) Uses: constants picinfo Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: species","tags":"","loc":"proc/get_ptl_mass_charge.html","title":"get_ptl_mass_charge – Fortran Program"},{"text":"public subroutine init_emfields() Uses: picinfo Arguments None","tags":"","loc":"proc/init_emfields~2.html","title":"init_emfields – Fortran Program"},{"text":"public subroutine init_emfields_derivatives() Uses: picinfo Arguments None","tags":"","loc":"proc/init_emfields_derivatives.html","title":"init_emfields_derivatives – Fortran Program"},{"text":"public subroutine free_emfields() Arguments None","tags":"","loc":"proc/free_emfields~2.html","title":"free_emfields – Fortran Program"},{"text":"public subroutine free_emfields_derivatives() Arguments None","tags":"","loc":"proc/free_emfields_derivatives.html","title":"free_emfields_derivatives – Fortran Program"},{"text":"public subroutine read_emfields_single(tindex0, pic_mpi_id) Uses: constants neighbors_module picinfo Arguments Type Intent Optional Attributes Name integer, intent(in) :: tindex0 integer, intent(in) :: pic_mpi_id Variables Type Visibility Attributes Name Initial integer, public :: nxl integer, public :: nxh integer, public :: nyl integer, public :: nyh integer, public :: nzl integer, public :: nzh integer, public :: fh","tags":"","loc":"proc/read_emfields_single.html","title":"read_emfields_single – Fortran Program"},{"text":"public subroutine calc_emfields_derivatives() Uses: picinfo neighbors_module Arguments None Variables Type Visibility Attributes Name Initial integer, public :: ix integer, public :: iy integer, public :: iz","tags":"","loc":"proc/calc_emfields_derivatives.html","title":"calc_emfields_derivatives – Fortran Program"},{"text":"public subroutine calc_interp_weights(dx, dy, dz) Arguments Type Intent Optional Attributes Name real(kind=fp), intent(in) :: dx real(kind=fp), intent(in) :: dy real(kind=fp), intent(in) :: dz","tags":"","loc":"proc/calc_interp_weights.html","title":"calc_interp_weights – Fortran Program"},{"text":"public subroutine trilinear_interp_bx(ix0, iy0, iz0, dx, dy, dz) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ix0 integer, intent(in) :: iy0 integer, intent(in) :: iz0 real(kind=fp), intent(in) :: dx real(kind=fp), intent(in) :: dy real(kind=fp), intent(in) :: dz","tags":"","loc":"proc/trilinear_interp_bx.html","title":"trilinear_interp_bx – Fortran Program"},{"text":"public subroutine trilinear_interp_by(ix0, iy0, iz0, dx, dy, dz) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ix0 integer, intent(in) :: iy0 integer, intent(in) :: iz0 real(kind=fp), intent(in) :: dx real(kind=fp), intent(in) :: dy real(kind=fp), intent(in) :: dz","tags":"","loc":"proc/trilinear_interp_by.html","title":"trilinear_interp_by – Fortran Program"},{"text":"public subroutine trilinear_interp_bz(ix0, iy0, iz0, dx, dy, dz) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ix0 integer, intent(in) :: iy0 integer, intent(in) :: iz0 real(kind=fp), intent(in) :: dx real(kind=fp), intent(in) :: dy real(kind=fp), intent(in) :: dz","tags":"","loc":"proc/trilinear_interp_bz.html","title":"trilinear_interp_bz – Fortran Program"},{"text":"public subroutine trilinear_interp_ex(ix0, iy0, iz0, dx, dy, dz) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ix0 integer, intent(in) :: iy0 integer, intent(in) :: iz0 real(kind=fp), intent(in) :: dx real(kind=fp), intent(in) :: dy real(kind=fp), intent(in) :: dz","tags":"","loc":"proc/trilinear_interp_ex.html","title":"trilinear_interp_ex – Fortran Program"},{"text":"public subroutine trilinear_interp_ey(ix0, iy0, iz0, dx, dy, dz) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ix0 integer, intent(in) :: iy0 integer, intent(in) :: iz0 real(kind=fp), intent(in) :: dx real(kind=fp), intent(in) :: dy real(kind=fp), intent(in) :: dz","tags":"","loc":"proc/trilinear_interp_ey.html","title":"trilinear_interp_ey – Fortran Program"},{"text":"public subroutine trilinear_interp_ez(ix0, iy0, iz0, dx, dy, dz) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ix0 integer, intent(in) :: iy0 integer, intent(in) :: iz0 real(kind=fp), intent(in) :: dx real(kind=fp), intent(in) :: dy real(kind=fp), intent(in) :: dz","tags":"","loc":"proc/trilinear_interp_ez.html","title":"trilinear_interp_ez – Fortran Program"},{"text":"public subroutine calc_b_norm() Arguments None Variables Type Visibility Attributes Name Initial real(kind=fp), public :: ib","tags":"","loc":"proc/calc_b_norm.html","title":"calc_b_norm – Fortran Program"},{"text":"public subroutine calc_gradient_B() Arguments None","tags":"","loc":"proc/calc_gradient_b.html","title":"calc_gradient_B – Fortran Program"},{"text":"public subroutine calc_curvature() Arguments None Variables Type Visibility Attributes Name Initial real(kind=fp), public :: b_dot_gradB real(kind=fp), public :: ib2 real(kind=fp), public :: ib","tags":"","loc":"proc/calc_curvature.html","title":"calc_curvature – Fortran Program"},{"text":"public subroutine particle_spectrum_vdist_main() Uses: commandline_arguments Arguments None Variables Type Visibility Attributes Name Initial integer, public :: ct integer, public :: ct_field integer, public :: ratio_particle_field real(kind=dp), public :: mp_elapsed","tags":"","loc":"proc/particle_spectrum_vdist_main.html","title":"particle_spectrum_vdist_main – Fortran Program"},{"text":"public subroutine init_scalar_pressure() Arguments None","tags":"","loc":"proc/init_scalar_pressure.html","title":"init_scalar_pressure – Fortran Program"},{"text":"public subroutine init_div_ptensor() Arguments None","tags":"","loc":"proc/init_div_ptensor.html","title":"init_div_ptensor – Fortran Program"},{"text":"public subroutine init_grad_pscalar() Arguments None","tags":"","loc":"proc/init_grad_pscalar.html","title":"init_grad_pscalar – Fortran Program"},{"text":"public subroutine free_scalar_pressure() Arguments None","tags":"","loc":"proc/free_scalar_pressure.html","title":"free_scalar_pressure – Fortran Program"},{"text":"public subroutine free_div_ptensor() Arguments None","tags":"","loc":"proc/free_div_ptensor.html","title":"free_div_ptensor – Fortran Program"},{"text":"public subroutine free_grad_pscalar() Arguments None","tags":"","loc":"proc/free_grad_pscalar.html","title":"free_grad_pscalar – Fortran Program"},{"text":"public subroutine calc_scalar_pressure() Arguments None","tags":"","loc":"proc/calc_scalar_pressure.html","title":"calc_scalar_pressure – Fortran Program"},{"text":"public subroutine calc_div_ptensor() Uses: constants neighbors_module Arguments None Variables Type Visibility Attributes Name Initial integer, public :: nx integer, public :: ny integer, public :: nz integer, public :: ix integer, public :: iy integer, public :: iz","tags":"","loc":"proc/calc_div_ptensor.html","title":"calc_div_ptensor – Fortran Program"},{"text":"public subroutine calc_grad_pscalar() Uses: constants neighbors_module Arguments None Variables Type Visibility Attributes Name Initial integer, public :: nx integer, public :: ny integer, public :: nz integer, public :: ix integer, public :: iy integer, public :: iz","tags":"","loc":"proc/calc_grad_pscalar.html","title":"calc_grad_pscalar – Fortran Program"},{"text":"public subroutine init_magnetic_fields() Uses: picinfo Arguments None","tags":"","loc":"proc/init_magnetic_fields.html","title":"init_magnetic_fields – Fortran Program"},{"text":"public subroutine free_magnetic_fields() Arguments None","tags":"","loc":"proc/free_magnetic_fields.html","title":"free_magnetic_fields – Fortran Program"},{"text":"public subroutine read_magnetic_fields(ct) Uses: mpi_module constants path_info parameters Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct Variables Type Visibility Attributes Name Initial character(len=150), public :: filename integer(kind=dp), public :: pos1 integer, public :: fh","tags":"","loc":"proc/read_magnetic_fields.html","title":"read_magnetic_fields – Fortran Program"},{"text":"public subroutine get_magnetic_field_at_point(x, z, dx, dz) Arguments Type Intent Optional Attributes Name real(kind=fp), intent(in) :: x real(kind=fp), intent(in) :: z real(kind=fp), intent(in) :: dx real(kind=fp), intent(in) :: dz Variables Type Visibility Attributes Name Initial real(kind=fp), public :: v1 real(kind=fp), public :: v2 real(kind=fp), public :: v3 real(kind=fp), public :: v4","tags":"","loc":"proc/get_magnetic_field_at_point.html","title":"get_magnetic_field_at_point – Fortran Program"},{"text":"public subroutine get_cmdline_arguments() Arguments None Variables Type Visibility Attributes Name Initial character(len=STRLEN), public :: config_dist","tags":"","loc":"proc/get_cmdline_arguments.html","title":"get_cmdline_arguments – Fortran Program"},{"text":"public subroutine init_inductive_electric_field() Uses: mpi_topology Arguments None Variables Type Visibility Attributes Name Initial integer, public :: nx integer, public :: ny integer, public :: nz","tags":"","loc":"proc/init_inductive_electric_field.html","title":"init_inductive_electric_field – Fortran Program"},{"text":"public subroutine free_inductive_electric_field() Arguments None","tags":"","loc":"proc/free_inductive_electric_field.html","title":"free_inductive_electric_field – Fortran Program"},{"text":"public subroutine init_inductive(species) Uses: usingle Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: species","tags":"","loc":"proc/init_inductive.html","title":"init_inductive – Fortran Program"},{"text":"public subroutine free_inductive(species) Uses: usingle Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: species","tags":"","loc":"proc/free_inductive.html","title":"free_inductive – Fortran Program"},{"text":"public subroutine calc_inductive_e(ct, species) Uses: mpi_module parameters pic_fields picinfo mpi_datatype_fields mpi_io_module usingle Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct character(len=*), intent(in) :: species","tags":"","loc":"proc/calc_inductive_e.html","title":"calc_inductive_e – Fortran Program"},{"text":"public subroutine init_analysis(ct) Uses: path_info picinfo particle_frames fieldline_tracing magnetic_field parameters Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct","tags":"","loc":"proc/init_analysis~2.html","title":"init_analysis – Fortran Program"},{"text":"public subroutine get_fieldline_points(x0, z0) Uses: fieldline_tracing mpi_topology Arguments Type Intent Optional Attributes Name real(kind=fp), intent(in) :: x0 real(kind=fp), intent(in) :: z0","tags":"","loc":"proc/get_fieldline_points.html","title":"get_fieldline_points – Fortran Program"},{"text":"public subroutine end_analysis() Uses: fieldline_tracing Arguments None","tags":"","loc":"proc/end_analysis~2.html","title":"end_analysis – Fortran Program"},{"text":"public subroutine get_particle_frames() Arguments None Variables Type Visibility Attributes Name Initial character(len=64), public :: fpath","tags":"","loc":"proc/get_particle_frames.html","title":"get_particle_frames – Fortran Program"},{"text":"public subroutine get_particle_frames_hydro() Arguments None Variables Type Visibility Attributes Name Initial character(len=64), public :: fpath","tags":"","loc":"proc/get_particle_frames_hydro.html","title":"get_particle_frames_hydro – Fortran Program"},{"text":"public subroutine init_pre_post_velocities() Uses: mpi_topology Arguments None Variables Type Visibility Attributes Name Initial integer, public :: nx integer, public :: ny integer, public :: nz","tags":"","loc":"proc/init_pre_post_velocities.html","title":"init_pre_post_velocities – Fortran Program"},{"text":"public subroutine free_pre_post_velocities() Arguments None","tags":"","loc":"proc/free_pre_post_velocities.html","title":"free_pre_post_velocities – Fortran Program"},{"text":"public subroutine read_pre_post_velocities(ct, fh) Uses: mpi_module constants parameters picinfo mpi_datatype_fields mpi_io_module pic_fields Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct integer, intent(in), dimension(3) :: fh Variables Type Visibility Attributes Name Initial integer(kind=MPI_OFFSET_KIND), public :: disp integer(kind=MPI_OFFSET_KIND), public :: offset","tags":"","loc":"proc/read_pre_post_velocities.html","title":"read_pre_post_velocities – Fortran Program"},{"text":"public subroutine init_pre_post_density() Uses: mpi_topology Arguments None Variables Type Visibility Attributes Name Initial integer, public :: nx integer, public :: ny integer, public :: nz","tags":"","loc":"proc/init_pre_post_density.html","title":"init_pre_post_density – Fortran Program"},{"text":"public subroutine free_pre_post_density() Arguments None","tags":"","loc":"proc/free_pre_post_density.html","title":"free_pre_post_density – Fortran Program"},{"text":"public subroutine read_pre_post_density(ct, fh) Uses: mpi_module constants parameters picinfo mpi_datatype_fields mpi_io_module pic_fields Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct integer, intent(in) :: fh Variables Type Visibility Attributes Name Initial integer(kind=MPI_OFFSET_KIND), public :: disp integer(kind=MPI_OFFSET_KIND), public :: offset","tags":"","loc":"proc/read_pre_post_density.html","title":"read_pre_post_density – Fortran Program"},{"text":"public subroutine init_current_densities() Uses: mpi_topology Arguments None Variables Type Visibility Attributes Name Initial integer, public :: nx integer, public :: ny integer, public :: nz","tags":"","loc":"proc/init_current_densities~2.html","title":"init_current_densities – Fortran Program"},{"text":"public subroutine init_ava_current_densities() Uses: parameters Arguments None","tags":"","loc":"proc/init_ava_current_densities.html","title":"init_ava_current_densities – Fortran Program"},{"text":"public subroutine free_avg_current_densities() Arguments None","tags":"","loc":"proc/free_avg_current_densities.html","title":"free_avg_current_densities – Fortran Program"},{"text":"public subroutine set_current_densities_to_zero() Arguments None","tags":"","loc":"proc/set_current_densities_to_zero.html","title":"set_current_densities_to_zero – Fortran Program"},{"text":"public subroutine free_current_densities() Arguments None","tags":"","loc":"proc/free_current_densities~2.html","title":"free_current_densities – Fortran Program"},{"text":"public subroutine calc_current_densities(ct) Uses: mpi_module constants saving_flags jdote_module mpi_io_fields parameters Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct Variables Type Visibility Attributes Name Initial integer, public :: t","tags":"","loc":"proc/calc_current_densities.html","title":"calc_current_densities – Fortran Program"},{"text":"public subroutine save_averaged_current() Uses: constants parameters particle_info Arguments None Variables Type Visibility Attributes Name Initial integer, public :: pos1 integer, public :: output_record integer, public :: ct logical, public :: dir_e","tags":"","loc":"proc/save_averaged_current.html","title":"save_averaged_current – Fortran Program"},{"text":"public subroutine init_neighbors(nx0, ny0, nz0) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nx0 integer, intent(in) :: ny0 integer, intent(in) :: nz0","tags":"","loc":"proc/init_neighbors.html","title":"init_neighbors – Fortran Program"},{"text":"public subroutine free_neighbors() Arguments None","tags":"","loc":"proc/free_neighbors.html","title":"free_neighbors – Fortran Program"},{"text":"public subroutine get_neighbors() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: ix integer, public :: iy integer, public :: iz","tags":"","loc":"proc/get_neighbors.html","title":"get_neighbors – Fortran Program"},{"text":"public subroutine get_mpi_neighbors(pic_mpi_id, nxl, nxh, nyl, nyh, nzl, nzh) Uses: picinfo Arguments Type Intent Optional Attributes Name integer, intent(in) :: pic_mpi_id integer, intent(out) :: nxl integer, intent(out) :: nxh integer, intent(out) :: nyl integer, intent(out) :: nyh integer, intent(out) :: nzl integer, intent(out) :: nzh Variables Type Visibility Attributes Name Initial integer, public :: ix integer, public :: iy integer, public :: iz integer, public :: tx integer, public :: ty integer, public :: tz","tags":"","loc":"proc/get_mpi_neighbors.html","title":"get_mpi_neighbors – Fortran Program"},{"text":"public subroutine get_saving_flags() Uses: read_config Arguments None Variables Type Visibility Attributes Name Initial integer, public :: fh","tags":"","loc":"proc/get_saving_flags.html","title":"get_saving_flags – Fortran Program"},{"text":"subroutine commit_analysis() Uses: mpi_topology particle_info para_perp_pressure pic_fields saving_flags neighbors_module compression_shear configuration_translate Arguments None","tags":"","loc":"proc/commit_analysis.html","title":"commit_analysis – Fortran Program"},{"text":"subroutine energy_conversion_from_current() Uses: mpi_module picinfo parameters particle_info pic_fields pic_fields inductive_electric_field previous_post_velocities previous_post_density current_densities para_perp_pressure jdote_module configuration_translate Arguments None Variables Type Visibility Attributes Name Initial integer, public :: input_record integer, public :: output_record integer, public :: tindex","tags":"","loc":"proc/energy_conversion_from_current.html","title":"energy_conversion_from_current – Fortran Program"},{"text":"subroutine calc_energy_conversion(ct) Uses: para_perp_pressure current_densities Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct","tags":"","loc":"proc/calc_energy_conversion.html","title":"calc_energy_conversion – Fortran Program"},{"text":"subroutine commit_analysis() Uses: mpi_module constants mpi_topology pic_fields particle_info parameters mpi_io_fields statistics Arguments None Variables Type Visibility Attributes Name Initial real(kind=fp), public, allocatable, dimension(:, :) :: bulk_energy real(kind=fp), public, allocatable, dimension(:, :) :: internal_energy real(kind=fp), public, dimension(4) :: bene_tot real(kind=fp), public, dimension(4) :: iene_tot real(kind=fp), public :: avg logical, public :: dir_e integer, public :: ct","tags":"","loc":"proc/commit_analysis~2.html","title":"commit_analysis – Fortran Program"},{"text":"subroutine calc_vdist_1d_fieldline(species) Uses: spectrum_config spectrum_config velocity_distribution fieldline_tracing particle_frames particle_file particle_fieldline Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: species Variables Type Visibility Attributes Name Initial integer, public :: i","tags":"","loc":"proc/calc_vdist_1d_fieldline.html","title":"calc_vdist_1d_fieldline – Fortran Program"},{"text":"subroutine check_folder_exist() Arguments None Variables Type Visibility Attributes Name Initial logical, public :: dir_e","tags":"","loc":"proc/check_folder_exist.html","title":"check_folder_exist – Fortran Program"},{"text":"subroutine write_vdist_1d(species) Uses: mpi_module mpi_io_module mpi_datatype_module mpi_info_module velocity_distribution particle_fieldline spectrum_config Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: species Variables Type Visibility Attributes Name Initial integer, public, dimension(2) :: sizes_short integer, public, dimension(2) :: sizes_long integer, public, dimension(2) :: subsizes_short integer, public, dimension(2) :: subsizes_long integer, public, dimension(2) :: starts integer(kind=MPI_OFFSET_KIND), public :: disp integer(kind=MPI_OFFSET_KIND), public :: offset character(len=150), public :: fname integer, public :: datatype_short integer, public :: datatype_long integer, public :: fh integer, public :: pos1 integer, public :: nbins","tags":"","loc":"proc/write_vdist_1d.html","title":"write_vdist_1d – Fortran Program"},{"text":"subroutine init_data() Uses: mpi_topology Arguments None Variables Type Visibility Attributes Name Initial integer, public :: nx integer, public :: ny integer, public :: nz","tags":"","loc":"proc/init_data.html","title":"init_data – Fortran Program"},{"text":"subroutine free_data() Arguments None","tags":"","loc":"proc/free_data.html","title":"free_data – Fortran Program"},{"text":"subroutine init_pic_fields() Uses: mpi_topology pic_fields Arguments None Variables Type Visibility Attributes Name Initial integer, public :: nx integer, public :: ny integer, public :: nz","tags":"","loc":"proc/init_pic_fields.html","title":"init_pic_fields – Fortran Program"},{"text":"subroutine open_pic_fields(species) Uses: pic_fields Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: species","tags":"","loc":"proc/open_pic_fields.html","title":"open_pic_fields – Fortran Program"},{"text":"subroutine read_pic_fields(ct) Uses: pic_fields Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct","tags":"","loc":"proc/read_pic_fields.html","title":"read_pic_fields – Fortran Program"},{"text":"subroutine close_pic_fields_file() Uses: pic_fields Arguments None","tags":"","loc":"proc/close_pic_fields_file.html","title":"close_pic_fields_file – Fortran Program"},{"text":"subroutine free_pic_fields() Uses: pic_fields Arguments None","tags":"","loc":"proc/free_pic_fields.html","title":"free_pic_fields – Fortran Program"},{"text":"subroutine open_hdf5_parallel(filename, groupname) Uses: mpi_info_module Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: groupname Variables Type Visibility Attributes Name Initial integer, public :: error","tags":"","loc":"proc/open_hdf5_parallel.html","title":"open_hdf5_parallel – Fortran Program"},{"text":"subroutine read_hdf5_parallel() Arguments None","tags":"","loc":"proc/read_hdf5_parallel.html","title":"read_hdf5_parallel – Fortran Program"},{"text":"subroutine commit_analysis() Uses: mpi_module mpi_topology particle_info para_perp_pressure pic_fields saving_flags neighbors_module compression_shear pressure_tensor parameters Arguments None Variables Type Visibility Attributes Name Initial integer, public :: input_record integer, public :: output_record","tags":"","loc":"proc/commit_analysis~3.html","title":"commit_analysis – Fortran Program"},{"text":"subroutine calc_vdist_2d_fieldline(species) Uses: spectrum_config spectrum_config velocity_distribution fieldline_tracing particle_frames particle_file particle_fieldline Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: species Variables Type Visibility Attributes Name Initial integer, public :: i","tags":"","loc":"proc/calc_vdist_2d_fieldline.html","title":"calc_vdist_2d_fieldline – Fortran Program"},{"text":"subroutine check_folder_exist() Arguments None Variables Type Visibility Attributes Name Initial logical, public :: dir_e","tags":"","loc":"proc/check_folder_exist~2.html","title":"check_folder_exist – Fortran Program"},{"text":"subroutine write_vdist_2d(species) Uses: mpi_module mpi_io_module mpi_datatype_module mpi_info_module velocity_distribution particle_fieldline spectrum_config Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: species Variables Type Visibility Attributes Name Initial integer, public, dimension(3) :: sizes_short integer, public, dimension(3) :: sizes_long integer, public, dimension(3) :: subsizes_short integer, public, dimension(3) :: subsizes_long integer, public, dimension(3) :: starts integer(kind=MPI_OFFSET_KIND), public :: disp integer(kind=MPI_OFFSET_KIND), public :: offset character(len=150), public :: fname integer, public :: datatype_short integer, public :: datatype_long integer, public :: fh integer, public :: pos1 integer, public :: nbins","tags":"","loc":"proc/write_vdist_2d.html","title":"write_vdist_2d – Fortran Program"},{"text":"subroutine init_analysis() Uses: mpi_module path_info picinfo configuration_translate topology_translate time_info mpi_io_translate emfields particle_fields parameters Arguments None","tags":"","loc":"proc/init_analysis~3.html","title":"init_analysis – Fortran Program"},{"text":"subroutine end_analysis() Uses: mpi_module topology_translate mpi_io_translate mpi_info_module emfields particle_fields Arguments None","tags":"","loc":"proc/end_analysis~3.html","title":"end_analysis – Fortran Program"},{"text":"subroutine get_spectra_config() Uses: path_info read_config spectrum_config Arguments None Variables Type Visibility Attributes Name Initial integer, public :: fh real(kind=fp), public :: tmp","tags":"","loc":"proc/get_spectra_config.html","title":"get_spectra_config – Fortran Program"},{"text":"subroutine get_energy_spectrum(ct, species) Uses: particle_frames path_info picinfo particle_energy_spectrum Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct character(len=1), intent(in) :: species Variables Type Visibility Attributes Name Initial character(len=256), public :: fpath character(len=256), public :: dataset character(len=256), public :: fname character(len=16), public :: cid character(len=16), public :: ctindex character(len=1), public :: ptl integer, public :: np integer, public :: fh integer, public :: tindex integer, public :: stat integer, public :: access","tags":"","loc":"proc/get_energy_spectrum.html","title":"get_energy_spectrum – Fortran Program"},{"text":"subroutine init_spectrum_one_core() Uses: spectrum_config Arguments None","tags":"","loc":"proc/init_spectrum_one_core.html","title":"init_spectrum_one_core – Fortran Program"},{"text":"subroutine free_spectrum_one_core() Arguments None","tags":"","loc":"proc/free_spectrum_one_core.html","title":"free_spectrum_one_core – Fortran Program"},{"text":"subroutine differentiate_spectrum() Uses: spectrum_config particle_energy_spectrum Arguments None Variables Type Visibility Attributes Name Initial integer, public :: i","tags":"","loc":"proc/differentiate_spectrum.html","title":"differentiate_spectrum – Fortran Program"},{"text":"subroutine init_calculation() Uses: mpi_module picinfo Arguments None","tags":"","loc":"proc/init_calculation.html","title":"init_calculation – Fortran Program"},{"text":"subroutine end_calculation() Uses: mpi_module Arguments None","tags":"","loc":"proc/end_calculation.html","title":"end_calculation – Fortran Program"},{"text":"subroutine calc_phi_parallel(ct) Uses: mpi_module constants fieldline_tracing Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: k real(kind=fp), public :: x real(kind=fp), public :: z real(kind=fp), public :: h real(kind=fp), public :: hinit real(kind=fp), public :: phi_parallel1 real(kind=fp), public :: phi_parallel2","tags":"","loc":"proc/calc_phi_parallel.html","title":"calc_phi_parallel – Fortran Program"},{"text":"subroutine tracing(x, z, htry, phi_parallel, direction_flag) Uses: fieldline_tracing Arguments Type Intent Optional Attributes Name real(kind=fp), intent(inout) :: x real(kind=fp), intent(inout) :: z real(kind=fp), intent(in) :: htry real(kind=fp), intent(inout) :: phi_parallel integer, intent(in) :: direction_flag Variables Type Visibility Attributes Name Initial real(kind=fp), public, dimension(0:6) :: kx real(kind=fp), public, dimension(0:6) :: ky real(kind=fp), public, dimension(0:6) :: kz real(kind=fp), public :: arc_length real(kind=fp), public :: xout real(kind=fp), public :: zout real(kind=fp), public :: xold real(kind=fp), public :: zold real(kind=fp), public :: dxds real(kind=fp), public :: dyds real(kind=fp), public :: dzds real(kind=fp), public :: dxdsnew real(kind=fp), public :: dydsnew real(kind=fp), public :: dzdsnew real(kind=fp), public :: xcross real(kind=fp), public :: zcross real(kind=fp), public :: h real(kind=fp), public :: hnext real(kind=fp), public :: errold real(kind=fp), public :: h_old logical, public :: is_accept","tags":"","loc":"proc/tracing~2.html","title":"tracing – Fortran Program"},{"text":"subroutine update_phi_parallel(xold, zold, kx, ky, kz, h, phi_parallel) Uses: constants fieldline_tracing electric_field Arguments Type Intent Optional Attributes Name real(kind=fp), intent(in) :: xold real(kind=fp), intent(in) :: zold real(kind=fp), intent(in), dimension(0:6) :: kx real(kind=fp), intent(in), dimension(0:6) :: ky real(kind=fp), intent(in), dimension(0:6) :: kz real(kind=fp), intent(in) :: h real(kind=fp), intent(inout) :: phi_parallel Variables Type Visibility Attributes Name Initial real(kind=fp), public, dimension(0:6) :: exs real(kind=fp), public, dimension(0:6) :: eys real(kind=fp), public, dimension(0:6) :: ezs real(kind=fp), public :: xtemp real(kind=fp), public :: ztemp integer, public :: i","tags":"","loc":"proc/update_phi_parallel.html","title":"update_phi_parallel – Fortran Program"},{"text":"subroutine save_phi_parallel(ct) Uses: mpi_module parameters mpi_io_module mpi_info_module path_info Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct Variables Type Visibility Attributes Name Initial integer, public, dimension(2) :: sizes integer, public, dimension(2) :: subsizes integer, public, dimension(2) :: starts integer, public :: filetype integer, public :: fh integer(kind=MPI_OFFSET_KIND), public :: disp integer(kind=MPI_OFFSET_KIND), public :: offset logical, public :: dir_e","tags":"","loc":"proc/save_phi_parallel.html","title":"save_phi_parallel – Fortran Program"},{"text":"subroutine calc_particle_energy_spectrum(species) Uses: spectrum_config spectrum_config particle_energy_spectrum fieldline_tracing particle_frames particle_file particle_fieldline Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: species Variables Type Visibility Attributes Name Initial integer, public :: i","tags":"","loc":"proc/calc_particle_energy_spectrum.html","title":"calc_particle_energy_spectrum – Fortran Program"},{"text":"subroutine check_folder_exist() Arguments None Variables Type Visibility Attributes Name Initial logical, public :: dir_e","tags":"","loc":"proc/check_folder_exist~3.html","title":"check_folder_exist – Fortran Program"},{"text":"subroutine write_particle_spectrum(species) Uses: mpi_module mpi_io_module mpi_datatype_module mpi_info_module particle_energy_spectrum particle_fieldline Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: species Variables Type Visibility Attributes Name Initial integer, public, dimension(2) :: sizes integer, public, dimension(2) :: subsizes integer, public, dimension(2) :: starts integer(kind=MPI_OFFSET_KIND), public :: disp integer(kind=MPI_OFFSET_KIND), public :: offset character(len=150), public :: fname integer, public :: datatype integer, public :: fh integer, public :: pos1","tags":"","loc":"proc/write_particle_spectrum.html","title":"write_particle_spectrum – Fortran Program"},{"text":"subroutine init_analysis() Uses: mpi_module particle_info path_info picinfo configuration_translate topology_translate time_info mpi_io_translate parameters interpolation_emf particle_drift neighbors_module particle_fields Arguments None Variables Type Visibility Attributes Name Initial integer, public :: nx integer, public :: ny integer, public :: nz","tags":"","loc":"proc/init_analysis~4.html","title":"init_analysis – Fortran Program"},{"text":"subroutine commit_analysis() Uses: mpi_module constants configuration_translate time_info path_info particle_drift picinfo Arguments None Variables Type Visibility Attributes Name Initial integer, public :: tindex integer, public :: tindex_new integer, public :: ct character(len=150), public :: fname real(kind=dp), public :: mp_elapsed logical, public :: dfile","tags":"","loc":"proc/commit_analysis~4.html","title":"commit_analysis – Fortran Program"},{"text":"subroutine analysis_single_frame(tindex0, ct, output_record) Uses: particle_info interpolation_emf particle_drift rank_index_mapping picinfo topology_translate particle_fields Arguments Type Intent Optional Attributes Name integer, intent(in) :: tindex0 integer, intent(in) :: ct integer, intent(in) :: output_record Variables Type Visibility Attributes Name Initial integer, public :: dom_x integer, public :: dom_y integer, public :: dom_z integer, public :: n integer, public :: ix integer, public :: iy integer, public :: iz","tags":"","loc":"proc/analysis_single_frame.html","title":"analysis_single_frame – Fortran Program"},{"text":"subroutine end_analysis() Uses: mpi_module topology_translate mpi_io_translate mpi_info_module interpolation_emf particle_drift neighbors_module particle_fields Arguments None","tags":"","loc":"proc/end_analysis~4.html","title":"end_analysis – Fortran Program"},{"text":"Uses: constants Variables Type Visibility Attributes Name Initial integer, public :: nbins real(kind=fp), public :: emax real(kind=fp), public :: emin real(kind=fp), public :: dve real(kind=fp), public :: dlogve real(kind=fp), public :: vmax real(kind=fp), public :: vmin real(kind=fp), public :: dv integer, public :: nbins_vdist integer, public :: tframe real(kind=fp), public, dimension(3) :: center real(kind=fp), public, dimension(3) :: sizes real(kind=fp), public, dimension(2,3) :: spatial_range integer, public, dimension(2,3) :: corners_mpi integer, public :: tot_pic_mpi integer, public, allocatable, dimension(:) :: pic_mpi_ranks character(len=64), public :: config_name Subroutines public subroutine read_spectrum_config () Arguments None public subroutine calc_energy_interval () Arguments None public subroutine calc_velocity_interval () Arguments None public subroutine init_pic_mpi_ranks () Arguments None public subroutine calc_pic_mpi_ranks () Arguments None public subroutine free_pic_mpi_ranks () Arguments None public subroutine set_spatial_range_de () Arguments None public subroutine calc_pic_mpi_ids () Arguments None","tags":"","loc":"module/spectrum_config.html","title":"spectrum_config – Fortran Program"},{"text":"Uses: constants Variables Type Visibility Attributes Name Initial real(kind=fp), public, allocatable, dimension(:, :, :) :: jdote real(kind=fp), public, allocatable, dimension(:, :) :: jdote_tot Subroutines public subroutine init_jdote () Arguments None public subroutine init_jdote_total () Arguments None public subroutine free_jdote () Arguments None public subroutine free_jdote_total () Arguments None public subroutine save_jdote_total () Arguments None public subroutine calc_jdote (jx, jy, jz, jdote_tot) Arguments Type Intent Optional Attributes Name real(kind=fp), intent(in), dimension(:, :, :) :: jx real(kind=fp), intent(in), dimension(:, :, :) :: jy real(kind=fp), intent(in), dimension(:, :, :) :: jz real(kind=fp), intent(out) :: jdote_tot","tags":"","loc":"module/jdote_module.html","title":"jdote_module – Fortran Program"},{"text":"Variables Type Visibility Attributes Name Initial integer, public :: tp1 integer, public :: tp2 integer, public :: inductive integer, public :: is_rel Subroutines public subroutine get_start_end_time_points () Arguments None public subroutine get_inductive_flag () Arguments None public subroutine get_relativistic_flag () Arguments None","tags":"","loc":"module/parameters.html","title":"parameters – Fortran Program"},{"text":"Uses: constants picinfo path_info interpolation_emf mpi_module Subroutines public subroutine init_drift_fields () Arguments None public subroutine set_drift_fields_zero () Arguments None public subroutine init_para_perp_fields () Arguments None public subroutine set_para_perp_fields_zero () Arguments None public subroutine init_jdote_sum () Arguments None public subroutine free_drift_fields () Arguments None public subroutine free_para_perp_fields () Arguments None public subroutine free_jdote_sum () Arguments None public subroutine calc_particle_energy_change_rate (tindex, species, np, sx, sy, sz) Arguments Type Intent Optional Attributes Name integer, intent(in) :: tindex character(len=1), intent(in) :: species integer, intent(in) :: np integer, intent(in) :: sx integer, intent(in) :: sy integer, intent(in) :: sz public subroutine save_data_arrays (tindex, output_record) Arguments Type Intent Optional Attributes Name integer, intent(in) :: tindex integer, intent(in) :: output_record public subroutine sum_data_arrays (ct) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct public subroutine save_jdote_sum () Arguments None","tags":"","loc":"module/particle_drift.html","title":"particle_drift – Fortran Program"},{"text":"Functions public function get_variable (fh, var_name, delimiter) result(var_value) Arguments Type Intent Optional Attributes Name integer, intent(in) :: fh character(len=*), intent(in) :: var_name character(len=*), intent(in) :: delimiter Return Value real(kind=fp) public function get_variable_int (fh, var_name, delimiter) result(var_value_int) Arguments Type Intent Optional Attributes Name integer, intent(in) :: fh character(len=*), intent(in) :: var_name character(len=*), intent(in) :: delimiter Return Value integer","tags":"","loc":"module/read_config.html","title":"read_config – Fortran Program"},{"text":"Uses: constants path_info read_config Variables Type Visibility Attributes Name Initial type( picdomain ), public :: domain real(kind=fp), public :: mime integer, public :: nt integer, public :: nbands real(kind=fp), public :: emax real(kind=fp), public :: einterval_e real(kind=fp), public :: einterval_i Derived Types type, public :: picdomain Components Type Visibility Attributes Name Initial real(kind=dp), public :: dx real(kind=dp), public :: dy real(kind=dp), public :: dz real(kind=dp), public :: idx real(kind=dp), public :: idy real(kind=dp), public :: idz real(kind=dp), public :: idxh real(kind=dp), public :: idyh real(kind=dp), public :: idzh real(kind=fp), public :: lx_de real(kind=fp), public :: ly_de real(kind=fp), public :: lz_de real(kind=fp), public :: dtwpe real(kind=fp), public :: dtwce real(kind=fp), public :: dtwpi real(kind=fp), public :: dtwci real(kind=fp), public :: dt real(kind=fp), public :: idt integer, public :: energies_interval integer, public :: fields_interval integer, public :: hydro_interval integer, public :: particle_interval integer, public :: nx integer, public :: ny integer, public :: nz integer, public :: pic_tx integer, public :: pic_ty integer, public :: pic_tz integer, public :: pic_nx integer, public :: pic_ny integer, public :: pic_nz integer, public :: nppc integer, public :: nproc Subroutines public subroutine read_domain () Arguments None public subroutine write_pic_info () Arguments None public subroutine broadcast_pic_info () Arguments None public subroutine get_total_time_frames (tp2) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: tp2 public subroutine get_energy_band_number () Arguments None public subroutine read_thermal_params () Arguments None public subroutine calc_energy_interval () Arguments None","tags":"","loc":"module/picinfo.html","title":"picinfo – Fortran Program"},{"text":"Uses: mpi_module picinfo mpi_topology Variables Type Visibility Attributes Name Initial integer, public :: sizes_ghost (3) integer, public :: subsizes_ghost (3) integer, public :: starts_ghost (3) integer, public :: sizes_nghost (3) integer, public :: subsizes_nghost (3) integer, public :: starts_nghost (3) integer, public :: filetype_ghost integer, public :: filetype_nghost Subroutines public subroutine set_mpi_datatype_fields () Arguments None","tags":"","loc":"module/mpi_datatype_fields.html","title":"mpi_datatype_fields – Fortran Program"},{"text":"Uses: mpi_module Subroutines public subroutine save_field (fdata, varname, ct) Arguments Type Intent Optional Attributes Name real(kind=fp), intent(in), dimension(:, :, :) :: fdata character(len=*), intent(in) :: varname integer, intent(in) :: ct","tags":"","loc":"module/mpi_io_fields.html","title":"mpi_io_fields – Fortran Program"},{"text":"Subroutines public subroutine init_analysis () Arguments None public subroutine end_analysis () Arguments None","tags":"","loc":"module/analysis_management.html","title":"analysis_management – Fortran Program"},{"text":"Uses: constants mpi_module hdf5","tags":"","loc":"module/parallel_hdf5.html","title":"parallel_hdf5 – Fortran Program"},{"text":"Variables Type Visibility Attributes Name Initial character(len=150), public :: rootpath character(len=150), public :: filepath character(len=150), public :: outputpath Subroutines public subroutine get_file_paths () Arguments None","tags":"","loc":"module/path_info.html","title":"path_info – Fortran Program"},{"text":"Uses: constants parameters Variables Type Visibility Attributes Name Initial real(kind=fp), public, allocatable, dimension(:,:,:) :: pperp real(kind=fp), public, allocatable, dimension(:,:,:) :: ppara Subroutines public subroutine init_avg_para_perp_pressure () Arguments None public subroutine init_para_perp_pressure () Arguments None public subroutine free_avg_para_perp_pressure () Arguments None public subroutine free_para_perp_pressure () Arguments None public subroutine calc_para_perp_pressure (ct) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct public subroutine calc_real_para_perp_pressure (ct) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct public subroutine save_para_perp_pressure (ct) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct public subroutine save_averaged_para_perp_pressure () Arguments None","tags":"","loc":"module/para_perp_pressure.html","title":"para_perp_pressure – Fortran Program"},{"text":"Variables Type Visibility Attributes Name Initial integer, public :: datatype Subroutines public subroutine set_mpi_io () Arguments None public subroutine write_data (fname, fdata, tindex, output_record) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname real(kind=fp), intent(in), dimension(:,:,:) :: fdata integer, intent(in) :: tindex integer, intent(in) :: output_record","tags":"","loc":"module/mpi_io_translate.html","title":"mpi_io_translate – Fortran Program"},{"text":"Uses: constants picinfo path_info Variables Type Visibility Attributes Name Initial integer, public :: txs integer, public :: tys integer, public :: tzs integer, public :: txe integer, public :: tye integer, public :: tze Subroutines public subroutine distribute_pic_mpi () Arguments None public subroutine init_emax_array () Arguments None public subroutine free_emax_array () Arguments None public subroutine update_emax_array (emax_pic_mpi, otx, oty, otz) Arguments Type Intent Optional Attributes Name real(kind=fp), intent(in), dimension(:, :, :) :: emax_pic_mpi integer, intent(in) :: otx integer, intent(in) :: oty integer, intent(in) :: otz public subroutine write_emax (ct, species) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct character(len=1), intent(in) :: species public subroutine set_emax_datatype () Arguments None public subroutine free_emax_datatype () Arguments None","tags":"","loc":"module/particle_maximum_energy.html","title":"particle_maximum_energy – Fortran Program"},{"text":"Uses: mpi_module constants rank_index_mapping Variables Type Visibility Attributes Name Initial integer, public, allocatable, dimension(:,:) :: idxstart integer, public, allocatable, dimension(:,:) :: idxstop type(ht_type), public :: ht Subroutines public subroutine set_topology () Arguments None public subroutine set_start_stop_cells () Arguments None public subroutine free_start_stop_cells () Arguments None","tags":"","loc":"module/topology_translate.html","title":"topology_translate – Fortran Program"},{"text":"Uses: constants Subroutines public subroutine init_emfields () Arguments None public subroutine free_emfields () Arguments None public subroutine read_emfields (tindex0) Arguments Type Intent Optional Attributes Name integer, intent(in) :: tindex0 public subroutine write_emfields (tindex, output_record) Arguments Type Intent Optional Attributes Name integer, intent(in) :: tindex integer, intent(in) :: output_record","tags":"","loc":"module/emfields.html","title":"emfields – Fortran Program"},{"text":"Uses: constants Variables Type Visibility Attributes Name Initial integer, public :: nx integer, public :: nz real(kind=fp), public :: gdx real(kind=fp), public :: gdz real(kind=fp), public :: lx real(kind=fp), public :: lz real(kind=fp), public :: hmax real(kind=fp), public, allocatable, dimension(:) :: xarr real(kind=fp), public, allocatable, dimension(:) :: zarr integer, public :: npoints real(kind=fp), public, dimension(0:6) :: a real(kind=fp), public, dimension(0:6) :: c real(kind=fp), public, dimension(0:6) :: dc real(kind=fp), public, dimension(0:5,0:6) :: b Subroutines public subroutine init_fieldline_tracing () Arguments None public subroutine init_fieldline_points () Arguments None public subroutine free_fieldline_points () Arguments None public subroutine end_fieldline_tracing () Arguments None public subroutine tracing (x0, z0, htry, direction_flag) Arguments Type Intent Optional Attributes Name real(kind=fp), intent(in) :: x0 real(kind=fp), intent(in) :: z0 real(kind=fp), intent(in) :: htry integer, intent(in) :: direction_flag public subroutine trace_field_line (x0, z0) Arguments Type Intent Optional Attributes Name real(kind=fp), intent(in) :: x0 real(kind=fp), intent(in) :: z0 public subroutine get_crossing_point (x, z, xold, zold, lx, lz, xcross, zcross) Arguments Type Intent Optional Attributes Name real(kind=fp), intent(in) :: x real(kind=fp), intent(in) :: z real(kind=fp), intent(in) :: xold real(kind=fp), intent(in) :: zold real(kind=fp), intent(in) :: lx real(kind=fp), intent(in) :: lz real(kind=fp), intent(out) :: xcross real(kind=fp), intent(out) :: zcross public subroutine controller (h, hmax, hnext, x, z, xout, zout, kx, kz, is_accept, errold) Arguments Type Intent Optional Attributes Name real(kind=fp), intent(inout) :: h real(kind=fp), intent(in) :: hmax real(kind=fp), intent(out) :: hnext real(kind=fp), intent(in) :: x real(kind=fp), intent(in) :: z real(kind=fp), intent(in) :: xout real(kind=fp), intent(in) :: zout real(kind=fp), intent(in), dimension(0:6) :: kx real(kind=fp), intent(in), dimension(0:6) :: kz logical, intent(inout) :: is_accept real(kind=fp), intent(inout) :: errold public subroutine push (dxds, dyds, dzds, direction_flag, x, z, h, kx, ky, kz, xout, zout, dxdsnew, dydsnew, dzdsnew) Arguments Type Intent Optional Attributes Name real(kind=fp), intent(in) :: dxds real(kind=fp), intent(in) :: dyds real(kind=fp), intent(in) :: dzds integer, intent(in) :: direction_flag real(kind=fp), intent(in) :: x real(kind=fp), intent(in) :: z real(kind=fp), intent(in) :: h real(kind=fp), intent(out), dimension(0:6) :: kx real(kind=fp), intent(out), dimension(0:6) :: ky real(kind=fp), intent(out), dimension(0:6) :: kz real(kind=fp), intent(out) :: xout real(kind=fp), intent(out) :: zout real(kind=fp), intent(out) :: dxdsnew real(kind=fp), intent(out) :: dydsnew real(kind=fp), intent(out) :: dzdsnew public subroutine derivs (x, z, direction_flag, deltax, deltay, deltaz) Arguments Type Intent Optional Attributes Name real(kind=fp), intent(in) :: x real(kind=fp), intent(in) :: z integer, intent(in) :: direction_flag real(kind=fp), intent(out) :: deltax real(kind=fp), intent(out) :: deltay real(kind=fp), intent(out) :: deltaz public subroutine Cash_Karp_parameters () Arguments None public subroutine Dormand_Prince_parameters () Arguments None","tags":"","loc":"module/fieldline_tracing.html","title":"fieldline_tracing – Fortran Program"},{"text":"Uses: constants path_info picinfo parameters Variables Type Visibility Attributes Name Initial real(kind=fp), public, allocatable, dimension(:,:,:) :: nrho real(kind=fp), public, allocatable, dimension(:,:,:,:) :: eb Subroutines public subroutine init_particle_fields () Arguments None public subroutine init_density_fields () Arguments None public subroutine init_velocity_fields () Arguments None public subroutine init_pressure_tensor () Arguments None public subroutine init_current_densities () Arguments None public subroutine set_current_density_zero () Arguments None public subroutine free_particle_fields () Arguments None public subroutine free_density_fields () Arguments None public subroutine free_velocity_fields () Arguments None public subroutine free_pressure_tensor () Arguments None public subroutine free_current_densities () Arguments None public subroutine read_particle_fields (tindex0, species) Arguments Type Intent Optional Attributes Name integer, intent(in) :: tindex0 character(len=1), intent(in) :: species public subroutine read_velocity_fields_single (tindex0, pic_mpi_id, species) Arguments Type Intent Optional Attributes Name integer, intent(in) :: tindex0 integer, intent(in) :: pic_mpi_id character(len=1), intent(in) :: species public subroutine read_pressure_tensor_single (tindex0, pic_mpi_id, species) Arguments Type Intent Optional Attributes Name integer, intent(in) :: tindex0 integer, intent(in) :: pic_mpi_id character(len=1), intent(in) :: species public subroutine read_density_fields_single (tindex0, pic_mpi_id, species) Arguments Type Intent Optional Attributes Name integer, intent(in) :: tindex0 integer, intent(in) :: pic_mpi_id character(len=1), intent(in) :: species public subroutine calc_current_density () Arguments None public subroutine calc_absJ () Arguments None public subroutine adjust_particle_fields (species) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: species public subroutine write_particle_fields (tindex, output_record, species) Arguments Type Intent Optional Attributes Name integer, intent(in) :: tindex integer, intent(in) :: output_record character(len=1), intent(in) :: species public subroutine write_current_densities (tindex, output_record) Arguments Type Intent Optional Attributes Name integer, intent(in) :: tindex integer, intent(in) :: output_record","tags":"","loc":"module/particle_fields.html","title":"particle_fields – Fortran Program"},{"text":"Uses: constants Variables Type Visibility Attributes Name Initial type(particle), public :: ptl real(kind=fp), public :: ke real(kind=fp), public :: gama real(kind=fp), public :: igama real(kind=fp), public :: px real(kind=fp), public :: py real(kind=fp), public :: pz real(kind=fp), public :: vpara real(kind=fp), public :: vperp real(kind=fp), public :: vparax real(kind=fp), public :: vparay real(kind=fp), public :: vparaz real(kind=fp), public :: vperpx real(kind=fp), public :: vperpy real(kind=fp), public :: vperpz real(kind=fp), public :: gyrof real(kind=fp), public :: vgx real(kind=fp), public :: vgy real(kind=fp), public :: vgz real(kind=fp), public :: vcx real(kind=fp), public :: vcy real(kind=fp), public :: vcz integer, public :: ci integer, public :: cj integer, public :: ck integer, public :: iex integer, public :: jex integer, public :: kex integer, public :: iey integer, public :: jey integer, public :: key integer, public :: iez integer, public :: jez integer, public :: kez integer, public :: ibx integer, public :: iby integer, public :: ibz integer, public :: jbx integer, public :: jby integer, public :: jbz integer, public :: kbx integer, public :: kby integer, public :: kbz real(kind=fp), public :: dx_ex real(kind=fp), public :: dy_ex real(kind=fp), public :: dz_ex real(kind=fp), public :: dx_ey real(kind=fp), public :: dy_ey real(kind=fp), public :: dz_ey real(kind=fp), public :: dx_ez real(kind=fp), public :: dy_ez real(kind=fp), public :: dz_ez real(kind=fp), public :: dx_bx real(kind=fp), public :: dx_by real(kind=fp), public :: dx_bz real(kind=fp), public :: dy_bx real(kind=fp), public :: dy_by real(kind=fp), public :: dy_bz real(kind=fp), public :: dz_bx real(kind=fp), public :: dz_by real(kind=fp), public :: dz_bz Subroutines public subroutine calc_particle_energy () Arguments None public subroutine calc_ptl_coord () Arguments None public subroutine calc_interp_param () Arguments None public subroutine calc_para_perp_velocity () Arguments None public subroutine calc_gyrofrequency () Arguments None public subroutine calc_para_perp_velocity_3d () Arguments None public subroutine calc_gradient_drift_velocity () Arguments None public subroutine calc_curvature_drift_velocity () Arguments None","tags":"","loc":"module/particle_module.html","title":"particle_module – Fortran Program"},{"text":"Uses: path_info Variables Type Visibility Attributes Name Initial integer, public :: ratio_interval integer, public :: fh Functions public function check_particle_in_range (spatial_range) result(isrange) Arguments Type Intent Optional Attributes Name real(kind=fp), intent(in), dimension(2,3) :: spatial_range Return Value logical public function check_both_particle_fields_exist (ct) result(is_time_valid) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct Return Value logical Subroutines public subroutine check_existence (tindex, species, existFlag) Arguments Type Intent Optional Attributes Name integer, intent(in) :: tindex character(len=1), intent(in) :: species logical, intent(out) :: existFlag public subroutine open_particle_file (tindex, species, cid) Arguments Type Intent Optional Attributes Name integer, intent(in) :: tindex character(len=1), intent(in) :: species character(len=*), intent(in) :: cid public subroutine close_particle_file () Arguments None public subroutine get_ratio_interval () Arguments None","tags":"","loc":"module/particle_file.html","title":"particle_file – Fortran Program"},{"text":"Variables Type Visibility Attributes Name Initial type( ht_type ), public :: ht type( ht_type ), public :: htg type(data_range), public :: range_out Derived Types type, public :: ht_type Components Type Visibility Attributes Name Initial integer, public :: tx integer, public :: ty integer, public :: tz integer, public :: nx integer, public :: ny integer, public :: nz integer, public :: start_x integer, public :: start_y integer, public :: start_z integer, public :: stop_x integer, public :: stop_y integer, public :: stop_z integer, public :: ix integer, public :: iy integer, public :: iz Subroutines public subroutine distribute_tasks (ntasks, nworkers, worker_id, ntask_current, task_start, task_end) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ntasks integer, intent(in) :: nworkers integer, intent(in) :: worker_id integer, intent(out) :: ntask_current integer, intent(out) :: task_start integer, intent(out) :: task_end public subroutine set_mpi_topology () Arguments None","tags":"","loc":"module/mpi_topology.html","title":"mpi_topology – Fortran Program"},{"text":"Uses: constants mpi_topology Variables Type Visibility Attributes Name Initial real(kind=fp), public, allocatable, dimension(:, :, :) :: pdiv_v real(kind=fp), public, allocatable, dimension(:, :, :) :: pshear real(kind=fp), public, allocatable, dimension(:, :, :) :: vdot_div_ptensor real(kind=fp), public, allocatable, dimension(:, :, :) :: div_v real(kind=fp), public, allocatable, dimension(:, :, :) :: bbsigma Subroutines public subroutine init_compression_shear () Arguments None public subroutine init_div_v () Arguments None public subroutine init_div_vdot_ptensor () Arguments None public subroutine free_compression_shear () Arguments None public subroutine free_div_v () Arguments None public subroutine free_div_vdot_ptensor () Arguments None public subroutine calc_div_v () Arguments None public subroutine calc_compression_shear () Arguments None public subroutine calc_div_vdot_ptensor () Arguments None public subroutine save_compression_shear (ct) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct public subroutine save_div_vdot_ptensor (ct) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct public subroutine save_tot_compression_shear (ct) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct public subroutine save_tot_div_vdot_ptensor (ct) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct","tags":"","loc":"module/compression_shear.html","title":"compression_shear – Fortran Program"},{"text":"Uses: constants picinfo path_info Variables Type Visibility Attributes Name Initial real(kind=dp), public, allocatable, dimension(:) :: f real(kind=dp), public, allocatable, dimension(:) :: fsum real(kind=dp), public, allocatable, dimension(:) :: flog real(kind=dp), public, allocatable, dimension(:) :: flogsum real(kind=dp), public, allocatable, dimension(:) :: ebins_lin real(kind=dp), public, allocatable, dimension(:) :: ebins_log Subroutines public subroutine init_energy_spectra () Arguments None public subroutine init_energy_spectra_single () Arguments None public subroutine set_energy_spectra_zero () Arguments None public subroutine set_energy_spectra_zero_single () Arguments None public subroutine init_maximum_energy (nt) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nt public subroutine set_maximum_energy_zero () Arguments None public subroutine free_maximum_energy () Arguments None public subroutine free_energy_spectra () Arguments None public subroutine free_energy_spectra_single () Arguments None public subroutine init_emax_pic_mpi () Arguments None public subroutine set_emax_pic_mpi_zero () Arguments None public subroutine free_emax_pic_mpi () Arguments None public subroutine calc_energy_bins () Arguments None public subroutine calc_energy_spectra (ct, species) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct character(len=1), intent(in) :: species public subroutine sum_spectra_over_mpi () Arguments None public subroutine get_maximum_energy_global (nt) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nt public subroutine save_particle_spectra (ct, species) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct character(len=1), intent(in) :: species public subroutine save_maximum_energy (nt, species) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nt character(len=1), intent(in) :: species public subroutine calc_energy_spectrum_single (tindex, species) Arguments Type Intent Optional Attributes Name integer, intent(in) :: tindex character(len=1), intent(in) :: species public subroutine update_energy_spectrum () Arguments None public subroutine update_maximum_energy () Arguments None","tags":"","loc":"module/particle_energy_spectrum.html","title":"particle_energy_spectrum – Fortran Program"},{"text":"Subroutines public subroutine get_average_and_total (fdata, avg, tot) Arguments Type Intent Optional Attributes Name real(kind=fp), intent(in), dimension(:, :, :) :: fdata real(kind=fp), intent(out) :: avg real(kind=fp), intent(out) :: tot public subroutine get_log_distribution (dataSet, minValue, maxValue, nbins, distData) Arguments Type Intent Optional Attributes Name real(kind=fp), intent(in), dimension(:, :, :) :: dataSet real(kind=fp), intent(in) :: minValue real(kind=fp), intent(in) :: maxValue integer, intent(in) :: nbins real(kind=fp), intent(out), dimension(nbins+2) :: distData","tags":"","loc":"module/statistics.html","title":"statistics – Fortran Program"},{"text":"Uses: constants Subroutines public subroutine read_config_jdote_eband () Arguments None","tags":"","loc":"module/jdote_energy_band.html","title":"jdote_energy_band – Fortran Program"},{"text":"Variables Type Visibility Attributes Name Initial integer, public :: httx integer, public :: htty integer, public :: httz integer, public :: tindex_start integer, public :: tindex_stop integer, public :: output_format integer, public :: append_to_files Subroutines public subroutine read_configuration () Arguments None","tags":"","loc":"module/configuration_translate.html","title":"configuration_translate – Fortran Program"},{"text":"Subroutines public subroutine rank_to_index (rank, nx, ny, nz, ix, iy, iz) Arguments Type Intent Optional Attributes Name integer, intent(in) :: rank integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz integer, intent(out) :: ix integer, intent(out) :: iy integer, intent(out) :: iz public subroutine index_to_rank (ix, iy, iz, nx, ny, nz, rank) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ix integer, intent(in) :: iy integer, intent(in) :: iz integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz integer, intent(out) :: rank","tags":"","loc":"module/rank_index_mapping.html","title":"rank_index_mapping – Fortran Program"},{"text":"Uses: constants path_info Variables Type Visibility Attributes Name Initial real(kind=dp), public, allocatable, dimension(:, :) :: fvel_2d real(kind=dp), public, allocatable, dimension(:, :) :: fvel_xy real(kind=dp), public, allocatable, dimension(:, :) :: fvel_xz real(kind=dp), public, allocatable, dimension(:, :) :: fvel_yz real(kind=dp), public, allocatable, dimension(:) :: fvel_para real(kind=dp), public, allocatable, dimension(:) :: fvel_perp real(kind=dp), public, allocatable, dimension(:, :) :: fvel_2d_sum real(kind=dp), public, allocatable, dimension(:, :) :: fvel_xy_sum real(kind=dp), public, allocatable, dimension(:, :) :: fvel_xz_sum real(kind=dp), public, allocatable, dimension(:, :) :: fvel_yz_sum real(kind=dp), public, allocatable, dimension(:) :: fvel_para_sum real(kind=dp), public, allocatable, dimension(:) :: fvel_perp_sum real(kind=dp), public, allocatable, dimension(:) :: vbins_short real(kind=dp), public, allocatable, dimension(:) :: vbins_long Subroutines public subroutine init_velocity_bins () Arguments None public subroutine free_velocity_bins () Arguments None public subroutine init_vdist_2d () Arguments None public subroutine init_vdist_2d_single () Arguments None public subroutine set_vdist_2d_zero_single () Arguments None public subroutine set_vdist_2d_zero () Arguments None public subroutine free_vdist_2d () Arguments None public subroutine free_vdist_2d_single () Arguments None public subroutine init_vdist_1d () Arguments None public subroutine init_vdist_1d_single () Arguments None public subroutine set_vdist_1d_zero_single () Arguments None public subroutine set_vdist_1d_zero () Arguments None public subroutine free_vdist_1d_single () Arguments None public subroutine free_vdist_1d () Arguments None public subroutine calc_vdist_2d (ct, species) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct character(len=1), intent(in) :: species public subroutine sum_vdist_2d_over_mpi () Arguments None public subroutine save_vdist_2d (ct, species) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct character(len=1), intent(in) :: species public subroutine calc_vdist_2d_single (tindex, species) Arguments Type Intent Optional Attributes Name integer, intent(in) :: tindex character(len=1), intent(in) :: species public subroutine calc_vdist_1d (ct, species) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct character(len=1), intent(in) :: species public subroutine sum_vdist_1d_over_mpi () Arguments None public subroutine save_vdist_1d (ct, species) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct character(len=1), intent(in) :: species public subroutine calc_vdist_1d_single (tindex, species) Arguments Type Intent Optional Attributes Name integer, intent(in) :: tindex character(len=1), intent(in) :: species public subroutine update_vdist_2d () Arguments None public subroutine update_vdist_1d () Arguments None","tags":"","loc":"module/velocity_distribution.html","title":"velocity_distribution – Fortran Program"},{"text":"Uses: mpi_module path_info Variables Type Visibility Attributes Name Initial integer, public :: nout integer, public :: output_record Subroutines public subroutine get_nout () Arguments None public subroutine adjust_tindex_start () Arguments None public subroutine set_output_record () Arguments None","tags":"","loc":"module/time_info.html","title":"time_info – Fortran Program"},{"text":"Uses: constants Variables Type Visibility Attributes Name Initial real(kind=fp), public :: ex0 real(kind=fp), public :: ey0 real(kind=fp), public :: ez0 Subroutines public subroutine init_electric_fields () Arguments None public subroutine free_electric_fields () Arguments None public subroutine read_electric_fields (ct) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct public subroutine get_electric_field_at_point (x, z, dx, dz) Arguments Type Intent Optional Attributes Name real(kind=fp), intent(in) :: x real(kind=fp), intent(in) :: z real(kind=fp), intent(in) :: dx real(kind=fp), intent(in) :: dz","tags":"","loc":"module/electric_field.html","title":"electric_field – Fortran Program"},{"text":"Variables Type Visibility Attributes Name Initial type(v0header), public :: v0 type(header_particle), public :: pheader type(header_fields), public :: fheader Subroutines public subroutine read_boilerplate (fh) Arguments Type Intent Optional Attributes Name integer, intent(in) :: fh public subroutine read_fields_header (fh) Arguments Type Intent Optional Attributes Name integer, intent(in) :: fh public subroutine read_particle_header (fh) Arguments Type Intent Optional Attributes Name integer, intent(in) :: fh","tags":"","loc":"module/file_header.html","title":"file_header – Fortran Program"},{"text":"Uses: constants Variables Type Visibility Attributes Name Initial real(kind=fp), public :: ptl_mass real(kind=fp), public :: ptl_charge real(kind=fp), public :: sqrt_ptl_mass character(len=1), public :: species character(len=2), public :: ibtag Subroutines public subroutine get_ptl_mass_charge (species) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: species","tags":"","loc":"module/particle_info.html","title":"particle_info – Fortran Program"},{"text":"Uses: constants Variables Type Visibility Attributes Name Initial real(kind=fp), public :: bx0 real(kind=fp), public :: by0 real(kind=fp), public :: bz0 real(kind=fp), public :: ex0 real(kind=fp), public :: ey0 real(kind=fp), public :: ez0 real(kind=fp), public :: absB0 real(kind=fp), public :: dbxdx0 real(kind=fp), public :: dbxdy0 real(kind=fp), public :: dbxdz0 real(kind=fp), public :: dbydx0 real(kind=fp), public :: dbydy0 real(kind=fp), public :: dbydz0 real(kind=fp), public :: dbzdx0 real(kind=fp), public :: dbzdy0 real(kind=fp), public :: dbzdz0 real(kind=fp), public :: bxn real(kind=fp), public :: byn real(kind=fp), public :: bzn real(kind=fp), public :: dBdx real(kind=fp), public :: dBdy real(kind=fp), public :: dBdz real(kind=fp), public :: kappax real(kind=fp), public :: kappay real(kind=fp), public :: kappaz Subroutines public subroutine init_emfields () Arguments None public subroutine init_emfields_derivatives () Arguments None public subroutine free_emfields () Arguments None public subroutine free_emfields_derivatives () Arguments None public subroutine read_emfields_single (tindex0, pic_mpi_id) Arguments Type Intent Optional Attributes Name integer, intent(in) :: tindex0 integer, intent(in) :: pic_mpi_id public subroutine calc_emfields_derivatives () Arguments None public subroutine calc_interp_weights (dx, dy, dz) Arguments Type Intent Optional Attributes Name real(kind=fp), intent(in) :: dx real(kind=fp), intent(in) :: dy real(kind=fp), intent(in) :: dz public subroutine trilinear_interp_bx (ix0, iy0, iz0, dx, dy, dz) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ix0 integer, intent(in) :: iy0 integer, intent(in) :: iz0 real(kind=fp), intent(in) :: dx real(kind=fp), intent(in) :: dy real(kind=fp), intent(in) :: dz public subroutine trilinear_interp_by (ix0, iy0, iz0, dx, dy, dz) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ix0 integer, intent(in) :: iy0 integer, intent(in) :: iz0 real(kind=fp), intent(in) :: dx real(kind=fp), intent(in) :: dy real(kind=fp), intent(in) :: dz public subroutine trilinear_interp_bz (ix0, iy0, iz0, dx, dy, dz) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ix0 integer, intent(in) :: iy0 integer, intent(in) :: iz0 real(kind=fp), intent(in) :: dx real(kind=fp), intent(in) :: dy real(kind=fp), intent(in) :: dz public subroutine trilinear_interp_ex (ix0, iy0, iz0, dx, dy, dz) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ix0 integer, intent(in) :: iy0 integer, intent(in) :: iz0 real(kind=fp), intent(in) :: dx real(kind=fp), intent(in) :: dy real(kind=fp), intent(in) :: dz public subroutine trilinear_interp_ey (ix0, iy0, iz0, dx, dy, dz) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ix0 integer, intent(in) :: iy0 integer, intent(in) :: iz0 real(kind=fp), intent(in) :: dx real(kind=fp), intent(in) :: dy real(kind=fp), intent(in) :: dz public subroutine trilinear_interp_ez (ix0, iy0, iz0, dx, dy, dz) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ix0 integer, intent(in) :: iy0 integer, intent(in) :: iz0 real(kind=fp), intent(in) :: dx real(kind=fp), intent(in) :: dy real(kind=fp), intent(in) :: dz public subroutine calc_b_norm () Arguments None public subroutine calc_gradient_B () Arguments None public subroutine calc_curvature () Arguments None","tags":"","loc":"module/interpolation_emf.html","title":"interpolation_emf – Fortran Program"},{"text":"Uses: mpi_module constants path_info picinfo particle_frames spectrum_config velocity_distribution particle_energy_spectrum parameters magnetic_field particle_info Subroutines public subroutine particle_spectrum_vdist_main () Arguments None","tags":"","loc":"module/particle_spectrum_vdist_module.html","title":"particle_spectrum_vdist_module – Fortran Program"},{"text":"Uses: constants mpi_topology pic_fields Variables Type Visibility Attributes Name Initial real(kind=fp), public, allocatable, dimension(:, :, :) :: pscalar real(kind=fp), public, allocatable, dimension(:, :, :) :: divp_x real(kind=fp), public, allocatable, dimension(:, :, :) :: divp_y real(kind=fp), public, allocatable, dimension(:, :, :) :: divp_z real(kind=fp), public, allocatable, dimension(:, :, :) :: gradp_x real(kind=fp), public, allocatable, dimension(:, :, :) :: gradp_y real(kind=fp), public, allocatable, dimension(:, :, :) :: gradp_z Subroutines public subroutine init_scalar_pressure () Arguments None public subroutine init_div_ptensor () Arguments None public subroutine init_grad_pscalar () Arguments None public subroutine free_scalar_pressure () Arguments None public subroutine free_div_ptensor () Arguments None public subroutine free_grad_pscalar () Arguments None public subroutine calc_scalar_pressure () Arguments None public subroutine calc_div_ptensor () Arguments None public subroutine calc_grad_pscalar () Arguments None","tags":"","loc":"module/pressure_tensor.html","title":"pressure_tensor – Fortran Program"},{"text":"Variables Type Visibility Attributes Name Initial integer(kind=4), public, parameter :: int_kind = 4 integer(kind=4), public, parameter :: real_kind = 4 integer(kind=4), public, parameter :: ptr_kind = 8 integer(kind=4), public, parameter :: STRLEN = 64 integer(kind=4), public, parameter :: XSTRLEN = 256","tags":"","loc":"module/kinds.html","title":"kinds – Fortran Program"},{"text":"Uses: constants Variables Type Visibility Attributes Name Initial real(kind=fp), public :: bx0 real(kind=fp), public :: by0 real(kind=fp), public :: bz0 Subroutines public subroutine init_magnetic_fields () Arguments None public subroutine free_magnetic_fields () Arguments None public subroutine read_magnetic_fields (ct) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct public subroutine get_magnetic_field_at_point (x, z, dx, dz) Arguments Type Intent Optional Attributes Name real(kind=fp), intent(in) :: x real(kind=fp), intent(in) :: z real(kind=fp), intent(in) :: dx real(kind=fp), intent(in) :: dz","tags":"","loc":"module/magnetic_field.html","title":"magnetic_field – Fortran Program"},{"text":"Uses: mpi_module kinds cla Variables Type Visibility Attributes Name Initial logical, public :: is_species logical, public :: is_config_dist logical, public :: is_emax_cell Subroutines public subroutine get_cmdline_arguments () Arguments None","tags":"","loc":"module/commandline_arguments.html","title":"commandline_arguments – Fortran Program"},{"text":"Uses: mpi_module constants picinfo Variables Type Visibility Attributes Name Initial real(kind=fp), public, allocatable, dimension(:,:,:) :: exin real(kind=fp), public, allocatable, dimension(:,:,:) :: eyin real(kind=fp), public, allocatable, dimension(:,:,:) :: ezin Subroutines public subroutine init_inductive_electric_field () Arguments None public subroutine free_inductive_electric_field () Arguments None public subroutine init_inductive (species) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: species public subroutine free_inductive (species) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: species public subroutine calc_inductive_e (ct, species) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct character(len=*), intent(in) :: species","tags":"","loc":"module/inductive_electric_field.html","title":"inductive_electric_field – Fortran Program"},{"text":"Uses: mpi_module constants Variables Type Visibility Attributes Name Initial integer, public :: nptot integer, public :: np integer, public :: startp integer, public :: endp Subroutines public subroutine init_analysis (ct) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct public subroutine get_fieldline_points (x0, z0) Arguments Type Intent Optional Attributes Name real(kind=fp), intent(in) :: x0 real(kind=fp), intent(in) :: z0 public subroutine end_analysis () Arguments None","tags":"","loc":"module/particle_fieldline.html","title":"particle_fieldline – Fortran Program"},{"text":"Variables Type Visibility Attributes Name Initial integer, public :: nt integer, public :: tinterval logical, public :: is_frame0 Subroutines public subroutine get_particle_frames () Arguments None public subroutine get_particle_frames_hydro () Arguments None","tags":"","loc":"module/particle_frames.html","title":"particle_frames – Fortran Program"},{"text":"Uses: constants Variables Type Visibility Attributes Name Initial real(kind=fp), public, allocatable, dimension(:, :, :) :: vdx1 real(kind=fp), public, allocatable, dimension(:, :, :) :: vdy1 real(kind=fp), public, allocatable, dimension(:, :, :) :: vdz1 real(kind=fp), public, allocatable, dimension(:, :, :) :: vdx2 real(kind=fp), public, allocatable, dimension(:, :, :) :: vdy2 real(kind=fp), public, allocatable, dimension(:, :, :) :: vdz2 Subroutines public subroutine init_pre_post_velocities () Arguments None public subroutine free_pre_post_velocities () Arguments None public subroutine read_pre_post_velocities (ct, fh) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct integer, intent(in), dimension(3) :: fh","tags":"","loc":"module/previous_post_velocities.html","title":"previous_post_velocities – Fortran Program"},{"text":"Uses: constants Variables Type Visibility Attributes Name Initial real(kind=fp), public, allocatable, dimension(:, :, :) :: nrho1 real(kind=fp), public, allocatable, dimension(:, :, :) :: nrho2 Subroutines public subroutine init_pre_post_density () Arguments None public subroutine free_pre_post_density () Arguments None public subroutine read_pre_post_density (ct, fh) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct integer, intent(in) :: fh","tags":"","loc":"module/previous_post_density.html","title":"previous_post_density – Fortran Program"},{"text":"Uses: constants pic_fields para_perp_pressure neighbors_module jdote_module mpi_topology picinfo mpi_io_fields parameters Variables Type Visibility Attributes Name Initial real(kind=fp), public, allocatable, dimension(:,:,:) :: jx1 real(kind=fp), public, allocatable, dimension(:,:,:) :: jy1 real(kind=fp), public, allocatable, dimension(:,:,:) :: jz1 real(kind=fp), public, allocatable, dimension(:,:,:) :: jx2 real(kind=fp), public, allocatable, dimension(:,:,:) :: jy2 real(kind=fp), public, allocatable, dimension(:,:,:) :: jz2 real(kind=fp), public, allocatable, dimension(:,:,:) :: jagyx real(kind=fp), public, allocatable, dimension(:,:,:) :: jagyy real(kind=fp), public, allocatable, dimension(:,:,:) :: jagyz real(kind=fp), public, allocatable, dimension(:,:,:) :: jperpx1 real(kind=fp), public, allocatable, dimension(:,:,:) :: jperpy1 real(kind=fp), public, allocatable, dimension(:,:,:) :: jperpz1 real(kind=fp), public, allocatable, dimension(:,:,:) :: jperpx2 real(kind=fp), public, allocatable, dimension(:,:,:) :: jperpy2 real(kind=fp), public, allocatable, dimension(:,:,:) :: jperpz2 Subroutines public subroutine init_current_densities () Arguments None public subroutine init_ava_current_densities () Arguments None public subroutine free_avg_current_densities () Arguments None public subroutine set_current_densities_to_zero () Arguments None public subroutine free_current_densities () Arguments None public subroutine calc_current_densities (ct) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct public subroutine save_averaged_current () Arguments None","tags":"","loc":"module/current_densities.html","title":"current_densities – Fortran Program"},{"text":"Uses: constants picinfo Variables Type Visibility Attributes Name Initial integer, public, allocatable, dimension(:) :: ixl integer, public, allocatable, dimension(:) :: ixh integer, public, allocatable, dimension(:) :: iyl integer, public, allocatable, dimension(:) :: iyh integer, public, allocatable, dimension(:) :: izl integer, public, allocatable, dimension(:) :: izh real(kind=dp), public, allocatable, dimension(:) :: idx real(kind=dp), public, allocatable, dimension(:) :: idy real(kind=dp), public, allocatable, dimension(:) :: idz Subroutines public subroutine init_neighbors (nx0, ny0, nz0) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nx0 integer, intent(in) :: ny0 integer, intent(in) :: nz0 public subroutine free_neighbors () Arguments None public subroutine get_neighbors () Arguments None public subroutine get_mpi_neighbors (pic_mpi_id, nxl, nxh, nyl, nyh, nzl, nzh) Arguments Type Intent Optional Attributes Name integer, intent(in) :: pic_mpi_id integer, intent(out) :: nxl integer, intent(out) :: nxh integer, intent(out) :: nyl integer, intent(out) :: nyh integer, intent(out) :: nzl integer, intent(out) :: nzh","tags":"","loc":"module/neighbors_module.html","title":"neighbors_module – Fortran Program"},{"text":"Variables Type Visibility Attributes Name Initial integer, public :: save_jcpara integer, public :: save_jcperp integer, public :: save_jmag integer, public :: save_jgrad integer, public :: save_jdiagm integer, public :: save_jpolar integer, public :: save_jexb integer, public :: save_jpara integer, public :: save_jperp integer, public :: save_jperp1 integer, public :: save_jperp2 integer, public :: save_jqnvpara integer, public :: save_jqnvperp integer, public :: save_jagy integer, public :: save_jtot integer, public :: save_jdivv integer, public :: save_jcpara_dote integer, public :: save_jcperp_dote integer, public :: save_jmag_dote integer, public :: save_jgrad_dote integer, public :: save_jdiagm_dote integer, public :: save_jpolar_dote integer, public :: save_jexb_dote integer, public :: save_jpara_dote integer, public :: save_jperp_dote integer, public :: save_jperp1_dote integer, public :: save_jperp2_dote integer, public :: save_jqnvpara_dote integer, public :: save_jqnvperp_dote integer, public :: save_jagy_dote integer, public :: save_jtot_dote integer, public :: save_jdivv_dote integer, public :: save_pre Subroutines public subroutine get_saving_flags () Arguments None","tags":"","loc":"module/saving_flags.html","title":"saving_flags – Fortran Program"},{"text":"Uses: particle_spectrum_vdist_module","tags":"","loc":"program/particle_spectrum_vdist_box.html","title":"particle_spectrum_vdist_box – Fortran Program"},{"text":"Uses: mpi_module particle_info analysis_management commandline_arguments Variables Type Attributes Name Initial integer :: ct Subroutines subroutine commit_analysis () Arguments None subroutine energy_conversion_from_current () Arguments None subroutine calc_energy_conversion (ct) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct","tags":"","loc":"program/dissipation.html","title":"dissipation – Fortran Program"},{"text":"Uses: particle_info analysis_management Subroutines subroutine commit_analysis () Arguments None","tags":"","loc":"program/bulk_flow_energy.html","title":"bulk_flow_energy – Fortran Program"},{"text":"Uses: mpi_module constants particle_frames spectrum_config particle_fieldline Variables Type Attributes Name Initial integer :: ct real(kind=fp), allocatable, dimension(:, :) :: vdist_para real(kind=fp), allocatable, dimension(:, :) :: vdist_perp real(kind=fp) :: x0 real(kind=fp) :: z0 Subroutines subroutine calc_vdist_1d_fieldline (species) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: species subroutine check_folder_exist () Arguments None subroutine write_vdist_1d (species) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: species","tags":"","loc":"program/vdist_1d_along_fieldline.html","title":"vdist_1d_along_fieldline – Fortran Program"},{"text":"Uses: mpi_module constants pic_fields particle_info parameters analysis_management mpi_io_fields Variables Type Attributes Name Initial real(kind=fp), allocatable, dimension(:, :, :) :: Nxx real(kind=fp), allocatable, dimension(:, :, :) :: Nxy real(kind=fp), allocatable, dimension(:, :, :) :: Nxz real(kind=fp), allocatable, dimension(:, :, :) :: Nyy real(kind=fp), allocatable, dimension(:, :, :) :: Nyz real(kind=fp), allocatable, dimension(:, :, :) :: Nzz real(kind=fp), allocatable, dimension(:, :, :) :: bxn real(kind=fp), allocatable, dimension(:, :, :) :: byn real(kind=fp), allocatable, dimension(:, :, :) :: bzn real(kind=fp), allocatable, dimension(:, :, :) :: alpha real(kind=fp), allocatable, dimension(:, :, :) :: beta real(kind=fp), allocatable, dimension(:, :, :) :: agyrotropy integer :: input_record integer :: output_record Subroutines subroutine init_data () Arguments None subroutine free_data () Arguments None subroutine init_pic_fields () Arguments None subroutine open_pic_fields (species) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: species subroutine read_pic_fields (ct) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct subroutine close_pic_fields_file () Arguments None subroutine free_pic_fields () Arguments None","tags":"","loc":"program/calc_agyrotropy.html","title":"calc_agyrotropy – Fortran Program"},{"text":"Uses: constants analysis_management mpi_module hdf5 Variables Type Attributes Name Initial integer(kind=hid_t) :: file_id integer(kind=hid_t), allocatable, dimension(:) :: group_id integer(kind=hid_t), allocatable, dimension(:) :: dset_id integer(kind=hid_t) :: filespace integer(kind=hid_t) :: memspace integer(kind=hid_t) :: plist_id integer(kind=hsize_t), allocatable, dimension(:) :: dset_dims integer(kind=hsize_t), allocatable, dimension(:) :: dcount integer(kind=hsize_t), allocatable, dimension(:) :: offset integer :: rank character(len=256) :: filename character(len=256) :: groupname Subroutines subroutine open_hdf5_parallel (filename, groupname) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: groupname subroutine read_hdf5_parallel () Arguments None","tags":"","loc":"program/parallel_hdf5.html","title":"parallel_hdf5 – Fortran Program"},{"text":"Uses: jdote_energy_band","tags":"","loc":"program/compression.html","title":"compression – Fortran Program"},{"text":"Uses: particle_info analysis_management Subroutines subroutine commit_analysis () Arguments None","tags":"","loc":"program/compression~2.html","title":"compression – Fortran Program"},{"text":"Uses: mpi_module constants picinfo mpi_topology particle_info analysis_management pic_fields statistics parameters Variables Type Attributes Name Initial character(len=150) :: fname integer, parameter :: nbands = 5 real(kind=dp), allocatable, dimension(:, :) :: rho_band_sum real(kind=fp) :: rho_band_tot real(kind=fp) :: rho_band_avg character(len=20) :: format1 integer :: iband integer :: ct","tags":"","loc":"program/particle_number_eband.html","title":"particle_number_eband – Fortran Program"},{"text":"Uses: mpi_module path_info picinfo particle_frames spectrum_config velocity_distribution parameters magnetic_field particle_info Variables Type Attributes Name Initial integer :: ct integer :: ct_field integer :: ratio_particle_field","tags":"","loc":"program/vdistribution.html","title":"vdistribution – Fortran Program"},{"text":"Uses: mpi_module constants particle_frames spectrum_config particle_fieldline Variables Type Attributes Name Initial integer :: ct real(kind=fp), allocatable, dimension(:, :, :) :: vdist_2d real(kind=fp), allocatable, dimension(:, :, :) :: vdist_xy real(kind=fp), allocatable, dimension(:, :, :) :: vdist_xz real(kind=fp), allocatable, dimension(:, :, :) :: vdist_yz real(kind=fp) :: x0 real(kind=fp) :: z0 Subroutines subroutine calc_vdist_2d_fieldline (species) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: species subroutine check_folder_exist () Arguments None subroutine write_vdist_2d (species) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: species","tags":"","loc":"program/vdist_2d_along_fieldline.html","title":"vdist_2d_along_fieldline – Fortran Program"},{"text":"Uses: mpi_module constants configuration_translate time_info emfields particle_fields path_info Variables Type Attributes Name Initial integer :: tindex integer :: tindex_new character(len=150) :: fname real(kind=dp) :: mp_elapsed logical :: dfile Subroutines subroutine init_analysis () Arguments None subroutine end_analysis () Arguments None","tags":"","loc":"program/translate.html","title":"translate – Fortran Program"},{"text":"Uses: mpi_module constants path_info picinfo particle_frames spectrum_config particle_energy_spectrum particle_maximum_energy parameters commandline_arguments mpi_info_module Variables Type Attributes Name Initial integer :: ct real(kind=dp) :: mp_elapsed","tags":"","loc":"program/parspec.html","title":"parspec – Fortran Program"},{"text":"Uses: mpi_module constants path_info picinfo particle_frames commandline_arguments mpi_info_module particle_energy_spectrum Variables Type Attributes Name Initial real(kind=dp) :: mp_elapsed integer :: ct real(kind=fp), allocatable, dimension(:) :: fcore Subroutines subroutine get_spectra_config () Arguments None subroutine get_energy_spectrum (ct, species) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct character(len=1), intent(in) :: species subroutine init_spectrum_one_core () Arguments None subroutine free_spectrum_one_core () Arguments None subroutine differentiate_spectrum () Arguments None","tags":"","loc":"program/parspec_cpu_based.html","title":"parspec_cpu_based – Fortran Program"},{"text":"Uses: mpi_module constants path_info picinfo particle_frames spectrum_config particle_energy_spectrum parameters Variables Type Attributes Name Initial integer :: ct real(kind=dp) :: mp_elapsed","tags":"","loc":"program/particle_spectrum_box.html","title":"particle_spectrum_box – Fortran Program"},{"text":"Uses: mpi_module constants fieldline_tracing analysis_management magnetic_field electric_field Variables Type Attributes Name Initial real(kind=fp), allocatable, dimension(:,:) :: phi_para integer :: nx_local integer :: nx_offset integer :: nx integer :: nz integer :: ct Subroutines subroutine init_calculation () Arguments None subroutine end_calculation () Arguments None subroutine calc_phi_parallel (ct) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct subroutine tracing (x, z, htry, phi_parallel, direction_flag) Arguments Type Intent Optional Attributes Name real(kind=fp), intent(inout) :: x real(kind=fp), intent(inout) :: z real(kind=fp), intent(in) :: htry real(kind=fp), intent(inout) :: phi_parallel integer, intent(in) :: direction_flag subroutine update_phi_parallel (xold, zold, kx, ky, kz, h, phi_parallel) Arguments Type Intent Optional Attributes Name real(kind=fp), intent(in) :: xold real(kind=fp), intent(in) :: zold real(kind=fp), intent(in), dimension(0:6) :: kx real(kind=fp), intent(in), dimension(0:6) :: ky real(kind=fp), intent(in), dimension(0:6) :: kz real(kind=fp), intent(in) :: h real(kind=fp), intent(inout) :: phi_parallel subroutine save_phi_parallel (ct) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ct","tags":"","loc":"program/parallel_potential.html","title":"parallel_potential – Fortran Program"},{"text":"Uses: mpi_module constants particle_frames spectrum_config particle_fieldline Variables Type Attributes Name Initial integer :: ct real(kind=fp), allocatable, dimension(:, :) :: flog_np real(kind=fp), allocatable, dimension(:, :) :: flin_np real(kind=fp) :: x0 real(kind=fp) :: z0 Subroutines subroutine calc_particle_energy_spectrum (species) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: species subroutine check_folder_exist () Arguments None subroutine write_particle_spectrum (species) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: species","tags":"","loc":"program/spectrum_along_fieldline.html","title":"spectrum_along_fieldline – Fortran Program"},{"text":"Uses: kinds cla Variables Type Attributes Name Initial character(len=STRLEN) :: key character(len=XSTRLEN) :: description integer(kind=int_kind) :: kkind character(len=STRLEN) :: default integer(kind=int_kind) :: i integer(kind=8) :: j integer(kind=8) :: jello real(kind=real_kind) :: x real(kind=4) :: y4 real(kind=8) :: y8 real(kind=8) :: arg4 character(len=STRLEN) :: a logical :: l logical :: ll logical :: arg1 logical :: f logical :: s character(len=STRLEN) :: arg2 character(len=STRLEN) :: arg3","tags":"","loc":"program/cla_test.html","title":"cla_test – Fortran Program"},{"text":"Uses: mpi_module constants particle_info Variables Type Attributes Name Initial integer :: ct real(kind=dp) :: mp_elapsed Subroutines subroutine init_analysis () Arguments None subroutine commit_analysis () Arguments None subroutine analysis_single_frame (tindex0, ct, output_record) Arguments Type Intent Optional Attributes Name integer, intent(in) :: tindex0 integer, intent(in) :: ct integer, intent(in) :: output_record subroutine end_analysis () Arguments None","tags":"","loc":"program/particle_based_jdote.html","title":"particle_based_jdote – Fortran Program"}]}